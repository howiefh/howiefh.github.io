<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>净土</title>
  
  <subtitle>乐不在外而在心，心以为乐，则是境皆乐；心以为苦，则无境不苦。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://howiefh.github.io/"/>
  <updated>2020-05-02T14:28:14.486Z</updated>
  <id>http://howiefh.github.io/</id>
  
  <author>
    <name>howiefh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis 类型处理器</title>
    <link href="http://howiefh.github.io/2017/09/30/mybatis-enum-handler/"/>
    <id>http://howiefh.github.io/2017/09/30/mybatis-enum-handler/</id>
    <published>2017-09-30T09:44:42.000Z</published>
    <updated>2020-05-02T14:28:14.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近测试将 MyBatis 从 3.1.1 升级到 3.2.3 时遇到一个问题。原来可以正常工作的枚举类型处理器，抛异常了。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused <span class="symbol">by:</span> org.apache.ibatis.executor.result.<span class="symbol">ResultMapException:</span> Error attempting to get column <span class="string">'member_type'</span> from result set.  <span class="symbol">Cause:</span> java.lang.<span class="symbol">IllegalArgumentException:</span> No <span class="class"><span class="keyword">enum</span> <span class="title">code</span> '<span class="title">MERCHANT</span>'. <span class="title">class</span> <span class="title">com</span>...<span class="title">ChangeSceneType</span></span></span><br></pre></td></tr></table></figure><p>涉及的代码及配置信息如下：</p><a id="more"></a><p>mybatis-config.xml :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com...CodeEnumTypeHandler"</span> <span class="attr">alias</span>=<span class="string">"enumHandler"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他枚举配置... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com...CodeEnumTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"com...MemberType"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他枚举配置... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com...CodeEnumTypeHandler"</span> <span class="attr">javaType</span>=<span class="string">"com...ChangeSceneType"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mapper:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"XxxMap"</span> <span class="attr">type</span>=<span class="string">"com...XxxEntity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他属性配置... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"member_type"</span> <span class="attr">property</span>=<span class="string">"memberType"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"enumHandler"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他属性配置... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CodeEnumTypeHandler.java:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CodeEnumTypeHandler&lt;E</span> <span class="keyword">extends</span> <span class="title">Enum</span> <span class="title">&amp;</span> <span class="title">CodeEnum&gt;</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler&lt;E&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Class</span>&lt;<span class="type">E</span>&gt; <span class="class"><span class="keyword">type</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">E</span>&gt; enums;</span><br><span class="line"></span><br><span class="line">    public <span class="type">CodeEnumTypeHandler</span>(<span class="type">Class</span>&lt;<span class="type">E</span>&gt; <span class="class"><span class="keyword">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= <span class="class"><span class="keyword">type</span></span>;</span><br><span class="line">        <span class="type">E</span>[] es = <span class="class"><span class="keyword">type</span>.<span class="title">getEnumConstants</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (es == <span class="literal">null</span> || es.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="class"><span class="keyword">type</span>.<span class="title">getSimpleName</span>(<span class="params"></span>) <span class="title">+</span> " <span class="title">does</span> <span class="title">not</span> <span class="title">represent</span> <span class="title">an</span> <span class="title">enum</span> <span class="title">type</span>.")</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        enums = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">E</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">E</span> e: es) &#123;</span><br><span class="line">            enums.put(e.getCode(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">E</span> valueOf(<span class="type">String</span> code) &#123;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">E</span> e = enums.get(code);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"No enum code '"</span> + code + <span class="string">"'. "</span> + <span class="class"><span class="keyword">type</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void setNonNullParameter(<span class="type">PreparedStatement</span> ps, int i, <span class="type">E</span> e, <span class="type">JdbcType</span> jdbcType)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        ps.setString(i, e.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">E</span> getNullableResult(<span class="type">ResultSet</span> rs, <span class="type">String</span> columnName) <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        <span class="type">String</span> value = rs.getString(columnName);</span><br><span class="line">        <span class="keyword">return</span> valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">E</span> getNullableResult(<span class="type">ResultSet</span> rs, int columnIndex) <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        <span class="type">String</span> value = rs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">E</span> getNullableResult(<span class="type">CallableStatement</span> cs, int columnIndex) <span class="keyword">throws</span> <span class="type">SQLException</span> &#123;</span><br><span class="line">        <span class="type">String</span> value = cs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. org.apache.ibatis.builder.xml.XMLMapperBuilder<span class="function"><span class="keyword">#</span><span class="title">resultMapElement</span><span class="params">(<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">parsing</span>.<span class="variable">XNode</span>, <span class="variable">java</span>.<span class="variable">util</span>.<span class="variable">List</span>&lt;<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">mapping</span>.<span class="variable">ResultMapping</span>&gt;)</span></span></span><br><span class="line">2. org.apache.ibatis.builder.MapperBuilderAssistant<span class="function"><span class="keyword">#</span><span class="title">buildResultMapping</span><span class="params">(<span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">JdbcType</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;? <span class="variable">extends</span> <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">TypeHandler</span>&lt;?&gt;&gt;, <span class="variable">java</span>.<span class="variable">util</span>.<span class="variable">List</span>&lt;<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">mapping</span>.<span class="variable">ResultFlag</span>&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">boolean</span>)</span></span></span><br><span class="line">3. org.apache.ibatis.builder.MapperBuilderAssistant<span class="function"><span class="keyword">#</span><span class="title">buildResultMapping</span><span class="params">(<span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">JdbcType</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;? <span class="variable">extends</span> <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">TypeHandler</span>&lt;?&gt;&gt;, <span class="variable">java</span>.<span class="variable">util</span>.<span class="variable">List</span>&lt;<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">mapping</span>.<span class="variable">ResultFlag</span>&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">boolean</span>)</span></span></span><br><span class="line">4. org.apache.ibatis.builder.BaseBuilder<span class="function"><span class="keyword">#</span><span class="title">resolveTypeHandler</span><span class="params">(<span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;? <span class="variable">extends</span> <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">TypeHandler</span>&lt;?&gt;&gt;)</span></span></span><br><span class="line">5. org.apache.ibatis.type.TypeHandlerRegistry#getMappingTypeHandler</span><br></pre></td></tr></table></figure><p>DEBUG 跟踪代码发现是 BaseBuilder 和 TypeHandlerRegistry 两个类做了调整</p><p>通过 Github 上 TypeHandlerRegistry 类的变更记录，发现是 <a href="https://github.com/mybatis/mybatis-3/commit/e92c2a2f1aacce52d7c1470b9aaa524dc8e9d1e7#diff-f54f4f9d0324952c3d7545a3e7a4dbee" target="_blank" rel="noopener">commit e92c2a2</a> 这次提交引入了这些变更。注释说明了这次变更的原因在 <a href="https://github.com/mybatis/old-google-code-issues/issues/746" target="_blank" rel="noopener">issue #746</a> 中有记录。为了解决 Spring 注入依赖的问题，有了这次的代码变更。</p><p>可以看到缓存 TypeHandler 的 Map 有了变化</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, Map&lt;<span class="keyword">Type</span>, TypeHandler&lt;?&gt;&gt;&gt; REVERSE_TYPE_HANDLER_MAP = <span class="keyword">new</span> HashMap&lt;<span class="keyword">Class</span>&lt;?&gt;, Map&lt;<span class="keyword">Type</span>, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line">+  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = <span class="keyword">new</span> HashMap&lt;<span class="keyword">Class</span>&lt;?&gt;, TypeHandler&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p>原来查找具体的 TypeHandler 是先根据 TypeHandler.class 类查找到 <code>Map&lt;Type, TypeHandler&lt;?&gt;&gt;</code>，最后通过属性的 javaType 查找到 TypeHandler。所以之前的代码和配置运行是没问题。但是之后改成了直接通过 TypeHandler.class 找 TypeHandler，所以 <code>&lt;typeHandler handler=&quot;com...CodeEnumTypeHandler&quot; javaType=&quot;com...ChangeSceneType&quot; /&gt;</code> 之前枚举的 TypeHandler 配置都会被覆盖掉，会抛出 <code>No enum code &#39;MERCHANT&#39;. class com...ChangeSceneType</code> 异常也就很好理解了。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>既然是直接通过 TypeHandler.class 找 TypeHandler，那么就可以对每种枚举都实现一个对应的 TypeHandler 类。这样带来的问题也很明显，项目中有多少枚举就得写多少对应的 TypeHandler。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MemberTypeHandler</span> <span class="keyword">extends</span> <span class="title">CodeEnumTypeHandler&lt;MemberType&gt;</span> </span>&#123;</span><br><span class="line">    public <span class="type">MemberTypeHandler</span>(<span class="type">Class</span>&lt;<span class="type">MemberType</span>&gt; <span class="class"><span class="keyword">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="class"><span class="keyword">type</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 Github Issue 里翻 enum 相关的信息，在 <a href="https://github.com/mybatis/mybatis-3/issues/995" target="_blank" rel="noopener">Issue #995</a> 找到了一个完美的解决办法。就是去掉 <code>&lt;resultMap&gt;</code> 配置中的typeHandler 属性。也就是说指定 typeHandler 是没有必要的，为什么是这样呢？</p><p>在设置返回对象的属性值时有如下的调用顺序：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.executor</span><span class="selector-class">.resultset</span><span class="selector-class">.DefaultResultSetHandler</span><span class="selector-id">#applyPropertyMappings</span></span><br><span class="line">2. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.executor</span><span class="selector-class">.resultset</span><span class="selector-class">.DefaultResultSetHandler</span><span class="selector-id">#getPropertyMappingValue</span></span><br><span class="line">3. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.type</span><span class="selector-class">.BaseTypeHandler</span><span class="selector-id">#getResult</span>(<span class="selector-tag">java</span><span class="selector-class">.sql</span><span class="selector-class">.ResultSet</span>, <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span>)</span><br><span class="line">4. <span class="selector-tag">com</span>..<span class="selector-class">.CodeEnumTypeHandler</span><span class="selector-id">#getNullableResult</span>(<span class="selector-tag">java</span><span class="selector-class">.sql</span><span class="selector-class">.ResultSet</span>, <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span>)</span><br><span class="line">5. <span class="selector-tag">com</span>..<span class="selector-class">.CodeEnumTypeHandler</span><span class="selector-id">#valueOf</span></span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#getPropertyMappingValue</code> 中有几行代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final TypeHandler&lt;?&gt; typeHandler = propertyMapping.get<span class="constructor">TypeHandler()</span>;</span><br><span class="line">final String column = prepend<span class="constructor">Prefix(<span class="params">propertyMapping</span>.<span class="params">getColumn</span>()</span>, columnPrefix);</span><br><span class="line">return typeHandler.get<span class="constructor">Result(<span class="params">rs</span>, <span class="params">column</span>)</span>;</span><br></pre></td></tr></table></figure><p>通过 propertyMapping 找到了类型处理器，这个 propertyMapping 是通过遍历 <code>org.apache.ibatis.mapping.ResultMap</code> 的 <code>propertyResultMappings</code> 属性获得的。<code>ResultMap</code> 类对应于 Mapper 文件中的 <code>&lt;resultMap&gt;</code> 元素，<code>ResultMapping</code> 类对应于 <code>&lt;resultMap&gt;</code> 元素的子元素 <code>&lt;result&gt;</code>。</p><p><code>ResultMap</code> 类中有四个 <code>ResultMapping</code> 列表，<code>ResultMap</code> 实例是由内部类 <code>ResultMap.Builder</code> 构造的，通过其<code>build</code> 方法可以看出 <code>idResultMappings</code>，<code>constructorResultMappings</code>，<code>propertyResultMappings</code> 是 <code>resultMappings</code> 的一个子集。<code>resultMappings</code> 又是什么时候构造出来的呢。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">List</span>&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">List</span>&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">List</span>&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">List</span>&lt;ResultMapping&gt; propertyResultMappings;</span><br></pre></td></tr></table></figure><p><code>ResultMap</code> 构建的过程。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.builder</span><span class="selector-class">.xml</span><span class="selector-class">.XMLMapperBuilder</span><span class="selector-id">#resultMapElement</span>(<span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.parsing</span><span class="selector-class">.XNode</span>, <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.List</span>&lt;<span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.mapping</span><span class="selector-class">.ResultMapping</span>&gt;)</span><br><span class="line">2. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.builder</span><span class="selector-class">.ResultMapResolver</span><span class="selector-id">#resolve</span></span><br><span class="line">3. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.builder</span><span class="selector-class">.MapperBuilderAssistant</span><span class="selector-id">#addResultMap</span></span><br><span class="line">4. <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.mapping</span><span class="selector-class">.ResultMap</span><span class="selector-class">.Builder</span><span class="selector-id">#build</span></span><br></pre></td></tr></table></figure><p><code>ResultMapping</code> 也是由他的内部类<code>ResultMapping.Builder</code> 改造。它的构建的过程如下。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. org.apache.ibatis.builder.xml.XMLMapperBuilder<span class="function"><span class="keyword">#</span><span class="title">resultMapElement</span><span class="params">(<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">parsing</span>.<span class="variable">XNode</span>, <span class="variable">java</span>.<span class="variable">util</span>.<span class="variable">List</span>&lt;<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">mapping</span>.<span class="variable">ResultMapping</span>&gt;)</span></span></span><br><span class="line">2. org.apache.ibatis.builder.xml.XMLMapperBuilder#buildResultMappingFromContext</span><br><span class="line">3. org.apache.ibatis.builder.MapperBuilderAssistant<span class="function"><span class="keyword">#</span><span class="title">buildResultMapping</span><span class="params">(<span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;?&gt;, <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">JdbcType</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">Class</span>&lt;? <span class="variable">extends</span> <span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">type</span>.<span class="variable">TypeHandler</span>&lt;?&gt;&gt;, <span class="variable">java</span>.<span class="variable">util</span>.<span class="variable">List</span>&lt;<span class="variable">org</span>.<span class="variable">apache</span>.<span class="variable">ibatis</span>.<span class="variable">mapping</span>.<span class="variable">ResultFlag</span>&gt;, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">java</span>.<span class="variable">lang</span>.<span class="variable">String</span>, <span class="variable">boolean</span>)</span></span></span><br><span class="line">4. org.apache.ibatis.mapping.ResultMapping.Builder#build</span><br></pre></td></tr></table></figure><p><code>buildResultMapping</code> 方法会调用前面提到的 <code>BaseBuilder#resolveTypeHandler</code> 方法，而因为我们没有配置 typeHandler 属性，所以此时调用 <code>BaseBuilder#resolveTypeHandler</code> 只会返回 null。但是每个类型都应该有它对应的类型处理器，这个类型处理器是什么时候构建出来的。<code>ResultMapping.Builder#build</code> 方法中就能找到答案了，这个方法会调用<code>ResultMapping.Builder#resolveTypeHandler</code>，如果它发现执行到这里 <code>ResultMapping</code> 的 <code>typeHandler</code> 属性还为 null，就会调用 <code>typeHandlerRegistry.getTypeHandler(resultMapping.javaType, resultMapping.jdbcType)</code>，这个方法和前面提到的同名方法是有区别的。它是从 <code>TYPE_HANDLER_MAP</code> 中取的 typeHandler，而前面是 <code>ALL_TYPE_HANDLERS_MAP</code>。<code>TYPE_HANDLER_MAP</code> 中存储的是属性的 javaType 和 jdbcType 与 typeHandler 映射的映射关系，可能有点拗口，也就是通过属性的 javaType 和 jdbcType 就可以找到它对应的类型处理器，而后者<br><code>ALL_TYPE_HANDLERS_MAP</code> 存储的是 TypeHandler.class 和 TypeHandler 实例的映射关系。</p><p>总结一下，不必配置<code>&lt;result&gt;</code> 元素的 typeHandler 属性是因为这样避免了通过 typeHandler 属性值(在本例中就是之前的enumHandler)找对应的 TypeHandler 实例，而是通过 javaType 和 jdbcType (在本例终究是MemberType枚举和VARCHAR) 找到对应的 TypeHandler 实例。</p><p>最后一个问题。TypeHandlerRegistry 中存储的映射关系又是什么时候注册进来的呢。 从方法<code>org.apache.ibatis.builder.xml.XMLConfigBuilder#typeHandlerElement</code>里可以找到答案。</p>]]></content>
    
    <summary type="html">
    
      MyBatis 类型处理器, MyBatis, 类型处理器, 枚举
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="MyBatis" scheme="http://howiefh.github.io/categories/Java/MyBatis/"/>
    
    
      <category term="Java" scheme="http://howiefh.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://howiefh.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven 总结</title>
    <link href="http://howiefh.github.io/2017/09/29/maven/"/>
    <id>http://howiefh.github.io/2017/09/29/maven/</id>
    <published>2017-09-29T14:06:33.000Z</published>
    <updated>2020-05-02T14:28:14.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Apache Maven 是一个项目构建、管理工具。基于项目对象模型（POM）的概念，Maven可以用来管理项目的依赖、编译、文档等信息。</p><p>Maven 提倡的是“约定优于配置”，基于这种理念，很多事情会变的简单起来，比如看到 <code>src/main/java</code> 你就知道这目录下是 Java 源文件，你也不必为了构建项目过多地配置插件。Maven 中的 Super POM 中指定了项目默认的目录结构、输出目录、常用插件版本配置等，所有的 POM 都会隐式地继承它（Super POM 有点像是 Java 中的 Object）。下面是一个简单的 POM 文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- POM对象模型版本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 项目坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.howiefh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 项目坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 项目依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>Maven 坐标定义了一组标识，它们可以用来唯一标识一个项目，一个依赖，或者 Maven POM 里的一个插件。 groupId, artifactId, version 和 packaging 这些组合的标识符拼成了一个项目的坐标。</p><ul><li>groupId<br>  团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。</li><li>artifactId<br>  在groupId下的表示一个单独项目的唯一标识符。</li><li>version<br>  一个项目的特定版本。正在开发中的项目会加一个“SNAPSHOT”的标记。</li><li>packaging<br>  项目的类型，默认是 jar，还可以是 war，ear。pom 类型比较特殊，涉及到后面提及的继承、聚合两个概念。packaging 是坐标的一部分，但不是项目唯一标识的一部分。</li></ul><p>还有一个限定符 classifier （分类器） 用于同样的代码生成多个单独的构件的场景。比如同时生成 JavaDoc 和二进制 JAR 包。</p><h2 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h2><p>为了能用一条命令就能构建 demo-common 和 demo-dao 两个模块，我们需要建立一个额外的名为 demo-aggregator 的模块，然后通过该模块构建整个项目的所有模块。demo-aggregator本身也是个 Maven 项目，它的 POM 如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.howiefh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-aggregator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo Aggregator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：packaging 的类型为 pom，module 的值是一个以当前 POM 为主目录的相对路径。</p><p>如果多个项目中使用很多相同的配置，可以考虑把公共配置放入父 POM， 子项目继承父 POM 实现配置复用.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.howiefh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> <span class="comment">&lt;!-- 仅为了说明用法，有点多余，Maven也会从这里找父POM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo Common<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个 Maven POM 从它父POM中继承的项目列表：</p><ul><li>定义符（groupId和artifactId中至少有一个必须被覆盖， 上面的配置中并没写groupId和version，会从父POM继承）</li><li>依赖</li><li>开发者和贡献者</li><li>插件列表项目对象模型</li><li>报告列表</li><li>插件执行 （id匹配的执行会被合并）</li><li>插件配置</li></ul><p>Maven 假设父 POM 在本地仓库中可用，或者在当前项目的父目录(../pom.xml) 中可用。 如果两个位置都不可用，默认行为还可以通过relativePath元素被覆盖。</p><p>注意：模块并不等于子项目。但是聚合和继承一般会组合使用。</p><p>区别：</p><ol><li>对于聚合来说，它知道有哪些模块被聚合，但被聚合的模块不知道这个聚合的存在。</li><li>对于继承关系的父 POM 来说，它不知道有哪些子项目继承它，但那些子项目都知道自己的父 POM 是什么。</li></ol><p>共同点：</p><ol><li>聚合 POM 与继承关系中的父 POM 的 packaging 都是 pom</li><li>聚合与继承关系中的父模块除了 POM 之外都没有实际的内容。</li></ol><p>一般公司会维护一个父 POM，不同的团队的项目都继承这个父 POM 并且一般也会维护一个自己团队的父 POM。继承关系如下</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">Super</span> <span class="comment">POM</span> --<span class="literal">-</span><span class="comment">被隐式继承</span>--<span class="literal">-</span>&gt; <span class="comment">xxx</span><span class="literal">-</span><span class="comment">company</span><span class="literal">-</span><span class="comment">parent</span> --<span class="literal">-</span><span class="comment">被显示继承</span>--<span class="literal">-</span>&gt; <span class="comment">xxx</span><span class="literal">-</span><span class="comment">project</span><span class="literal">-</span><span class="comment">parent</span></span><br></pre></td></tr></table></figure><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖范围控制哪些依赖在哪些classpath（编译classpath、测试classpath、运行classpath）中可用，哪些依赖包含在一个应用中。</p><ul><li>compile（编译范围）<br>  compile是默认的范围；编译范围依赖在所有的classpath中可用。</li><li>provided（已提供范围）<br>  provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</li><li>runtime（运行时范围）<br>  runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</li><li>test（测试范围）<br>  test范围依赖在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</li><li>system（系统范围）<br>  该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。</li><li>import(Maven 2.0.9及以上)<br>  导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。</li></ul><table><thead><tr><th>scope</th><th>main-classpath</th><th>test-classpath</th><th>runtime-classpath</th><th>example</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>slf4j</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>mysql-jdbc-driver</td></tr></tbody></table><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><h3 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h3>]]></content>
    
    <summary type="html">
    
      maven
    
    </summary>
    
    
      <category term="java" scheme="http://howiefh.github.io/categories/java/"/>
    
    
      <category term="maven" scheme="http://howiefh.github.io/tags/maven/"/>
    
      <category term="java" scheme="http://howiefh.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Git 内幕</title>
    <link href="http://howiefh.github.io/2016/05/16/git-internals/"/>
    <id>http://howiefh.github.io/2016/05/16/git-internals/</id>
    <published>2016-05-16T12:51:10.000Z</published>
    <updated>2020-05-04T11:16:04.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="对待数据的方式"><a href="#对待数据的方式" class="headerlink" title="对待数据的方式"></a>对待数据的方式</h3><p>几乎所有版本控制工具都是记录与初始文件的差异，而 Git 是记录快照，每次提交更新时，就是当前工作目录下的所有文件的完整数据，而不是差异，当然如果提交时，文件没有被修改，不再重新存储该文件，而是指向上次存储的文件。</p><p>假设提交了5次，对于工作目录的文件A，在第三和第五次提交时有修改</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 其他版本控制</span><br><span class="line">A (<span class="function"><span class="title">v1</span>) --------------&gt;</span> △<span class="number">1</span> (<span class="function"><span class="title">v3</span>) ---------------&gt;</span> △<span class="number">2</span> (v5)</span><br><span class="line"># Git</span><br><span class="line">A (<span class="function"><span class="title">v1</span>) ---&gt;</span> A (<span class="function"><span class="title">v2</span>) ---&gt;</span> A1 (<span class="function"><span class="title">v3</span>) ---&gt;</span> A1 (<span class="function"><span class="title">v4</span>) ---&gt;</span> A2 (v5)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符组成字符串，基于 Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><h3 id="三种状态-amp-三棵树"><a href="#三种状态-amp-三棵树" class="headerlink" title="三种状态&amp;三棵树"></a>三种状态&amp;三棵树</h3><p>Git 有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中，又可以分为未暂存已修改和未提交已修改。已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>查看精简的状态</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">MM <span class="module-access"><span class="module"><span class="identifier">README</span>.</span></span>md</span><br></pre></td></tr></table></figure><p>结果前面的标记表示状态。</p><ul><li><code>??</code> 新添加的未跟踪文件前面有<code>??</code>标记</li><li>A 新添加到暂存区中的文件前面有A标记</li><li>M 修改过的文件前面有M标记，出现在右边表示未暂存已修改、出现在左边表示已暂存但是未提交已修改。</li></ul><p>由此引入 Git 的三棵树的概念：HEAD、索引（index）以及工作目录。</p><p>先说一下两个重要的目录，工作目录和仓库目录。工作目录是你运行<code>git init</code>的目录，是对项目的某个版本独立提取出来的内容。Git 仓库目录（<code>.git</code>，通常这是个隐藏文件夹）是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>HEAD 和 index 对应着仓库目录下的两个文件，<code>.git/HEAD</code>和<code>.git/index</code>。</p><p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。可以将它看做<strong>你的上一次提交</strong>的快照。想看HEAD快照的实际目录列表可以通过命令<code>git ls-tree -r HEAD</code></p><p>索引（index，暂存区域）是一个文件，保存了下次将提交的文件列表信息。可以将它看做<strong>预期的下一次提交</strong>。<code>git ls-files -s</code>命令可以查看索引的目录列表。</p><p>HEAD和index这两棵树高效但不直观，工作目录就相当直观了，可以把工作目录当做<strong>沙盒</strong>。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改文件。</li><li>暂存文件，<strong>将文件的快照放入暂存区域</strong>。（对应<code>git add</code>命令，生成blob对象，添加索引）</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。（对应<code>git commit</code>命令，生成树对象、提交对象）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/git-tree.jpg" alt="三棵树"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为index的区域是暂存区（stage，亦称index），标记为master的是master分支所代表的目录树。</li><li>图中可以看出此时HEAD实际是指向master分支的一个“游标”。所以图示的命令中出现HEAD的地方可以用master来替换。</li><li>图中的objects标识的区域为Git的对象库，实际位于<code>.git/objects</code>目录下。</li><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（<code>git commit</code>）时，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新。即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached &lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或者<code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或者<code>git checkout HEAD &lt;file&gt;</code>命令时，会用HEAD指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>假设你在分支hotfix上进行了紧急修复，并进行了提交，这时master分支和hotfix分别指向C2和C3。你需要切换回master分支，将修改的内容合并回master分支，执行<code>git merge hotfix</code>。在合并的时候，你会发现”快进（fast-forward）”这个词。由于当前 master 分支所指向的提交是你当前提交（hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），这种情况下不需要解决分歧。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">               <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>  <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">               <span class="comment">|</span> <span class="comment">master</span> <span class="comment">|</span>  <span class="comment">|</span> <span class="comment">hotfix</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>               <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>  <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                    <span class="comment">|</span>         <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                    <span class="comment">v</span>         <span class="comment">v</span></span><br><span class="line"><span class="comment"></span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">|</span> <span class="comment">C0</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C1</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C2</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C4</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                     <span class="comment">^</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">|</span>     <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                     <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span> <span class="comment">c3</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                           <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                              <span class="comment">^</span></span><br><span class="line"><span class="comment"></span>                          <span class="literal">+</span>--<span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                          <span class="comment">|</span> <span class="comment">iss53</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                          <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><p>你还有一个分支iss53在解决 issue#53 的问题。做完hotfix后，iss53上的工作也完成了，并且有了一次新的提交（C5），你需要将这个分支也合并到master上，和之前合并hotfix不同，现在你的iss53和master已经出现分叉了。出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                                        <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                                        <span class="comment">|</span> <span class="comment">master</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                                        <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                                             <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                                             <span class="comment">v</span></span><br><span class="line"><span class="comment"></span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>         <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">|</span> <span class="comment">C0</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C1</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C2</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C4</span> <span class="comment">|</span>&lt;--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span> <span class="comment">C6</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>         <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                     <span class="comment">^</span>                       <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">|</span>     <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                     <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span> <span class="comment">C3</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C5</span> <span class="comment">|</span>&lt;--<span class="literal">+</span></span><br><span class="line">                           <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                                       <span class="comment">^</span></span><br><span class="line"><span class="comment"></span>                                   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                                   <span class="comment">|</span> <span class="comment">iss53</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                                   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><p>如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突。此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决冲突。 在合并冲突后的任意时刻可以使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。</p><p>可以通过<code>git mergetool</code>使用图形化工具解决冲突，也可以直接对冲突文件进行修改，解决冲突。</p><p>在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。如果所有冲突已经解决，就可以提交这次合并了。</p><h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>Git 有很多合并策略，可以在合并时候指定合并策略，不指定的话，Git也会使用它认为合适的策略完成合并。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [-s <span class="tag">&lt;<span class="name">strategy</span>&gt;</span>] [-X <span class="tag">&lt;<span class="name">strategy-option</span>&gt;</span>] <span class="tag">&lt;<span class="name">commit</span>&gt;</span>...</span><br></pre></td></tr></table></figure><p>其中参数-s用于设定合并策略，参数-X用于为所选的合并策略提供附加的参数。</p><p>Git的合并策略：</p><ul><li>resolve<br>  该合并策略只能用于合并两个头（即当前分支和另外的一个分支），使用三向合并策略。这个合并策略被认为是最安全、最快的合并策略。</li><li>recursive<br>  该合并策略只能用于合并两个头（即当前分支和另外的一个分支），使用三向合并策略。这个合并策略是合并两个头指针时的默认合并策略。<br>  当合并的头指针拥有一个以上的祖先的时候，会针对多个公共祖先创建一个合并的树，并以此作为三向合并的参照。这个合并策略被认为可以实现冲突的最小化，而且可以发现和处理由于重命名导致的合并冲突。<br>  这个合并策略可以使用下列选项。<ul><li>ours<br>  在遇到冲突的时候，选择我们的版本（当前分支的版本），而忽略他人的版本。如果他人的改动和本地改动不冲突，会将他人改动合并进来。<br>  不要将此模式和后面介绍的单纯的ours合并策略相混淆。后面介绍的ours合并策略直接丢弃其他分支的变更，无论冲突与否。</li><li>theirs<br>  和ours选项相反，遇到冲突时选择他人的版本，丢弃我们的版本。</li><li>subtree[=path]<br>  这个选项使用子树合并策略，比下面介绍的subtree（子树合并）策略的定制能力更强。下面的subtree合并策略要对两个树的目录移动进行猜测，而recursive合并策略可以通过此参数直接对子树目录进行设置。</li></ul></li><li>octopus<br>  可以合并两个以上的头指针，但是拒绝执行需要手动解决的复杂合并。主要的用途是将多个主题分支合并到一起。这个合并策略是对三个及三个以上头指针进行合并时的默认合并策略。</li><li>ours<br>  可以合并任意数量的头指针，但是合并的结果总是使用当前分支的内容，丢弃其他分支的内容。</li><li>subtree<br>  这是一个经过调整的recursive策略。当合并树A和B时，如果B和A的一个子树相同，B首先进行调整以匹配A的树的结构，以免两棵树在同一级别进行合并。同时也针对两棵树的共同祖先进行调整。</li></ul><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>除了使用<code>git merge</code>合并分支，还有其它方法：可以提取在 C4 中引入的补丁和修改，然后在 C5 的基础上再应用一次。 在 Git 中，这种操作就叫做变基。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout iss53</span><br><span class="line">git rebase <span class="keyword">master</span>  <span class="title"># 以master</span>为基（<span class="literal">master</span>原有的提交不会变），重做iss53的提交</span><br></pre></td></tr></table></figure><p>变基原理是首先找到这两个分支（即当前分支 iss53、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C4, 最后以此将之前另存为临时文件的修改依序应用，应用完后当前分支（iss53）也就指向了最后一个提交（C5’）。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                        <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                        <span class="comment">|</span> <span class="comment">master</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                        <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                             <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                             <span class="comment">v</span></span><br><span class="line"><span class="comment"></span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">|</span> <span class="comment">C0</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C1</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C2</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C4</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C3'|</span>&lt;--<span class="literal">+</span> <span class="comment">C5'|</span></span><br><span class="line"><span class="comment"></span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                     <span class="comment">^</span>                          <span class="comment">^</span></span><br><span class="line"><span class="comment"></span>                     <span class="comment">|</span>     <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>      <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                     <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span> <span class="comment">C3</span> <span class="comment">|</span>&lt;--<span class="literal">+</span> <span class="comment">C5</span> <span class="comment">|</span>  <span class="literal">+</span>--<span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                           <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="literal">+</span>--<span class="literal">+</span><span class="literal">-</span><span class="literal">+</span>  <span class="comment">|</span> <span class="comment">iss53</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                                            <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><p>注意上图的线性分支上并不是 <code>C3&#39;&lt;--C4&lt;--C5&#39;</code>（假设以数字大小表示提交时间的先后，数字小提交时间更早）。rebase把iss53的基础定为master（C4），将iss53的修改（C3，C5）重做一遍，提交记录不再按时间排序了，而且提交的哈希值已经变了。看上去像是直接将iss53的修改拼接到master后面了，但是我觉得最好不要这样理解，拼接和重做还是有区别的，重做后C3’，C5’哈希值已经变了（作者、提交说明这些没变）。</p><p>现在回到 master 分支，进行一次快进合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge iss53</span><br></pre></td></tr></table></figure><p>此时C5’指向的对象就和<code>merge</code>指向的快照一样了。</p><p>使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 iss53）变基到目标分支（即 master）上。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase <span class="keyword">master</span> <span class="title">iss53</span></span><br><span class="line"><span class="comment"># 然后再执行</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge iss53</span><br></pre></td></tr></table></figure><p>为什么不是直接在master分支上<code>git rebase iss53</code>？我的理解是这条命令是以iss53为基，重做master上的提交（C2之后的提交）。效果上和上面的操作结果是一样的，master分支最后包含了iss53上的更改，而且只用了一条命令。执行这条命令后会是这样：<code>C0 &lt;-- C1 &lt;-- C2 &lt;-- C3 &lt;-- C5(iss53) &lt;-- C4&#39;(master)</code>，而远程master应该还是这样<code>C0 &lt;-- C1 &lt;-- C2 &lt;-- C4</code>。本地分支和远程分支在C2后分叉了，你不得不再去解决这个问题。而且这样会改变master分支上之前的提交，<code>C4&#39;</code>已经不是<code>C4</code>了，尽管内容没太大区别。</p><p><code>--onto</code>选项，取出（checkout） b 分支，找出处于 b 分支和 a 分支的共同祖先之后的修改（在b分支上而不在a分支上的修改），然后把它们在 master 分支上重演一遍。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto <span class="keyword">master</span> <span class="title">a</span> b</span><br></pre></td></tr></table></figure><p><strong>变基有风险，不要对在你的仓库外有副本的分支执行变基（不要对推送至远程仓库的提交执行变基）。</strong>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>git rebase 与git merge 区别：</p><ol><li>历史记录不同： rebase是简洁的，历史记录是线性的，但commit不是按照日期排序，重做后的提交的哈希值也改变了。merge之后历史记录是非线性的看着比较复杂，但是commit按日期排序，每个提交还是原来的提交。</li><li>merge会多一次提交，merge 后还需要再提交一次，rebase不需要。</li></ol><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。Git 提供了底层命令和高层命令，我们平时使用的checkout、branch、remote都是高层命令，底层命令我们平时可能接触不到，这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。底层命令可以帮助我们了解Git是怎么工作的。</p><p>先看一下<code>git init</code>命令后<code>.git</code>目录的内容。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -F1</span><br><span class="line">HEAD</span><br><span class="line">config*</span><br><span class="line">description</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line"><span class="built_in">ref</span>s/</span><br></pre></td></tr></table></figure><p>config 文件包含项目特有的配置选项。 info 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。 hooks 目录包含客户端或服务端的钩子脚本（hook scripts）。</p><p>剩下的四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。 这些条目是 Git 的核心组成部分。 objects 目录存储所有数据内容；refs 目录存储指向数据（分支）的提交对象的指针；HEAD 文件指示目前被检出的分支；index 文件保存暂存区信息。 我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</p><h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git 是一个内容寻址文件系统。意味着 Git 的核心部分是一个简单的键值对数据库（key-value data store）。通过实践体会一下，执行下面任一条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin <span class="comment"># -w表示存储数据对象，--stdin表示从终端读数据</span></span><br><span class="line">git <span class="built_in">hash</span>-object -w test.txt                      <span class="comment"># 保存test.txt的数据</span></span><br></pre></td></tr></table></figure><p>会返回一个哈希码<code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code>，这个就是键，看一下是怎么存储，打开<code>.git/objects/</code>会发现<code>d6</code>目录，然后目录里面有文件<code>70460b4b4aece5915caf5c68d12f560a9fe3e4</code>， 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。有了键，怎么取值呢，用<code>git cat-file -p &lt;key&gt;</code>，执行<code>git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</code>就会输出之前的数据内容。<code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示格式友好的内容。</p><p>Git 中的对象的格式大致是这样的<code>&lt;对象类型&gt;&lt;空格&gt;&lt;内容的字节数&gt;&lt;\0&gt;&lt;内容&gt;</code>，看一下commit、tree、blob、tag（附注标签）这四种对象（blob对象对应一个文件，tree对象对应一个目录）的内容吧，Git中的对象文件是通过zlib压缩的，所以要看内容你还得解压。</p><p>看一下数据对象<code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code>对应文件的内容，对象类型是blob，然后一个空格，然后是长度13，后面一个字节的值是0，”test content”是12个字节，还有最后一个字节值是<code>10</code>也就是<code>\n</code>换行符，加起来就是13个字节了，注意blob下面应该还有一个空行</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob <span class="number">13</span>\<span class="number">0</span>test content\n</span><br></pre></td></tr></table></figure><p>如果你对上面的内容用SHA1加密，得到的结果就是<code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></p><p>提交对象<code>253e0582cd4b955b53cbcc2011197e028c31518b</code>的内容如下，commit对象内容包含了tree对象<code>a2310bc7e99afc10f781b87fa87bfe6b6447a4ec</code>、作者、提交者、提交信息</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit <span class="number">170</span>\<span class="number">0</span>tree a2310bc7e99afc10f781b87fa87bfe6b6447a4ec</span><br><span class="line">author Feng Hao &lt;<span class="symbol">howiefh@</span>gmail.com&gt; <span class="number">1462757839</span> +<span class="number">0800</span></span><br><span class="line">committer Feng Hao &lt;<span class="symbol">howiefh@</span>gmail.com&gt; <span class="number">1462757839</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">add index.htm\n</span><br></pre></td></tr></table></figure><p>tree对象<code>a2310bc7e99afc10f781b87fa87bfe6b6447a4ec</code>内容如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree <span class="number">37</span>\<span class="number">0100644</span> index.htm\<span class="number">0</span>S??B?I/x?wy?a???</span><br></pre></td></tr></table></figure><p>100644是文件模式，然后是文件名，然后又是一个<code>\0</code>字节，后面的乱码是什么呢？是index.htm对应的blob对象哈希值，是直接以二进制存的，而不是转成十六进制的字符串，所以看着是一堆乱码，看一下下面的字节数组，从83开始就是这个哈希值<code>53a7f2429549142f78b7777904b26102858d9716</code>。可以使用<code>git ls-tree -r &lt;object&gt;</code>查看树对象的内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">51</span>, <span class="number">55</span>, <span class="number">0</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">54</span>, <span class="number">52</span>, <span class="number">52</span>, <span class="number">32</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">120</span>, <span class="number">46</span>, <span class="number">104</span>, <span class="number">116</span>, <span class="number">109</span>, <span class="number">0</span>, <span class="number">83</span>, <span class="number">-89</span>, <span class="number">-14</span>, <span class="number">66</span>, <span class="number">-107</span>, <span class="number">73</span>, <span class="number">20</span>, <span class="number">47</span>, <span class="number">120</span>, <span class="number">-73</span>, <span class="number">119</span>, <span class="number">121</span>, <span class="number">4</span>, <span class="number">-78</span>, <span class="number">97</span>, <span class="number">2</span>, <span class="number">-123</span>, <span class="number">-115</span>, <span class="number">-105</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure><p>再看下<code>53a7f2429549142f78b7777904b26102858d9716</code>的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blob 45\0<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>\n</span><br></pre></td></tr></table></figure><p>附注标签对象<code>2232ed02d3a75f2027c5a31728c36a4d32c20b25</code>（<code>.git/refs/tags</code>这里可以找到对应tag文件，文件内容就是对应tag的哈希值）内容如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tag <span class="number">138</span>\<span class="number">0</span>object <span class="number">253e0582</span>cd4b955b53cbcc2011197e028c31518b</span><br><span class="line">type commit</span><br><span class="line">tag <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line">tagger Feng Hao &lt;<span class="symbol">howiefh@</span>gmail.com&gt; <span class="number">1462847525</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">version <span class="number">0.0</span><span class="number">.1</span>\n</span><br></pre></td></tr></table></figure><p>可以看到tag对象内容包含了上面commit对象的引用<code>253e0582cd4b955b53cbcc2011197e028c31518b</code></p><p>总结一下，一个commit对象包含了一条tree对象（工作目录的根目录）记录，一个tree对象包含一条或多条树对象或blob对象记录。一个数据对象对应一个文件，包含了文件内容。</p><p>下面通过底层命令进行一次提交</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个文件</span><br><span class="line"><span class="built_in">mkdir</span> src</span><br><span class="line"><span class="keyword">vim</span> src/<span class="built_in">index</span>.htm</span><br><span class="line"># 添加到暂存区 git <span class="built_in">add</span> src/<span class="built_in">index</span>.htm</span><br><span class="line">git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> src/<span class="built_in">index</span>.htm</span><br><span class="line"># 记录下目录树（将当前暂存区的状态记录为一个树对象）</span><br><span class="line">git <span class="keyword">write</span>-tree</span><br><span class="line"># 创建一次提交 d71a1bbe2730a62e875a7e242584a48d8681b0cd是上一步返回的哈希码</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'first commit'</span> | git commit-tree d71a1bbe2730a62e875a7e242584a48d8681b0cd</span><br><span class="line"># 验证 <span class="number">8</span>f97c86c8f07bfdae3a628ed8bf33829d7cf71dd 上一步返回的哈希码</span><br><span class="line">git <span class="built_in">log</span> --stat <span class="number">8</span>f97c86c8f07bfdae3a628ed8bf33829d7cf71dd</span><br></pre></td></tr></table></figure><p>下面是此时对象的关系，正如前文提到的，对于一次提交只有改变了的文件或目录才需要重新生成对象，<code>blob e738</code>就是之前生成的对象，其它对则是这次更新后新生成的。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">        <span class="comment">|commit</span>  <span class="comment">8f97|</span></span><br><span class="line"><span class="comment"></span>        <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">             <span class="string">.</span><span class="comment">/</span></span><br><span class="line"><span class="comment"></span>              <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>         <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="comment">v</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">      <span class="literal">+</span>--<span class="literal">+</span> <span class="comment">tree</span> <span class="comment">d71a</span><span class="literal">+</span>--<span class="literal">+</span></span><br><span class="line"><span class="comment">index</span><span class="string">.</span><span class="comment">htm</span><span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>  <span class="comment">src</span></span><br><span class="line"><span class="comment"></span>      <span class="comment">|</span>                <span class="comment">|</span></span><br><span class="line"><span class="comment"></span> <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="comment">v</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>      <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="comment">v</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"> <span class="comment">|blob</span> <span class="comment">e738|</span>      <span class="comment">|tree</span> <span class="comment">a231|</span></span><br><span class="line"><span class="comment"></span> <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>      <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                    <span class="comment">index</span><span class="string">.</span><span class="comment">htm</span></span><br><span class="line"><span class="comment"></span>                       <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                  <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="comment">v</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line">                  <span class="comment">|blob</span> <span class="comment">53a7|</span></span><br><span class="line"><span class="comment"></span>                  <span class="literal">+</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Git 中的引用位于<code>.git/refs</code>中，分支引用位于<code>.git/refs/heads</code>中，远程分支引用位于<code>.git/refs/remotes</code>中，标签引用位于<code>.git/refs/tags</code>。对于前两者是可变的，分支引用是一个指向某一系列提交之首的指针或引用，每有提交就会向前推进。远程分支引用和分支引用最大区别是它是只读的，它在向远程服务器推送或拉去分支时才会变化。虽然可以 git checkout 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 commit 命令来更新远程引用。 Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。标签引用是固定的引用，它的内容不会随着你提交而变化，附注标签和轻量标签区别在于，附注标签引用指向了标签对象，而轻量标签引用指向的是提交对象（创建轻量引用并不会创建标签对象）</p><p>通过<code>git update-ref</code>更新分支引用、轻量标签引用</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git update-<span class="built_in">ref</span> <span class="built_in">ref</span>s/heads/master <span class="number">8f</span>97c86c8f07bfdae3a628ed8bf33829d7cf71dd</span><br><span class="line">git update-<span class="built_in">ref</span> <span class="built_in">ref</span>s/tags/v1<span class="number">.0</span> <span class="number">8f</span>97c86c8f07bfdae3a628ed8bf33829d7cf71dd</span><br></pre></td></tr></table></figure><p>还有一个引用就是 HEAD 引用，位于<code>.git/HEAD</code>。HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。 下面是 HEAD 文件的内容</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line"><span class="built_in">ref</span>: <span class="built_in">ref</span>s/heads/master</span><br></pre></td></tr></table></figure><p>通过<code>git symbolic-ref</code>可以查看或者更新HEAD引用的值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git symbolic-<span class="built_in">ref</span> HEAD</span><br><span class="line">git symbolic-<span class="built_in">ref</span> HEAD <span class="built_in">ref</span>s/heads/test</span><br></pre></td></tr></table></figure><p>当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 update-ref 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。Git 就是通过HEAD文件知道当前所在分支最新提交的 SHA-1 值的。</p><h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>正如前面说的，Git 是记录快照，数据对象中保存着完整的文件内容，这样如果有文件比较大，比如十几KB，那么对文件做一次很小的更改，在Git就会保存两个十几KB的数据对象，这有点浪费空间，Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。其实 Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。当版本库中有太多的松散对象，或者执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时，Git 都会这样做。要看到打包过程，可以执行 <code>git gc</code> 命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git gc</span></span><br></pre></td></tr></table></figure><p>你会发现<code>.git/objects</code>目录下的数据对象都消失了（未被引用的对象除外）。然后还多了两个pack文件。git verify-pack 这个底层命令可以让你查看已打包的内容：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">verify</span>-<span class="built_in">pack</span> -v .git/objects/<span class="built_in">pack</span>/<span class="built_in">pack</span>-<span class="number">9</span>78e03944f5c581011e6998cd0e9e30000905586.idx</span><br></pre></td></tr></table></figure><p>可以观察下输出中一行有两个哈希码的行，Git已经帮你进行差量保存。比如下面 033b4 这个数据对象引用了数据对象 b042a，即文件的第二个版本。 命令输出内容的第三列显示的是各个对象在包文件中的大小，可以看到 b042a 占用了 22K 空间，而 033b4 仅占用 9 字节。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b042a60ef7dff760008df33cee372b945b6e884e blob   <span class="number">22054</span> <span class="number">5799</span> <span class="number">1463</span></span><br><span class="line"><span class="number">033</span>b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   <span class="number">9</span> <span class="number">20</span> <span class="number">7262</span> <span class="number">1</span> b042a60ef7dff760008df33cee372b945b6e884e</span><br></pre></td></tr></table></figure><p><code>git gc</code>也把引用给打包了，<code>.git/refs</code>现在也空了，多了一个文件<code>.git/packed-refs</code>。如果你更新了引用，Git 并不会修改这个文件，而是向 <code>.git/refs/</code> 创建一个新的文件。如果Git在<code>.git/refs</code>目录下找不到引用，就会到<code>.git/packed-refs</code>中查找。</p><h3 id="引用规格（refspec）"><a href="#引用规格（refspec）" class="headerlink" title="引用规格（refspec）"></a>引用规格（refspec）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/schacon/simplegit-progit</span><br></pre></td></tr></table></figure><p>上述命令会在 <code>.git/config</code> 文件中添加一个小节，并在其中指定远程版本库的名称（origin）、URL 和一个用于获取操作的引用规格（refspec）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/schacon/</span>simplegit-progit</span><br><span class="line">    fetch = +refs<span class="regexp">/heads/</span>*:refs<span class="regexp">/remotes/</span>origin<span class="regexp">/*</span></span><br></pre></td></tr></table></figure><p>引用规格的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<code>&lt;dst&gt;</code> 是那些远程引用在本地所对应的位置。<code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">X</span>--<span class="literal">-</span><span class="comment">Y</span>--<span class="literal">-</span><span class="comment">Z</span>  <span class="comment">远程服务器上的分支master</span></span><br><span class="line"><span class="comment"></span>        <span class="comment">/</span></span><br><span class="line"><span class="comment">o</span>--<span class="literal">-</span><span class="comment">o</span>--<span class="literal">-</span><span class="comment">o</span>--<span class="literal">-</span><span class="comment">A</span>--<span class="literal">-</span><span class="comment">B</span>  <span class="comment">本地远程分支引用origin/dev</span></span><br></pre></td></tr></table></figure><p><code>git fetch origin +refs/heads/master:refs/remotes/origin/dev</code>将使<code>origin/dev</code>指向Z，不加<code>+</code>的话你会得到这样的信息<code>! [rejected]        master     -&gt; origin/dev  (non-fast-forward)</code>。</p><p>默认情况下，引用规格由 <code>git remote add</code> 命令自动生成， Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code> 中。</p><p>下面三条命令实际是一样的，Git 会把它们都扩展成 refs/remotes/origin/master</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log origin/<span class="literal">master</span></span><br><span class="line">git log remotes/origin/<span class="literal">master</span></span><br><span class="line">git log refs/remotes/origin/<span class="literal">master</span></span><br></pre></td></tr></table></figure><p>如果想让 Git 每次只拉取远程的 master 分支，而不是所有分支，可以把（引用规格的）获取那一行修改为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs<span class="regexp">/heads/</span><span class="string">master:</span>refs<span class="regexp">/remotes/</span>origin/master</span><br></pre></td></tr></table></figure><p>你也可以指定多个引用规格。 在命令行中，你可以按照如下的方式拉取多个分支：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin <span class="string">master:</span>refs<span class="regexp">/remotes/</span>origin<span class="regexp">/mymaster topic:refs/</span>remotes<span class="regexp">/origin/</span>topic</span><br></pre></td></tr></table></figure><p>不能在模式中使用部分通配符，下面是不合法的：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/qa*<span class="symbol">:refs/remotes/origin/qa*</span></span><br></pre></td></tr></table></figure><p>但可以使用命名空间（或目录）来达到类似目的。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/qa/*<span class="symbol">:refs/remotes/origin/qa/*</span></span><br></pre></td></tr></table></figure><p>QA 团队想把 <code>master</code> 分支推送到远程服务器的 <code>qa/master</code> 分支上，可以运行：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="literal">master</span>:refs/heads/qa/<span class="literal">master</span></span><br></pre></td></tr></table></figure><p>如果他们希望 Git 每次运行 <code>git push origin</code> 时都像上面这样推送，可以在配置文件中添加一条 push 值：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = <span class="string">https:</span><span class="comment">//github.com/schacon/simplegit-progit</span></span><br><span class="line">    fetch = +refs<span class="regexp">/heads/</span>*:refs<span class="regexp">/remotes/</span>origin<span class="comment">/*</span></span><br><span class="line"><span class="comment">    push = refs/heads/master:refs/heads/qa/master</span></span><br></pre></td></tr></table></figure><p>对于push 的引用规格的格式中的 <code>&lt;src&gt;</code> 应该代表本地版本库中的引用；<code>&lt;dst&gt;</code> 是那些远程版本库中的引用。</p><p>当你把<code>&lt;src&gt;</code>留空时，意味着将远程版本定义为空，也就是删除它，可以达到远程分支的效果。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> :topic</span><br></pre></td></tr></table></figure><p><code>git push</code>的行为：如果不加<code>&lt;remote&gt;</code>，也不指定引用规格，这个命令等效于<code>git push &lt;remote&gt;</code>，<code>&lt;remote&gt;</code>的值由<code>.git/config</code>中的<code>branch.&lt;branchname&gt;.remote</code>指定，如果没有指定，默认推送至<code>origin</code>远程仓库。</p><p><code>git push &lt;remote&gt;</code>的行为：如果为注册的远程版本库设置了push参数，即通过<code>remote.&lt;remote&gt;.push</code>配置了引用规格，则执行<code>git push &lt;remote&gt;</code>时使用该引用规格执行推送。否则根据<code>push.default</code>配置的策略执行。</p><p><code>git push</code>的策略</p><ul><li>nothing 什么都不干除非指定了引用规格。</li><li>current 把当前的分支push到远程的同名分支。本地分支和远程分支不需要有追踪关系。</li><li>upstream/tracking 当本地分支有upstream（即本地分支和远程分支要有追踪关系）时push到对应的远程分支。当执行<code>git push</code>时按照追踪关系推送，追踪关系可以在<code>.git/config</code>中配置<code>branch.&lt;branchname&gt;.remote</code>和<code>branch.&lt;branchname&gt;.merge</code>。通过<code>git branch -vv</code>就可以看到追踪关系。一般推荐这种策略。</li><li>simple 和upstream一样, 但不允许将本地分支提交到远程不一样名字的分支，例如你的本地分支是<code>refs/heads/foo</code>而你通过<code>git branch --set-upstream-to=origin/bar</code>指定了远程追踪分支<code>refs/heads/bar</code>，在执行<code>git push</code>就会提示错误了。Git 2.0后的默认策略</li><li>matching 本地所有的分支都推送到远程同名分支上去，如果没有对应同名的远程分支，Git什么也不会做。Git 2.0前的默认的策略。</li></ul><p>通过下面命令可以配置策略</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global push.default simple</span><br></pre></td></tr></table></figure><p><code>git push origin :</code>，<code>:</code>该表达式的含义是同名分支推送，即对所有在远程版本库有同名分支的本地分支执行推送。参考matching策略。</p><p><code>git push origin foo</code>，Git 自动将 foo 分支名字展开为 <code>refs/heads/foo:refs/heads/foo</code>。<code>git push origin foo:foo</code>也会做同样的事。所以你在<code>bar</code>分支时，想推送<code>foo</code>分支，当你指定了引用规格时，不用担心会错将<code>bar</code>推送。</p><p>要推送的远程版本库的URL地址由<code>remote.&lt;remote&gt;.pushurl</code>指定。如果没有配置，则使用<code>remote.&lt;remote&gt;.url</code>配置的URL地址。</p><p>对于Git 2.0之后的版本，<code>git push</code>默认策略为simple，所以一般在第一次推送时候指定<code>-u</code>参数，建立追踪关系，之后你就可以不用再加这个参数了，甚至可以直接执行<code>git push</code>。</p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>当删除分支却发现分支还有用时，当你硬重置了一个分支，却想找回丢失的提交时。可以使用<code>git reglog</code>工具尝试恢复丢失的提交。你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 引用日志（reflog）也可以通过 git update-ref 命令更新。</p><p><code>git reset --hard HEAD~2</code>将会使最新的两次提交丢失，执行<code>git reflog</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">ref</span>log</span><br><span class="line"><span class="number">3</span>b75ed9 <span class="symbol">HEAD@</span>&#123;<span class="number">0</span>&#125;: reset: moving to HEAD~<span class="number">2</span></span><br><span class="line">df55ffe <span class="symbol">HEAD@</span>&#123;<span class="number">1</span>&#125;: commit: add foot.html</span><br><span class="line"><span class="number">19</span>eb010 <span class="symbol">HEAD@</span>&#123;<span class="number">2</span>&#125;: commit: add head.html</span><br><span class="line"><span class="number">3</span>b75ed9 <span class="symbol">HEAD@</span>&#123;<span class="number">3</span>&#125;: commit (initial): add index.html</span><br></pre></td></tr></table></figure><p>这时可以通过执行<code>git branch recover-branch df55ffe</code>让一个分支指向提交<code>df55ffe</code></p><p>为了使显示的信息更加有用，我们可以执行 git log -g，这个命令会以标准日志的格式输出引用日志。</p><p>另一个命令是<code>git fsck</code>，它会检查数据库的完整性， 如果使用一个 –full 选项运行它，它会向你显示出所有没有被其他对象指向的对象。还需要一个<code>--no-reflogs</code>选项，这样可以忽略reflog引用的对象。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --full --no-<span class="built_in">ref</span>logs</span><br><span class="line">Checking object directories: <span class="number">100</span>% (<span class="number">256</span>/<span class="number">256</span>), done.</span><br><span class="line">dangling commit df55ffedca681c04e700463f023e3c96f93f274f</span><br></pre></td></tr></table></figure><p><code>dangling</code>后的就是你需要的那次提交。如果你的reflog不幸被删了，这个命令就能派上用场了。</p><h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>有时，一个文件已经从工作目录中删除了，并且很确定不再需要这个文件，但是这个文件还是存在于版本库中，所以每次clone的时候都还是会clone这个文件。有办法可以从版本库删除数据对象，然后重写那之后的每次提交。</p><p>从<code>git count-objects -v</code>输出的内容可以看到版本库数据的大小。size-pack就是包文件的大小，如果执行了 <code>git gc</code> 可以通过<code>git verify-pack -v .git/objects/pack/pack-29…69.idx | sort -k 3 -n | tail -3</code>找到最大的三个对象，然后通过<code>git rev-list --objects --all | grep &lt;SHA-1&gt;</code>可以找到和<code>git verify-pack</code>命令找到的哈希值相关联的文件名，通过<code>git log --oneline --branches -- &lt;file&gt;</code>可以找到和文件相关的提交。然后重写历史<code>git filter-branch --index-filter &#39;git rm --ignore-unmatch --cached git.tgz&#39; -- 7b30847^..</code>，<code>7b30847</code>是上一步找到的最早的提交记录的哈希。你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 <code>.git/refs/original</code> 通过 filter-branch 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据库。此时大文件还是以松散对象的形式存在，不过不会再克隆时出现了，通过<code>git prune --expire now</code>可以彻底的删除它。</p><p>参考：</p><ul><li><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git</a></li><li><a href="http://www.worldhello.net/gotgit/" target="_blank" rel="noopener">Git权威指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      Git 原理；Git 内幕；Git 对象；
    
    </summary>
    
    
      <category term="Git" scheme="http://howiefh.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://howiefh.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo日历插件</title>
    <link href="http://howiefh.github.io/2016/04/29/hexo-s-calendar-plugin/"/>
    <id>http://howiefh.github.io/2016/04/29/hexo-s-calendar-plugin/</id>
    <published>2016-04-29T13:10:44.000Z</published>
    <updated>2020-05-02T14:28:14.486Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在使用 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a> 并且你在寻找一款 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a> 下可用的日历插件，你还希望这款日历插件能像博客园或者WordPress的日历小工具一样，如果某天有文章，日期就会显示为文章链接，那么本文介绍的这个插件就是你所需要的。</p><p>实际上之前在 <a href="http://howiefh.github.io/2014/04/20/hexo-optimize-and-my-theme-landscape-f/">Landscape-F</a> 主题中已经实现过一个日历插件（<a href="https://github.com/howiefh/hexo-calendar" target="_blank" rel="noopener">hexo-calendar</a>）了，只不过当时这个插件很挫，打开一篇文章时，日历中才能显示文章链接，而且只能显示文章发表当月的文章的链接，你要查看其他月的日历时，就算有文章也不会在日历中显示，因为当时的做法是在生成页面直接在页面的日历中嵌入文章当月所有文章的链接，是完全静态的。现在我重新实现了日历插件（<a href="https://github.com/howiefh/hexo-generator-calendar" target="_blank" rel="noopener">hexo-generator-calendar</a>），很简单，就是在Hexo generator的时候，把所有文章的标题、链接、发布时间信息以json格式存入文件中，然后在前端用ajax方法请求日历数据，解析并生成日历表格。下面简单介绍下这个插件的安装和使用。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>执行下面的命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> &lt;你的博客路径&gt;</span><br><span class="line">npm install <span class="params">--save</span> git:<span class="string">//github.com/howiefh/hexo-generator-calendar.git</span></span><br></pre></td></tr></table></figure><p>当然只安装 <a href="https://github.com/howiefh/hexo-generator-calendar" target="_blank" rel="noopener">hexo-generator-calendar</a> 是不够的，你还得使用主题 <a href="http://howiefh.github.io/2014/04/20/hexo-optimize-and-my-theme-landscape-f/">Landscape-F</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;你的博客路径&gt;</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/howiefh/hexo-theme-landscape-f.git themes/landscape<span class="_">-f</span></span><br></pre></td></tr></table></figure><p>在博客根目录的<code>_config.yml</code>中配置主题</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">theme:</span> landscape-f</span><br></pre></td></tr></table></figure><p>如果你在其他 <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a> 主题中也想显示日历，你需要在相应目录中添加以下几个文件：</p><ul><li><a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/layout/_widget/calendar.ejs" target="_blank" rel="noopener">calendar.ejs</a></li><li><a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/languages.js" target="_blank" rel="noopener">languages.js</a> (多亏了<a href="https://github.com/xdan/datetimepicker/" target="_blank" rel="noopener">https://github.com/xdan/datetimepicker/</a>)</li><li><a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a></li><li><a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/css/_partial/calendar.styl" target="_blank" rel="noopener">calendar.styl</a></li></ul><p>此外，你还需要在 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/css/_variables.styl" target="_blank" rel="noopener">_variables.styl</a> 中添加以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">color-calendar-border</span> = <span class="comment">#d1d1d1</span></span><br><span class="line"><span class="attr">color-calendar-post-bg</span> = <span class="comment">#007acc</span></span><br><span class="line"><span class="attr">color-calendar-hover-bg</span> = <span class="comment">#686868</span></span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/layout/_partial/after-footer.ejs" target="_blank" rel="noopener">after-footer.ejs</a> 中添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.widgets.indexOf</span>('<span class="attr">calendar</span>') != <span class="string">-1)&#123;</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">js</span>('<span class="attr">js</span>/<span class="attr">languages</span>') %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">js</span>('<span class="attr">js</span>/<span class="attr">calendar</span>') %&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#calendar'</span>).aCalendar(<span class="string">'&lt;%= theme.calendar.language || config.language %&gt;'</span>, $.extend(&lt;%- <span class="built_in">JSON</span>.stringify(theme.calendar.options ) %&gt;, &#123;<span class="attr">single</span>:&lt;%= config.calendar.single %&gt;, <span class="attr">root</span>:<span class="string">'&lt;%= config.calendar.root %&gt;'</span>&#125;));</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以在博客根目录的<code>_config.yml</code>中配置这个插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">calendar:</span></span><br><span class="line">    <span class="attr">single:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">calendar/</span></span><br></pre></td></tr></table></figure><ul><li>single - 生成一个单独的json文件。 (默认: true)</li><li>root - 当single的值是false时，这个值才会生效，用来指定按月份生成的多个json文件的根目录。 (默认: calendar/)</li></ul><p>上面是 <a href="https://github.com/howiefh/hexo-generator-calendar" target="_blank" rel="noopener">hexo-generator-calendar</a> 插件的配置，接下来讲下 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a> 的配置。主要就是语言和其它选项的配置。</p><ul><li><p>语言<br>  如果主题根目录下<code>_config.yml</code>文件中有如下配置，将优先使用此处的配置；否则使用博客根目录的<code>_config.yml</code>中的language配置项的值，如果此项仍为空或者无效则使用 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a> 中的默认配置（英文）。</p>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">calendar:</span></span><br><span class="line">  language: <span class="built_in">zh</span>-CN</span><br></pre></td></tr></table></figure></li><li><p>选项<br>  对于 months、dayOfWeekShort、dayOfWeek、postsMonthTip、titleFormat这五项配置优先选用主题根目录下<code>_config.yml</code>中的配置，其次是 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/languages.js" target="_blank" rel="noopener">languages.js</a> 中的配置（语言配置参考上面），最后是 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a> 的默认配置。对于single、root这两项，优先选用博客根目录的<code>_config.yml</code>中的 <a href="https://github.com/howiefh/hexo-generator-calendar" target="_blank" rel="noopener">hexo-generator-calendar</a> 的配置，其次是主题根目录下<code>_config.yml</code>中的配置，最后是 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a> 的默认配置。其他项优先选择主题根目录下<code>_config.yml</code>中的配置，最后是 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a> 的默认配置。</p></li></ul><p>主题根目录下<code>_config.yml</code>中的配置示例</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">calendar</span>:</span><br><span class="line">  <span class="attribute">language</span>: zh-CN</span><br><span class="line">  <span class="attribute">options</span>:</span><br><span class="line">    <span class="attribute">months</span>: [<span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>, <span class="string">'June'</span>, <span class="string">'July'</span>, <span class="string">'August'</span>, <span class="string">'September'</span>, <span class="string">'October'</span>, <span class="string">'November'</span>, <span class="string">'December'</span>]</span><br><span class="line">    <span class="attribute">dayOfWeekShort</span>: [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'T'</span>, <span class="string">'W'</span>, <span class="string">'T'</span>, <span class="string">'F'</span>, <span class="string">'S'</span>]</span><br><span class="line">    <span class="attribute">dayOfWeek</span>: [<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>, <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span>]</span><br><span class="line">    <span class="attribute">postsMonthTip</span>: <span class="string">'Posts published in LMM yyyy'</span></span><br><span class="line">    <span class="attribute">titleFormat</span>: <span class="string">'yyyy LMM'</span></span><br><span class="line">    <span class="attribute">titleLinkFormat</span>: <span class="string">'/archives/yyyy/MM/'</span></span><br><span class="line">    <span class="attribute">headArrows</span>: &#123;<span class="attribute">previous</span>: <span class="string">'&lt;span class="cal-prev"&gt;&lt;/span&gt;'</span>, <span class="attribute">next</span>: <span class="string">'&lt;span class="cal-next"&gt;&lt;/span&gt;'</span>&#125;</span><br><span class="line">    <span class="attribute">footArrows</span>: &#123;<span class="attribute">previous</span>: <span class="string">' '</span>, <span class="attribute">next</span>: <span class="string">' '</span>&#125;</span><br><span class="line">    <span class="attribute">weekOffset</span>: <span class="number">0</span></span><br><span class="line">    <span class="attribute">single</span>: false</span><br><span class="line">    <span class="attribute">root</span>: <span class="string">'/calendar/'</span></span><br><span class="line">    <span class="attribute">url</span>: <span class="string">'/calendar.json'</span></span><br></pre></td></tr></table></figure><p>当然，关于配置，你还可以直接修改 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/layout/_partial/after-footer.ejs" target="_blank" rel="noopener">after-footer.ejs</a> 或者 <a href="https://github.com/howiefh/hexo-theme-landscape-f/blob/master/source/js/calendar.js" target="_blank" rel="noopener">calendar.js</a>。事实上不做任何配置也是可以使用的，最多你可能只需要设置一下语言。</p><p>到此，怎么安装使用这款日历插件应该就讲清楚了，希望大家喜欢这款日历插件O(∩_∩)O。</p>]]></content>
    
    <summary type="html">
    
      Hexo 日历; Hexo Calendar; Hexo plugin; Calendar Plugin;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://howiefh.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://howiefh.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>AES加密时报java.security.InvalidKeyException Illegal key size</title>
    <link href="http://howiefh.github.io/2016/04/21/java-security-illegal-key-size/"/>
    <id>http://howiefh.github.io/2016/04/21/java-security-illegal-key-size/</id>
    <published>2016-04-21T06:41:09.000Z</published>
    <updated>2020-05-02T14:28:14.486Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AES 加密时，密钥大于128bit的话会抛出java.security.InvalidKeyException异常。因为密钥长度是受限的，根据网上一些博客中说的，这种限制是因为<a href="http://book.2cto.com/201311/37620.html" target="_blank" rel="noopener">美国对软件出口的控制</a>。解决办法很简单，下载对应版本的jce包，解压并覆盖 ${JAVA_HOME}/jre/lib/security/ 下的同名文件即可。</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_blank" rel="noopener">Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 6</a></p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_blank" rel="noopener">Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 7 Download</a></p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 8 Download</a></p>]]></content>
    
    <summary type="html">
    
      AES加密；java.security.InvalidKeyException; Illegal key size
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://howiefh.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 总结</title>
    <link href="http://howiefh.github.io/2015/09/01/javascript-summary/"/>
    <id>http://howiefh.github.io/2015/09/01/javascript-summary/</id>
    <published>2015-09-01T02:22:17.000Z</published>
    <updated>2020-05-04T11:38:36.614Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是对前面<a href="/2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="/2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="/2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记的总结。</p><a id="more"></a><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>有三个关键字可以用于声明变量：var,let,const。后面两个是ES6新加的。如果没有使用任何关键字，变量是全局变量（不推荐）。</p><p>var 声明的变量会被提升到当前作用域的最前面，它的作用域范围也就是当前作用域，即使它是在语句块中声明。</p><p>let、const 声明的变量会绑定当前语句块（暂时性死区，temporal dead zone，简称TDZ），被声明之后才可以使用。只在声明所在的块级作用域内有效；不存在“变量提升“现象，只能在声明的位置后面使用；也不可重复声明。不同的是const声明之后不可变，如果声明的是对象，不能再指向另一个对象，但是对象属性可以变。使用Object.freeze方法可以使对象属性也不可变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//if中的声明语句会被提升到这里</span></span><br><span class="line">  <span class="comment">//var a;</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError: can't access lexical declaration `b' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError: b is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">//ReferenceError: c is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6规定，var和function声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。</p><h2 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h2><p>var 声明的变量，function声明的函数会被提升到当前作用域顶端。只有声明才会提升，表达式不会。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>共有七种数据类型：Undefined, Null, Boolean, String, Symbol, Number和Object.</p><p>前六种是简单（基本）数据类型，其中Boolean, String, Number有基本包装类型，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象</p><p>ES6新加了Symbol类型，是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><ul><li>“undefined” 如果这个值未定义</li><li>“boolean” 如果这个值是布尔值</li><li>“string” 如果这个值是字符串</li><li>“number” 如果这个值是数值</li><li>“object” 如果这个值是对象或者null</li><li>“function” 如果这个值是函数</li><li>“symbol” 如果这个值是Symbol类型（ES6新增）</li></ul><p>实际上JavaScript中函数也是对象。</p><p>大体上来说,基本类型的值应该使用 typeof 来检测,而对象的值则应该使用 instanceof 来检测。</p><h2 id="对象的类定义"><a href="#对象的类定义" class="headerlink" title="对象的类定义"></a>对象的类定义</h2><p>JavaScript 标准文档只给出了一种获取 [[Class]] 值的方法，那就是使用 Object.prototype.toString。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">type, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clas = <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> obj !== <span class="literal">undefined</span> &amp;&amp; obj !== <span class="literal">null</span> &amp;&amp; clas === type;</span><br><span class="line">&#125;</span><br><span class="line">is(<span class="string">'String'</span>, <span class="string">'test'</span>); <span class="comment">// true</span></span><br><span class="line">is(<span class="string">'String'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面例子中，Object.prototype.toString 方法被调用，this 被设置为了需要获取 [[Class]] 值的对象。</p><p>Object.prototype.toString 返回一种标准格式字符串，所以上例可以通过 slice 截取指定位置的字符串，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])    <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)    <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>)    <span class="comment">// "[object Number]"</span></span><br></pre></td></tr></table></figure><h2 id="undefined-amp-null"><a href="#undefined-amp-null" class="headerlink" title="undefined &amp; null"></a>undefined &amp; null</h2><p>这两种类型分别都只有一个值，分别是undefined和null。</p><p>未声明的变量或声明后没有初始化的变量都是undefined的，typeof会返回undefined。全局变量中有undefined变量，其值也是undefined。函数中没有定义return或return没有显示返回任何内容时返回值会是undefined。函数参数没有显示传递值也会是undefined。</p><p>null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</p><p>实际上，undefined值是派生自null值的，<code>null == undefined</code>将会返回true。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在使用相等(==)和不相等(!=)操作符,或者在 if 、 for 及 while 等流控制语句中使用非布尔值时, 最常发生类型转换。避免隐式类型转换，可能会带来不期望的结果。尽量使用<code>===</code>,<code>!==</code>替代<code>==</code>,<code>!=</code>。</p><p>最好是使用显示类型转换，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转为数值</span></span><br><span class="line"><span class="keyword">var</span> n1 = +<span class="string">'123'</span>; <span class="comment">//123 和下面等效</span></span><br><span class="line"><span class="keyword">var</span> n2 = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">//123</span></span><br><span class="line"><span class="keyword">var</span> n3 = <span class="built_in">parseInt</span>(<span class="string">'123.3blue'</span>); <span class="comment">//123</span></span><br><span class="line"><span class="keyword">var</span> n4 = <span class="built_in">parseInt</span>(<span class="string">'blue123'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> n5 = <span class="built_in">parseInt</span>(<span class="string">'0123.23'</span>, <span class="number">8</span>); <span class="comment">//83</span></span><br><span class="line"><span class="keyword">var</span> n6 = <span class="built_in">parseFloat</span>(<span class="string">'123.23.12blue'</span>); <span class="comment">//123.23</span></span><br><span class="line"><span class="comment">//转为字符串</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">''</span> + <span class="number">123</span>; <span class="comment">//"123" 和下面等效</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">String</span>(<span class="number">123</span>);<span class="comment">//"123"</span></span><br><span class="line"><span class="comment">//转为布尔值</span></span><br><span class="line"><span class="keyword">var</span> b1 = !!<span class="string">'123'</span>;<span class="comment">//true 和下面等效</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">'123'</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>技巧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span> + <span class="number">10</span> === <span class="string">'10'</span>; <span class="comment">// true</span></span><br><span class="line">+<span class="string">'10'</span> === <span class="number">10</span>; <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'foo'</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>内置类型（比如 Number 和 String）的构造函数在被调用时，使用或者不使用 new 的结果完全不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;     <span class="comment">// false, 对象与数字的比较</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;         <span class="comment">// true, 数字与数字的比较</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) + <span class="number">0</span> === <span class="number">10</span>; <span class="comment">// true, 由于隐式的类型转换</span></span><br></pre></td></tr></table></figure><p>布尔类型转换规则</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>非空字符串</td><td>“”</td></tr><tr><td>Number</td><td>非零数字值（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>n/a（不适用）</td><td>undefined</td></tr></tbody></table><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol，表示独一无二的值。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><p>Symbol 不可以使用new关键字，Symbol函数可以接受字符串参数使其返回值容易被区分，只是作为描述，即使参数相同Symbol函数返回值也不等。</p><p>Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><p>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。</p><p>Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。注意，Symbol函数是总是返回新的值。</p><p>Symbol.keyFor方法返回一个已登记的Symbol类型值的key。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a === s2 <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>除了定义自己使用的Symbol值以外，ES6还提供一些内置的Symbol值：对象的Symbol.hasInstance属性，对象的Symbol.iterator属性等等。</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>最小数值和最大数值分别为Number.MIN_VALUE，Number.MAX_VALUE</p><p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，0除以0会返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity，因此不会影响其他代码的执行。 NaN本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身</p><p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?\`</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="string">'Mr. '</span> + name&#125;</span></span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><p>函数tag依次会接收到多个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123; <span class="comment">// ...  &#125;</span></span><br></pre></td></tr></table></figure><p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p><p>tag函数所有参数的实际值如下。</p><ul><li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li><li>第二个参数: 15</li><li>第三个参数：50</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>; <span class="comment">// "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>; <span class="comment">// 'Hi\\u000A!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 't0e1s2t'</span></span><br></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p><ul><li><p>一元操作符(<code>++,--,+,-</code>)<br>  在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。如<code>+&#39;10&#39; === 10 //true</code></p></li><li><p>位操作符(<code>~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</code>)<br>  ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理</p><p>  默认情况下，ECMAScript 中的所有整数都是有符号整数</p></li><li><p>布尔操作符(<code>!,&amp;&amp;,||</code>)<br>  非操作符对于非布尔值会先将其转换为布尔值在计算。</p><p>  与、或操作符，对于非布尔值，可以理解为先将其转为布尔值在计算，但是返回值仍旧是原值而不是转换后的布尔值。如<code>null &amp;&amp; 1</code>可以理解为<code>false &amp;&amp; true</code>。由于短路效应，第一个操作数是false那么就直接将第一个操作数返回，即返回null。再比如<code>NaN || obj</code>可以理解为<code>false || true</code>，短路效应要到表达式的值就是第二个操作数的值，即obj。</p></li><li><p>乘性操作符(<code>*,/,%</code>)<br>  在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值true将被当作1。</p><p>  注意<code>0 * Infinity = NaN</code>， <code>Infinity / Infinity = NaN</code>， <code>0 / 0 = NaN</code>， <code>Infinity % 有限大的数值 = NaN</code>， <code>有限大的数值 % 0= NaN</code>， <code>Infinity % Infinity = NaN</code></p></li><li><p>加性操作符(<code>+,-</code>)<br>  <code>+</code> 如果有操作数是字符串会拼接字符串。拼接时其他类型调用toString()方法</p><p>  注意<code>Infinity + (-Infinity) = NaN</code>， <code>Infinity -Infinity = NaN</code>， <code>-Infinity -(-Infinity) = NaN</code></p><p>  减法，如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。</p></li><li><p>关系操作符(<code>&gt;,&lt;,&gt;=,&lt;=</code>)<br>  对于字符串实际比较的是两个字符串中对应位置的每个字符的字符编码值</p><p>  如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</p></li><li><p>相等操作符(<code>===,!==,==,!=</code>)<br>  <code>==,!=</code> 比较规则</p><ul><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较； 这两个操作符在进行比较时则要遵循下列规则。</li><li>null和undefined是相等的。</li><li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li><li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li></ul></li><li><p>条件操作符(<code>boolean_expression?true_value:false_value</code>)</p></li><li><p>逗号操作符(<code>,</code>)</p></li><li><p>赋值操作符(<code>=以及*=、+=等复合赋值运算符</code>)</p></li></ul><h2 id="ES6中的"><a href="#ES6中的" class="headerlink" title="ES6中的..."></a>ES6中的<code>...</code></h2><p>rest参数可以在函数参数和解构时使用，<code>...</code>后面的变量是一个数组，可以将一个序列存入这个数组。</p><p>扩展操作符可以看作rest参数的逆操作，可以将一个数组转变为一个序列，可以在函数调用和解构时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...a</span>)</span>&#123;&#125;</span><br><span class="line">foo(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">var</span> [...a] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]; <span class="comment">// a = [1,2,4]</span></span><br><span class="line"><span class="keyword">var</span> [a] = [...[<span class="number">1</span>,<span class="number">2</span>]]; <span class="comment">// a = 1</span></span><br></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ECMAScript6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a即为1，b为2，c为3</span></span><br><span class="line"><span class="keyword">var</span> [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];<span class="comment">//third为"baz"</span></span><br><span class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">//head为1，tail为[2,3,4]</span></span><br><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><p>实际赋值操作符右边只要是实现了Iterable接口的对象就行，所以Set、Map、Generator函数的返回值都可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set().add('a').add('b');</span><br><span class="line">var [a, b] = <span class="keyword">set</span>; //a = "a",b = "b"</span><br></pre></td></tr></table></figure><p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;<span class="comment">//bar = "bbb", foo = "aaa"</span></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = undefined</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">"Hello"</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">"World"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj; <span class="comment">//x = "Hello", y = "World"</span></span><br><span class="line"><span class="comment">//默认值生效的条件是，对象的属性值严格等于undefined。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;; <span class="comment">//x = 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><p>如果左边变量名和右边属性名不一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = "aaa"</span></span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;; <span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>函数参数也可以使用解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>解构的主要应用</p><p>1）交换变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>2）从函数返回多个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example(); <span class="comment">//a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure><p>3）函数参数的定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>4）提取JSON数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; id, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, number) <span class="comment">// 42, [867, 5309]</span></span><br></pre></td></tr></table></figure><p>5）函数参数的默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>6）遍历Map结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    .set(<span class="string">'first'</span>, <span class="string">'hello'</span>)</span><br><span class="line">    .set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123; <span class="comment">// ...  &#125;</span></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123; <span class="comment">// ...  &#125;</span></span><br></pre></td></tr></table></figure><p>7）输入模块的指定方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>ECMAScript 中的语句以一个分号结尾;如果省略分号,则由解析器确定语句的结尾，为了避免自动插入都好改变代码行为，最好加上分号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="comment">//直接返回了</span></span><br><span class="line"> &#123;&#125;</span><br></pre></td></tr></table></figure><p>if, do-while,while,for,label,break,continue,switch和Java没有太大差别。</p><p>switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串”10”不等于数值10）。</p><p>首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。</p><h2 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h2><p>for-in 语句是一种精准的迭代语句,可以用来枚举对象的属性（包括原型链上的属性）。对于数组则是遍历下标</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(location)&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> hostName = hostname;</span><br><span class="line">    <span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用with 语句关联了location 对象。这意味着在with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。 严格模式下不允许使用with语句，否则将视为语法错误</p><h2 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h2><p>实现了Iterable接口的对象都可以用于for-of循环。for-of循环可以使用的范围包括数组、Set和Map结构及其entries,values,keys方法返回的对象、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator函数返回的对象，以及字符串。</p><p>并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure><p>通过for-of遍历对象，一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">": "</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法是使用Generator函数将对象重新包装一下。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>ECMAScript中最有意思的可能是函数了，函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。<strong>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</strong>。</p><p>创建一个函数，在创建Funciton类型实例的同时还会创建一个原型对象，函数变量的prototype属性指向该原型对象。</p><h2 id="函数声明和表达式"><a href="#函数声明和表达式" class="headerlink" title="函数声明和表达式"></a>函数声明和表达式</h2><p>函数通常是使用函数声明语法定义的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用函数表达式定义函数的方式，和上面效果是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的下面这样声明函数，add只能在函数内部使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后一种定义函数的方式是使用Function构造函数。Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐，因为这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码,第二次是解析传入构造函数中的字符串)</span></span><br></pre></td></tr></table></figure><p>在函数名后加圆括号就是调用函数，不加就只是一个函数指针。所以也可以像下面这样定义一个函数就直接调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>匿名函数被认为是表达式；因此为了可调用性，它们首先会被执行。</p><p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外两种方式</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;());</span><br></pre></td></tr></table></figure><p>这种立即执行的匿名函数可以用来解决只有一个全局作用域导致的常见错误是命名冲突。</p><h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>将函数名想象为指针，也有助于理解为什么 ECMAScript中没有函数重载的概念。在创建第二个同名函数时,实际上覆盖了引用第一个函数的函数名变量。</p><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>函数内部的arguments是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但是arguments存储的参数和形式参数存储的变量空间是独立的。arguments 对象为其内部属性以及函数形式参数创建 getter 和 setter 方法。因此，改变形参的值会影响到 arguments 对象的值，反之亦然。严格模式下不允许创建这些getter和setter，所以两者值互不影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    num1 = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>函数内部的另一个特殊对象是 this ,其行为与 Java 中的 this 大致类似。this引用的是执行函数的环境对象（当在网页的全局作用域中调用函数时，this对象引用的就是window）。</p><p>全局范围内使用this，它指向全局对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="comment">//浏览器里就是window</span></span><br><span class="line">foo() <span class="comment">//这种函数调用中的this也是全局对象，如果在严格模式下将是undefined</span></span><br><span class="line">test.foo(); <span class="comment">//this指向test对象</span></span><br><span class="line"><span class="keyword">new</span> foo();  <span class="comment">//this指向新创建的对象</span></span><br></pre></td></tr></table></figure><p>还可以显示设置this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line"><span class="comment">//在foo 函数内 this 被设置成了 bar。</span></span><br><span class="line">foo.apply(bar, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 数组将会被扩展，如下所示</span></span><br><span class="line">foo.call(bar, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 传递到foo的参数是：a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure><p>常见误解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">//this将是全局对象，严格模式是undefined&#125;</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易认为test方法中的this是Foo，但是并不是，这里test符合的是函数调用的情况，this将是全局对象，严格模式是undefined</p><p>为什么内部函数（test）没有取得其包含作用域(或外部作用域)的 this 对象呢? 每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments 。内部函数在搜索这两个变量时,只会搜索到其活动对象（当前函数test的作用域）为止,因此永远不可能直接访问外部函数中的这两个变量。不过,可以把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里。像下面这样使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">//that&#125;</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 someObject 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = someObject.methodTest;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>虽然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"><span class="keyword">new</span> Bar().method();</span><br></pre></td></tr></table></figure><p>当 method 被调用时，this 将会指向 Bar 的实例对象。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>没有return，或者return不带任何返回值，都会返回undefined值。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><p>定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。</p><p>甚至还可以设置双重默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; method = <span class="string">'GET'</span> &#125; = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p><p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p><p>注意，参数默认值所处的作用域，不是全局作用域，而是函数作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><p>函数的length属性，不包括rest参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, ...b</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>将一个数组（只要实现了Iterable接口的对象即可）转为用逗号分隔的参数序列，该运算符主要用于函数调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6允许使用“箭头”（=&gt;）定义函数（和Java8中lambda表达式有点类似）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line">(param1, param2, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, paramN) =&gt; expression <span class="comment">// equivalent to:  =&gt; &#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数可以省略圆括号</span></span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有参数，则需要一个圆括号</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回一个对象，必须在对象外面加上括号。</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持Rest参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line"><span class="comment">// 支持变量解构</span></span><br><span class="line">(&#123;param1, param2&#125;) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>箭头函数有几个使用注意点。</p><ul><li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。</li><li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">1</span>,</span><br><span class="line">  doSomeThing()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x*<span class="keyword">this</span>.length));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.doSomeThing();<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>如果不是使用箭头函数，得到结果是不一样的，如下例，下面this就是window</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length:<span class="number">1</span>,</span><br><span class="line">  doSomeThing()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length * x;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.doSomeThing();<span class="comment">//[0,0,0]</span></span><br></pre></td></tr></table></figure><p>箭头函数还有可以嵌套</p><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><p>Generator函数是一个普通函数，但是有几个特征。一是，function命令与函数名之间有一个星号；二是，可以像调用普通函数一样调用Generator函数，但是返回的结果并不是函数返回值，而是一个实现了Iterable和Iterator接口的对象（该对象的Symbol.iterator方法返回其自身）；三是，函数体内部使用yield语句，每调用Generator函数返回值的next方法，就会到达下一个yield语句，同时将yield语句后面的表达式求值后作为返回结果的value属性（yield语句在英语里的意思就是“产出”）；四是，函数体内也可以有<code>yield*</code>，其后面须是一个Iterable对象；五是，Generator函数返回值的next方法可以有参数，参数将作为函数体内上一个yield语句的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">123</span>+<span class="number">234</span>;</span><br><span class="line">  <span class="keyword">yield</span> x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line">it[<span class="built_in">Symbol</span>.iterator]() === it <span class="comment">// true</span></span><br><span class="line">it.next();</span><br><span class="line">it.next(<span class="string">'a'</span>);</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>一个稍复杂的例子，取出嵌套数组的所有成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.label = label;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.left);</span><br><span class="line">    <span class="keyword">yield</span> t.label;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> inorder(tree)) &#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line">result <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure><p>Generator函数还有一个特点，它可以在函数体外通过返回的Iterator对象的throw方法抛出错误，然后在函数体内捕获。</p><p>一个对象的属性可以是Generator函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; * gen()&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">gen</span>: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是尾调用，下面三种情况都不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一种情况等同于下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;<span class="comment">//函数m和n都属于尾调用</span></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数inner用到了，外层函数addOne的内部变量one。</p><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当调用 compare() 时,会创建一个包含 arguments 、 value1 和 value2 的活动对象。全局执行环境的变量对象(包含 result和 compare )在 compare() 执行环境的作用域链中则处于第二位。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+</span><br><span class="line">|<span class="string">     compare          </span>|</span><br><span class="line">|<span class="string">  execution context   </span>|<span class="string">&lt;-------------------------------------------------+</span></span><br><span class="line"><span class="string">+----------------------+    +------------+      +----------------------+  </span>|</span><br><span class="line">|<span class="string">(scope chain) </span>|<span class="string">      -</span>|<span class="string">---&gt;</span>|<span class="string">scope chain </span>|<span class="string">  +--&gt;</span>|<span class="string">global variable object</span>|<span class="string">  </span>|</span><br><span class="line">+----------------------+    +------------+  |<span class="string">   +----------------------+  </span>|</span><br><span class="line">                            |<span class="string">1     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   compare </span>|<span class="string">         -</span>|<span class="string">--+</span></span><br><span class="line"><span class="string">                            +------------+      +----------------------+</span></span><br><span class="line"><span class="string">                            </span>|<span class="string">0     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   result  </span>|<span class="string"> undefined</span>|</span><br><span class="line">                            +------------+  |<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">                                            </span>|</span><br><span class="line">                                            |<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">                                            +--&gt;</span>|<span class="string">    compare()         </span>|</span><br><span class="line">                                                |<span class="string">  activation object   </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string"> arguments </span>|<span class="string">  [5,10]  </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value1  </span>|<span class="string">  5       </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value2  </span>|<span class="string">  10      </span>|</span><br><span class="line">                                                +----------------------+</span><br></pre></td></tr></table></figure><p>每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在,而像compare() 函数这样的局部环境的变量对象,则只在函数执行的过程中存在。在创建 compare() 函数时,会创建一个预先包含全局变量对象的作用域链,这个作用域链被保存在内部的 [[Scope]] 属性中。当调用 compare() 函数时,会为函数创建一个执行环境,然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。此后,又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中 compare() 函数的执行环境而言,其作用域链中包含两个变量对象:本地活动对象和全局变量对象。显然,作用域链本质上是一个指向变量对象的指针列表,它只引用但不实际包含变量对象。</p><p>无论什么时候在函数中访问一个变量时,就会从作用域链中搜索具有相应名字的变量。一般来讲,当函数执行完毕后,局部活动对象就会被销毁,内存中仅保存全局作用域(全局执行环境的变量对象)。但是,下面要讲的闭包的情况又有所不同。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(<span class="string">"Howie"</span>);</span><br><span class="line">f();</span><br><span class="line">f = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>即使这个内部函数被返回了,而且是在其他地方被调用了,但它仍然可以访问外部函数的变量 name。之所以还能够访问这个变量,是因为内部函数的作用域链中包含fn() 的作用域。</p><p>前面讲的有关如何创建作用域链以及作用域链有什么作用的细节,对彻底理解闭包至关重要。当某个函数被调用时,会创建一个执行环境(execution context)及相应的作用域链。然后,使用 arguments 和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中,外部函数的活动对象始终处于第二位,外部函数的外部函数的活动对象处于第三位,……直至作为作用域链终点的全局执行环境。</p><p>fn(“Howie”) 返回后其活动对象并没有被销毁，因为匿名函数（即被返回的f函数）的作用域链中有对其的引用。通过将 f设置为等于 null解除该函数的引用,就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁,其他作用域(除了全局作用域)也都可以安全地销毁了。</p><p>过度使用闭包可能会导致内存占用过多，只在绝对必要时使用闭包。</p><p>作用域链的这种配置机制引出了一个值得注意的副作用,即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象,而不是某个特殊的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组中每个函数都只会返回10，而不是0到9。i在createFunctions()的活动变量中，而每个匿名函数的作用域链第二个位置就是createFunctions()的活动变量，当createFunctions()返回后，i的值为10，此时每个函数都引用着保存变量 i 的同一个变量对象,所以在每个函数内部 i 的值都是 10。通过创建另一个匿名函数强制让闭包的行为符合预期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6中我们还可以使用let关键字声明i，这样i仅在for循环中有效，可以得到同样预期的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>ES6中模块功能由三个命令构成：export，import和module。export命令用于用户自定义模块，规定对外接口；import命令用于导入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突；module用于整体输入其它模块的提供的功能。</p><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, year&#125;;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name <span class="keyword">as</span> nickName, year&#125; <span class="keyword">from</span> <span class="string">'profile'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nickName);</span><br></pre></td></tr></table></figure><p>import花括号里面的变量名必须与导出的变量名相同，可以通过as起别名。下面是另一个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure><p>如上，如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。最后再看一个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">module</span> math <span class="keyword">from</span> <span class="string">"circleplus"</span>; <span class="comment">//整体导入相当于 import * as math from "circleplus";</span></span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">"circleplus"</span>; <span class="comment">//导入circleplus中导出的默认方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export deault</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>ECMA-262 定义了下列 7 种错误类型: Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError。可以通过继承这些类型自定义错误类型。</p><p>内置的Error对象具有两个标准属性name和message</p><ul><li><strong>name</strong>：错误名称</li><li><strong>message</strong>：错误提示信息</li><li><strong>stack</strong>：错误的堆栈（非标准属性，但是大多数平台支持）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，并不影响return语句要返回的值。</p><p>必须要给 throw 操作符指定一个值,这个值是什么类型,没有要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="attr">name</span>: <span class="string">"JavaScript"</span>&#125;;</span><br></pre></td></tr></table></figure><p>任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。</p><p>另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。IE中的COM对象的垃圾收集机制采用的就是引用计数策略，只要在IE中涉及COM对象，就会存在循环引用的问题</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数</p><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ECMAScript 中有两种属性:数据属性和访问器属性。</p><ol><li>数据属性<br> 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。<ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li><li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li><li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</li></ul></li><li>访问器属性<br> 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。<ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li><li>[[Get]]：在读取属性时调用的函数。默认值为undefined。</li><li>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 ECMAScript 5的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//2004</span></span><br></pre></td></tr></table></figure><h3 id="对象使用和属性"><a href="#对象使用和属性" class="headerlink" title="对象使用和属性"></a>对象使用和属性</h3><p>一种方式是使用对象字面量表示法。属性名可以是字符串也可以是Symbol类型的数据（后者必须使用方括号包含）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">'Howie'</span>,</span><br><span class="line">  age : <span class="number">26</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种方法是通过构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Howie'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>构造函数一般首字母大写，如果构造函数没有参数，使用new时后面的括号也可以省略。</p><p>ES6中可以简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nickname = <span class="built_in">Symbol</span>.for(<span class="string">'nickname'</span>);</span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'cat'</span>;</span><br><span class="line"><span class="keyword">var</span> animal = &#123; [nickname]:<span class="string">'mimi'</span>, type ,<span class="string">'come from'</span>:<span class="string">'shan xi'</span>&#125;</span><br></pre></td></tr></table></figure><p>访问属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animal[nickname]</span><br><span class="line">animal.type</span><br><span class="line">animal[<span class="string">'type'</span>]</span><br><span class="line">animal[<span class="string">'come from'</span>]</span><br></pre></td></tr></table></figure><p>从上例可以看出属性名不是一个有效的变量名（比如属性名中包含空格，或者属性名是 JS 的关键词）</p><p>有很多变通方法可以让数字的字面值看起来像对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString();<span class="comment">//出错</span></span><br><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>JavaScript中每个函数都是Function类型的实例，每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个函数的原型对象，而这个对象的用途是包含可以由特定类型的<strong>所有实例共享的属性和方法</strong>。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。</p><p>默认情况下，每个原型对象都有一个constructor属性，这个属性指向 prototype 属性所在实例，也就是构造函数。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。每个对象都有[[Prototype]]属性（内部属性），虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code>，通过它可以访问[[Prototype]]；这个属性指向了构造函数的原型对象，JavaScript中通过递归原型链来查找对象属性，同一个构造函数创建的对象都可以访问到其原型中的属性constructor。除了通过instanceof外也可以通过person.constructor === Person来判断是否是Person类型，但是instanceof更加可靠，因为prototype对象完全可以被覆盖，其属性constructor也就不一定是Person了。</p><p>ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。</p><p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p><p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<code>person1.name = &quot;Greg&quot;;</code>将会覆盖原型中的name属性。</p><p>使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。</p><p>有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<code>&quot;name&quot; in person</code>为true</p><p>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。</p><p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">//["name","age","jbo","sayName"]</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">//["constructor","name","age","jbo","sayName"]</span></span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>工厂模式、寄生构造函数模式、稳妥构造函数模式都是构造函数（工厂模式中就是普通函数）内部创建一个对象然后返回，通常返回的对象和构造函数没有什么联系。后两者使用new创建对象，工厂模式是直接函数调用。第三种没有公共属性，而且也不引用this的对象。</p><p>组合使用构造函数模式和原型模式结合了两者的优点，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。动态原型模式则在此基础上通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在每个实例共享的属性应该在原型上定义，如方法，如果在this对象上定义，那么每个实例的相同函数名的函数实例实际是不同的，这样就会浪费空间。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, job)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。</p><p>如果对比前面的组合使用构造函数模式和原型模式，可以发现前面的Person构造函数对应现在Person类的构造方法constructor，前面Person原型上定义的sayName方法现在是类的内部方法。</p><p>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><p>与函数一样，Class也可以使用表达式的形式定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Me只能在类内部使用</p><p>Class不存在变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>与ES5一样，在Class内部可以使用get和set关键字，定义访问器属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>父类的静态方法，可以被子类继承。</p><p>ES6为new命令引入了一个<code>new.target</code>属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，<code>new.target</code>会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>在构造函数原型上定义的属性可以被所有实例共享。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>ES6加入了static关键字。</p><p>构造函数原型链上定义的变量或属性只能通过构造函数访问，也可以当做是静态的。</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>严格来讲,JavaScript 中没有私有成员的概念;所有对象属性都是公有的。不过,倒是有一个私有变量的概念。任何在函数中定义的变量,都可以认为是私有变量,因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p><p>我们把有权访问私有变量和私有函数的公有方法称为特权方法(privileged method)。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>注意,这个模式在定义构造函数时并没有使用函数声明,而是使用了函数表达式。函数声明只能创建局部函数,但那并不是我们想要的。出于同样的原因,我们也没有在声明 MyObject 时使用 var 关键字。但也要知道,在严格模式下给未经声明的变量赋值会导致错误。</p><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>有人进一步改进了模块模式,即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例,同时还必须添加某些属性和(或)方法对其加以增强的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/js-obj.jpg" alt="JavaScript Object Layout" title="JavaScript Object Layout"></p><p>上面这张图将原型链关系描绘地非常清晰</p><h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>组合继承(combination inheritance) ,有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//第二次调用 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">///第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>如果知识用原型链继承，那么像colors这样的引用类型会被子类的所有实例共享，一个实例更改colors，所有都会更改，这不是我们想要的，而结合借用构造函数的继承方法，在构造函数内调用父类的构造方法，通过使用 apply() 和 call() 方法也可以在(将来)新创建的对象上执行构造函数，则解决了所有子类实例共享colors的问题。</p><p>组合继承是 JavaScript 最常用的继承模式;不过,它也有自己的不足。组合继承最大的问题就是无论什么情况下,都会调用两次超类型构造函数:一次是在创建子类型原型的时候,另一次是在子类型构造函数内部。没错,子类型最终会包含超类型对象的全部实例属性,但我们不得不在调用子类型构造函数时重写这些属性。</p><p>在第一次调用 SuperType 构造函数时, SubType.prototype 会得到两个属性: name 和 colors ;它们都是 SuperType 的实例属性,只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时,又会调用一次 SuperType 构造函数,这一次又在新对象上创建了实例属性 name 和 colors 。</p><p>寄生组合式继承,即通过借用构造函数来继承属性,通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数,我们所需要的无非就是超类型原型的一个副本而已。本质上,就是使用寄生式继承来继承超类型的原型,然后再将结果指定给子类型的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部,第一步是创建超类型原型的一个副本。第二步是为创建的副本添加 constructor 属性,从而弥补因重写原型而失去的默认的 constructor 属性。最后一步,将新创建的对象(即副本)赋值给子类型的原型。</p><p>ECMAScript 5 新增 Object.create() 方法。这个方法接收两个参数:一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。如果没有Object.create()方法，使用下面代码可以达到类似效果。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码是实现继承的常用方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承</p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayAge()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">    <span class="keyword">super</span>.sayName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p><p>对比借用构造函数继承，实质是先创建子类的实例对象this，然后再将父类的属性添加到this上面（<code>Parent.apply(this)</code>）。ES6的继承机制则不同，实质是先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的属性修改this。</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p><p>大部分浏览器实现中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ol><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li><li>子类prototype属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的prototype属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubType.__proto__ === SuperType <span class="comment">// true</span></span><br><span class="line">SubType.prototype.__proto__ === SuperType.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面，讨论三种特殊情况。</p><p>第一种特殊情况，子类继承Object类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>第二种特殊情况，不存在任何继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>第三种特殊情况，子类继承null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(SubType) === SuperType <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构，比如<code>Array()</code>。以前，这些原生构造函数是无法继承的，即不能自己定义一个Array的子类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">colors.length  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure><p>之所以会发生这种情况，是因为原生构造函数无法外部获取，通过<code>Array.apply()</code>或者分配给原型对象都不行。ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</p><p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h1 id="原生类型"><a href="#原生类型" class="headerlink" title="原生类型"></a>原生类型</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>JavaScript语言的所有对象都是由Object衍生的对象；所有对象都继承了Object.prototype的方法和属性，尽管它们可能被覆盖。</p><p>构建方法的参数为空，null或undefined将返回一个空对象，参数为String，Number,Boolean类型相当于使用其对应包装类型创建对象。对于其它类型的对象会返回原对象。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>Object.assign(target, …sources)</td><td>把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。</td></tr><tr><td>Object.create(proto, [ propertiesObject ])</td><td>创建具有指定原型并可选择包含指定属性的对象。</td></tr><tr><td>Object.defineProperties(obj, props)</td><td>将一个或多个属性添加到对象，和/或修改现有属性的特性，并返回该对象。</td></tr><tr><td>Object.defineProperty(obj, prop, descriptor)</td><td>将属性添加到对象，或修改现有属性的特性，并返回该对象。</td></tr><tr><td>Object.freeze(obj)</td><td>冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</td></tr><tr><td>Object.getOwnPropertyDescriptor(obj, prop)</td><td>返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</td></tr><tr><td>Object.getOwnPropertyNames(obj)</td><td>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</td></tr><tr><td>Object.getOwnPropertySymbols(obj)</td><td>返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。</td></tr><tr><td>Object.getPrototypeOf(object)</td><td>返回指定对象的原型（也就是该对象内部属性[[Prototype]]的值）。</td></tr><tr><td>Object.is(value1, value2)</td><td>返回一个值，该值指示两个值是否相同。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身</td></tr><tr><td>Object.isExtensible(obj)</td><td>返回指示是否可将新属性添加到对象的值。</td></tr><tr><td>Object.isFrozen(obj)</td><td>判断一个对象是否被冻结（frozen）</td></tr><tr><td>Object.isSealed(obj)</td><td>判断一个对象是否是密封的（sealed）</td></tr><tr><td>Object.keys(obj)</td><td>返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。</td></tr><tr><td>Object.preventExtensions(obj)</td><td>让一个对象变的不可扩展，也就是永远不能再添加新的属性</td></tr><tr><td>Object.seal(obj)</td><td>可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</td></tr><tr><td>Object.setPrototypeOf(object, prototype)</td><td>设置一个对象的原型(既对象的[[Prototype]]内部属性)。</td></tr></tbody></table><p>Object原型属性</p><ul><li>Object.prototype.constructor： 返回一个指向创建了该对象原型的函数引用</li><li>Object.prototype.<strong>proto</strong>：非标准，一个对象的<strong>proto</strong> 属性和自己的内部属性[[Prototype]]指向一个相同的值 (通常称这个值为原型),原型的值可以是一个对象值也可以是null(比如说Object.prototype.<strong>proto</strong>的值就是null)</li></ul><p>Object实例方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>obj.hasOwnProperty(prop)</td><td>用来判断某个对象是否含有指定的自身属性</td></tr><tr><td>prototype.isPrototypeOf(obj)</td><td>测试一个对象是否存在于另一个对象的原型链上</td></tr><tr><td>obj.propertyIsEnumerable(prop)</td><td>返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性</td></tr><tr><td>obj.toLocaleString();</td><td>返回一个该对象的字符串表示。该方法主要用于被本地化相关对象覆盖。</td></tr><tr><td>obj.toString()</td><td>返回一个代表该对象的字符串。</td></tr><tr><td>obj.valueOf()</td><td>返回一个对象的值，默认情况下返回对象本身。</td></tr></tbody></table><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(...items);</span><br></pre></td></tr></table></figure><p>如果只有一个参数并且是数值，那么这个参数将用于指定数组大小，否则创建包含这个参数的一个数组。</p><p>Array的函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>Array.from(arrayLike[, mapFn[, thisArg]])</td><td>将一个类数组对象或可迭代对象转换成真实的数组。</td></tr><tr><td>Array.isArray(value)</td><td>返回一个布尔值，该值指示对象是否为数组。</td></tr><tr><td>Array.of(…items)</td><td>将它的任意多个参数放在一个数组里并返回。</td></tr></tbody></table><p>Array 实例的属性</p><ul><li>length： 数组长度</li></ul><p>Array 实例的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>concat(…arguments)</td><td>将传入的数组或非数组值与原数组合并,组成一个新的数组并返回.</td></tr><tr><td>copyWithin(target, start[, end])</td><td>复制数组从start位置到end位置的元素到target，end默认是数组长度</td></tr><tr><td>entries()</td><td>返回包含数组的键/值对的迭代器</td></tr><tr><td>every(callbackfn[, thisArg])</td><td>测试数组的所有元素是否都通过了指定函数的测试</td></tr><tr><td>fill(value[, start[, end]])</td><td>将一个数组中指定区间的所有元素的值, 都替换成或者说填充成为某个固定的值 区间是[start,end)，start默认0，end默认数组长度</td></tr><tr><td>filter(callbackfn[, thisArg])</td><td>利用所有通过指定函数测试的元素创建一个新的数组，并返回</td></tr><tr><td>find(predicate[, thisArg])</td><td>返回数组中满足测试条件的一个元素，如果没有满足条件的元素，则返回undefined</td></tr><tr><td>findIndex(predicate[, thisArg])</td><td>用来查找数组中某指定元素的索引, 如果找不到指定的元素, 则返回 -1</td></tr><tr><td>forEach(callbackfn[, thisArg])</td><td>让数组的每一项都执行一次给定的函数</td></tr><tr><td>indexOf(searchElement[, fromIndex])</td><td>返回根据给定元素找到的第一个索引值，否则返回-1</td></tr><tr><td>keys()</td><td>返回包含数组的索引值的迭代器</td></tr><tr><td>lastIndexOf(searchElement[, fromIndex])</td><td>返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始</td></tr><tr><td>map(callbackfn[, thisArg])</td><td>返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组</td></tr><tr><td>pop()</td><td>从数组中移除最后一个元素并将该元素返回</td></tr><tr><td>push(…items)</td><td>添加一个或多个元素到数组的末尾，并返回数组新的长度（length 属性值）</td></tr><tr><td>reduce(callbackfn[, initialValue])</td><td>通过对数组中的所有元素（从左到右）调用定义的回调函数来累积单个结果。 回调函数的返回值是累积的结果，并且作为对回调函数的下一个调用中的参数提供</td></tr><tr><td>reduceRight(callbackfn[, initialValue])</td><td>通过对数组中的所有元素调用定义的回调函数来按降序顺序（从右到左）累积单个结果。 回调函数的返回值是累积的结果，并且作为对回调函数的下一个调用中的参数提供</td></tr><tr><td>reverse()</td><td>颠倒数组中元素的顺序</td></tr><tr><td>shift()</td><td>从数组中移除第一个元素并将返回该元素</td></tr><tr><td>slice(start, end)</td><td>把数组中一部分的浅复制（shallow copy）存入一个新的数组对象中，并返回这个新的数组</td></tr><tr><td>some(callbackfn[, thisArg])</td><td>测试数组中的某些元素是否通过了指定函数的测试</td></tr><tr><td>sort(comparefn)</td><td>对数组的元素做原地的排序，并返回这个数组。 sort 可能不是稳定的</td></tr><tr><td>splice(start, deleteCount, …items)</td><td>用新元素替换旧元素，以此修改数组的内容</td></tr><tr><td>toLocaleString([reserved1[, reserved2]])</td><td>返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开</td></tr><tr><td>toString()</td><td>返回一个字符串，表示指定的数组及其元素</td></tr><tr><td>unshift(…items)</td><td>在数组的开头添加一个或者多个元素，并返回数组新的 length 值</td></tr><tr><td>values()</td><td>返回一个新的包含数组中每个索引的取值的 Array Iterator （数组迭代）对象</td></tr><tr><td><a href="">@@iterator</a></td><td>返回迭代器</td></tr></tbody></table><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateVal)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, month, date[, hours[, minutes[, seconds[,ms]]]])</span><br></pre></td></tr></table></figure><p>Date 函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>Date.now()</td><td>返回 1970 年 1 月 1日与当前日期和时间之间的毫秒数。</td></tr><tr><td>Date.parse(string)</td><td>分析一个包含日期的字符串，并返回该日期与 1970 年 1 月 1 日午夜之间相差的毫秒数。</td></tr><tr><td>Date.UTC(year, month, date[, hours[, minutes[, seconds[,ms]]]])</td><td>返回协调通用时间 (UTC)（或 GMT）1970 年 1 月 1 日午夜与所提供的日期之间相差的毫秒数。</td></tr></tbody></table><p>Date实例方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getTime()</td><td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td></tr><tr><td>setTime(ms)</td><td>以毫秒数设置日期,会改变整个日期</td></tr><tr><td>getFullYear()</td><td>取得4位数的年份(如2007而非仅07)</td></tr><tr><td>getUTCFullYear()</td><td>返回UTC日期的4位数年份</td></tr><tr><td>setFullYear(year)</td><td>设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td></tr><tr><td>setUTCFullYear(year)</td><td>设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td></tr><tr><td>getMonth()</td><td>返回日期中的月份,其中0表示一月,11表示十二月</td></tr><tr><td>getUTCMonth()</td><td>返回UTC日期中的月份,其中0表示一月,11表示十二月</td></tr><tr><td>setMonth(month)</td><td>设置日期的月份。传入的月份值必须大于0,超过11则增加年份</td></tr><tr><td>setUTCMonth(month)</td><td>设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份</td></tr><tr><td>getDate()</td><td>返回日期月份中的天数(1到31)</td></tr><tr><td>getUTCDate()</td><td>返回UTC日期月份中的天数(1到31)</td></tr><tr><td>setDate(date)</td><td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td></tr><tr><td>setUTCDate(date)</td><td>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td></tr><tr><td>getDay()</td><td>返回日期中星期的星期几(其中0表示星期日,6表示星期六)</td></tr><tr><td>getUTCDay()</td><td>返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)</td></tr><tr><td>getHours()</td><td>返回日期中的小时数(0到23)</td></tr><tr><td>getUTCHours()</td><td>返回UTC日期中的小时数(0到23)</td></tr><tr><td>setHours(hours)</td><td>设置日期中的小时数。传入的值超过了23则增加月份中的天数</td></tr><tr><td>setUTCHours(hours)</td><td>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</td></tr><tr><td>getMinutes()</td><td>返回日期中的分钟数(0到59)</td></tr><tr><td>getUTCMinutes()</td><td>返回UTC日期中的分钟数(0到59)</td></tr><tr><td>setMinutes(minutes)</td><td>设置日期中的分钟数。传入的值超过59则增加小时数</td></tr><tr><td>setUTCMinutes(minutes)</td><td>设置UTC日期中的分钟数。传入的值超过59则增加小时数</td></tr><tr><td>getSeconds()</td><td>返回日期中的秒数(0到59)</td></tr><tr><td>getUTCSeconds()</td><td>返回UTC日期中的秒数(0到59)</td></tr><tr><td>setSeconds(seconds)</td><td>设置日期中的秒数。传入的值超过了59会增加分钟数</td></tr><tr><td>setUTCSeconds(seconds)</td><td>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</td></tr><tr><td>getMilliseconds()</td><td>返回日期中的毫秒数</td></tr><tr><td>getUTCMilliseconds()</td><td>返回UTC日期中的毫秒数</td></tr><tr><td>setMilliseconds(ms)</td><td>设置日期中的毫秒数</td></tr><tr><td>setUTCMilliseconds(ms)</td><td>设置UTC日期中的毫秒数</td></tr><tr><td>getTimezoneOffset()</td><td>返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化</td></tr><tr><td>toDateString()</td><td>以特定于实现的格式显示星期几、月、日和年；</td></tr><tr><td>toTimeString()</td><td>以特定于实现的格式显示时、分、秒和时区；</td></tr><tr><td>toLocaleDateString()</td><td>以特定于地区的格式显示星期几、月、日和年；</td></tr><tr><td>toLocaleTimeString()</td><td>以特定于实现的格式显示时、分、秒；</td></tr><tr><td>toUTCString()</td><td>以特定于实现的格式完整的UTC日期。</td></tr><tr><td>toJSON()</td><td>调用 toJSON() 返回一个 JSON 格式字符串 (使用 toISOString) ，表示该日期对象的值。默认情况下，这个方法常用于 JSON 序列化时序列化日期对象</td></tr></tbody></table><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern[, flags])</span><br><span class="line">/pattern/[flags]</span><br></pre></td></tr></table></figure><p>使用构造函数，pattern可以是字符串，ES6中也可以是正则字面量，如果是正则字面量第二个参数会覆盖字面量中的标志。构造函数如果第一个是字符串需要注意所有元字符需要双重转义（<code>\\</code>字符串中就是<code>\\\\</code>）</p><p>模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： <code>( [ { \ ^ $ | ) ? * + .]}</code></p><p>正则表达式的匹配模式支持下列 5 个标志，后两个是ES6新增。</p><ul><li>g :表示全局(global)模式,即模式将被应用于所有字符串,而非在发现第一个匹配项时立即停止;</li><li>i :表示不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写;</li><li>m :表示多行(multiline)模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li><li>u :表示“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li><li>y :表示“粘连”（sticky）模式。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。如果同时使用g修饰符和y修饰符，则y修饰符覆盖g修饰符。</li></ul><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p><ul><li>global：布尔值，表示是否设置了g标志。</li><li>ignoreCase：布尔值，表示是否设置了i标志。</li><li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li><li>multiline：布尔值，表示是否设置了m标志。</li><li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>ES6新增属性</li><li>sticky:布尔值，表示是否设置了y标志。</li><li>flags: 字符串，表示正则表达式的标志</li></ul><p>RegExp的实例方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>exec(str)</td><td>为指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串</td></tr><tr><td>test(str)</td><td>执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false</td></tr></tbody></table><p>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</p><p>正则表达式的valueOf()方法返回正则表达式本身。</p><p>RegExp 构造函数属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串。Opera未实现此属性</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项。Opera未实现此属性</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组。Opera未实现此属性</td></tr><tr><td>leftContext</td><td>$`</td><td>input字符串中lastMatch之前的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值,表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td></tr><tr><td>rightContext</td><td>$’</td><td>Input字符串中lastMatch之后的文本</td></tr></tbody></table><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(p1, p2, … , pn, body)</span><br></pre></td></tr></table></figure><p>JavaScript中所有函数都是Function类型的实例。</p><p>Function实例属性</p><ul><li>name： 函数名</li><li>length： 函数参数的个数</li><li>prototype： 函数原型</li></ul><p>Function实例方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>apply(thisArg, argArray)</td><td>指定 this 值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。 和call方法的区别是call方法接受的是一个参数列表</td></tr><tr><td>bind(thisArg, …args)</td><td>创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数</td></tr><tr><td>call(thisArg, …args)</td><td>在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>([value])</span><br></pre></td></tr></table></figure><p>基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p><h2 id="Number-1"><a href="#Number-1" class="headerlink" title="Number"></a>Number</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>([value])</span><br></pre></td></tr></table></figure><p>Number属性</p><ul><li>Number.MAX_VALUE 能表示的最大正数。最大的负数是 -MAX_VALUE。</li><li>Number.MIN_VALUE 能表示的最小正数 – 即，最接近 0 的正数 (实际上不会变成 0)。最小的负数是 -MIN_VALUE。</li><li>Number.MAX_SAFE_INTEGER 能表示的最大整数。(2^53?1).</li><li>Number.MIN_SAFE_INTEGER 能表示的最小整数。 (?(2^53?1))</li><li>Number.NaN 特殊的“非数字”值。</li><li>Number.NEGATIVE_INFINITY 特殊的负无穷大值，在溢出时返回。</li><li>Number.POSITIVE_INFINITY 特殊的正无穷大值，在溢出时返回。</li></ul><p>Number函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>Number.isFinite(number)</td><td>返回一个布尔值，该值指示值是否为有限数。</td></tr><tr><td>Number.isInteger(number)</td><td>返回一个布尔值，该值指示值是否为整数。</td></tr><tr><td>Number.isNaN(number)</td><td>返回一个布尔值，该值指示某个值是否为保留值 NaN（非数字）。</td></tr><tr><td>Number.isSafeInteger(number)</td><td>返回一个布尔值，该值指示值是否可在 JavaScript 中安全表示。</td></tr><tr><td>Number.parseFloat(string)</td><td>解析一个字符串并返回一个浮点数</td></tr><tr><td>Number.parseInt(string, radix)</td><td>解析一个字符串并返回一个整数，第二参数指定进制</td></tr></tbody></table><p>Number实例方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>toExponential(fractionDigits)</td><td>返回一个字符串，其中包含一个以指数记数法表示的数字。</td></tr><tr><td>toFixed(fractionDigits)</td><td>返回一个字符串，它表示定点表示法中的一个数字。</td></tr><tr><td>toLocaleString([reserved1[, reserved2]])</td><td>返回基于当前区域设置转换为字符串的对象。</td></tr><tr><td>toPrecision(precision)</td><td>返回一个字符串，其中包含一个以指数或定点表示法表示且具有指定位数的数字。</td></tr><tr><td>toString(radix)</td><td>返回对象的字符串表示形式。可以指定进制</td></tr><tr><td>valueOf()</td><td>返回指定对象的基元值。</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(value);</span><br></pre></td></tr></table></figure><p>ES6提供了对Unicode辅助平面码点的支持</p><p>String 函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>String.fromCharCode(…codeUnits)</td><td>根据指定的一或多个 Unicode 字符编码来返回一个字符串。</td></tr><tr><td>String.fromCodePoint(…codePoints)</td><td>可以识别码点大于0xFFFF（辅助平面）的字符，弥补了String.fromCharCode方法的不足</td></tr><tr><td>String.raw(template, …substitutions)</td><td>模板字符串的标签函数，它的作用类似于 Python 中的字符串前缀 r 和 C# 中的字符串前缀 @，是用来获取一个模板字符串的原始字面量值的</td></tr></tbody></table><p>String 实例的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt(pos)</td><td>返回指定索引处的字符。</td></tr><tr><td>charCodeAt(pos)</td><td>返回指定字符的 Unicode 编码。但是不支持辅助平面的码点</td></tr><tr><td>codePointAt(pos)</td><td>返回一个 Unicode UTF-16 字符的码点。辅助平面的码点</td></tr><tr><td>concat(…args)</td><td>返回由提供的两个字符串串联而成的字符串。</td></tr><tr><td>endsWith(searchString[,endPosition])</td><td>返回一个布尔值，该值指示字符串或子字符串是否以传入字符串结尾。</td></tr><tr><td>includes(searchString[, position])</td><td>返回一个布尔值，该值指示传入字符串是否包含在字符串对象中。</td></tr><tr><td>indexOf(searchString[, position])</td><td>返回字符串内第一次出现子字符串的字符位置。</td></tr><tr><td>lastIndexOf(searchString[, position])</td><td>返回字符串内子字符串的最后一个匹配项。</td></tr><tr><td>localeCompare(that[, reserved1[, reserved2]])</td><td>返回一个值，该值指示两个字符串在当前区域设置中是否相等。</td></tr><tr><td>match(regexp)</td><td>通过使用提供的正则表达式对象来搜索字符串并以数组形式返回结果。</td></tr><tr><td>normalize([form])</td><td>按照指定的一种 Unicode 正规形式将当前字符串正规化。四种 Unicode 正规形式 “NFC”, “NFD”, “NFKC”, 以及 “NFKD” 其中的一个, 默认值为 “NFC”</td></tr><tr><td>repeat(count)</td><td>返回一个新的字符串对象，它的值等于重复了指定次数的原始字符串。</td></tr><tr><td>replace(searchValue, replaceValue)</td><td>使用正则表达式替换字符串中的文本并返回结果。</td></tr><tr><td>search(regexp)</td><td>返回正则表达式搜索中第一个子字符串匹配项的位置。</td></tr><tr><td>slice(start, end)</td><td>返回字符串的片段。</td></tr><tr><td>split(separator, limit)</td><td>返回一个字符串拆分为若干子字符串时所产生的字符串数组。</td></tr><tr><td>startsWith(searchString[, position])</td><td>返回一个布尔值，该值指示字符串或子字符串是否以传入字符串开头。</td></tr><tr><td>substr(start, end)</td><td>返回一个从指定位置开始且具有指定长度的子字符串。</td></tr><tr><td>substring(start, end)</td><td>返回 String 对象中指定位置处的子字符串。</td></tr><tr><td>toLocaleLowerCase([reserved1[, reserved2]])</td><td>返回一个字符串，其中所有字母字符都转换为小写形式，并将考虑主机环境的当前区域设置。</td></tr><tr><td>toLocaleUpperCase([reserved1[, reserved2]])</td><td>返回一个字符串，其中所有字母字符都转换为大写形式，并将考虑主机环境的当前区域设置。</td></tr><tr><td>toLowerCase()</td><td>返回一个字符串，其中所有字母字符都转换为小写形式。</td></tr><tr><td>toString()</td><td>返回字符串。</td></tr><tr><td>toUpperCase()</td><td>返回一个字符串，其中所有字母字符都转换为大写形式。</td></tr><tr><td>trim()</td><td>返回已移除前导空格、尾随空格和行终止符的字符串。</td></tr><tr><td>valueOf()</td><td>返回字符串</td></tr><tr><td><a href="">@@iterator</a></td><td>返回迭代器</td></tr></tbody></table><p>ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr() 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和 substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。</p><p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0</p><h2 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h2><p>Global对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ,实际上全都是 Global 对象的方法。</p><ul><li><p>URI 编码方法<br>  对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 其中，encodeURI()主要用于整个URI（例如，<code>http://www.wrox.com/illegal value.htm</code>），而 encodeURIComponent()主要用于对URI中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p><p>  一般来说，我们使用 encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI进行编码。</p><p>  与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和decodeURIComponent()</p></li><li><p>eval()方法<br>  eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。看例子： eval(“alert(‘hi’)”); 这行代码的作用等价于代码： alert(“hi”);</p><p>  当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过 eval() 执行的代码可以引用在包<br>含环境中定义的变量 <code>var msg = &quot;hello world&quot;; eval(&quot;alert(msg)&quot;);</code></p><p>  在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。 严格模式下，在外部访问不到eval()中创建的任何变量或函数，在严格模式下,为 eval 赋值也会导致错误</p></li><li><p>Global 对象的属性<br>  特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下表列出了Global对象的所有属性。</p></li></ul><p>isFinite(number)，isNaN(number)，parseFloat(string)，parseInt(string , radix)这几个函数功能和Number的类似</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>undefined</td><td>特殊值 undefined</td></tr><tr><td>NaN</td><td>特殊值 NaN</td></tr><tr><td>Infinity</td><td>特殊值 Infinity</td></tr><tr><td>Date</td><td>构造函数 Date</td></tr><tr><td>RegExp</td><td>构造函数 RegExp</td></tr><tr><td>Error</td><td>构造函数 Error</td></tr><tr><td>Object</td><td>构造函数 Object</td></tr><tr><td>Array</td><td>构造函数 Array</td></tr><tr><td>Function</td><td>构造函数 Function</td></tr><tr><td>Boolean</td><td>构造函数 Boolean</td></tr><tr><td>String</td><td>构造函数 String</td></tr><tr><td>Number</td><td>构造函数 Number</td></tr><tr><td>EvalError</td><td>构造函数 EvalError</td></tr><tr><td>RangeError</td><td>构造函数 RangeError</td></tr><tr><td>ReferenceError</td><td>构造函数 ReferenceError</td></tr><tr><td>SyntaxError</td><td>构造函数 SyntaxError</td></tr><tr><td>TypeError</td><td>构造函数 TypeError</td></tr><tr><td>URIError</td><td>构造函数 URIError</td></tr></tbody></table><p>ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul><li>Math 对象的属性</li></ul><table><thead><tr><th>属 性</th><th>说 明</th></tr></thead><tbody><tr><td>Math.E</td><td>自然对数的底数，即常量e的值</td></tr><tr><td>Math.LN10</td><td>10的自然对数</td></tr><tr><td>Math.LN2</td><td>2的自然对数</td></tr><tr><td>Math.LOG2E</td><td>以2为底e的对数</td></tr><tr><td>Math.LOG10E</td><td>以10为底e的对数</td></tr><tr><td>Math.PI</td><td>π的值</td></tr><tr><td>Math.SQRT1_2</td><td>1/2的平方根（即2的平方根的倒数）</td></tr><tr><td>Math.SQRT2</td><td>2的平方根</td></tr></tbody></table><ul><li><p>min() 和 max() 方法<br>  这两个方法都可以接收任意多个数值参数，要查找数组中的最大值可以使用apply方法。</p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">var max = Math.max.apply(Math, values);</span><br></pre></td></tr></table></figure></li><li><p>舍入方法</p><ul><li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li><li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li><li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li></ul></li><li><p>random() 方法<br>  Math.random() 方法返回大于等于 0 小于 1 的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。 <code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code></p></li><li><p>其他方法</p></li></ul><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>Math.abs(num)</td><td>返回num 的绝对值</td></tr><tr><td>Math.exp(num)</td><td>返回Math.E 的num 次幂</td></tr><tr><td>Math.log(num)</td><td>返回num 的自然对数</td></tr><tr><td>Math.pow(num,power)</td><td>返回num 的power 次幂</td></tr><tr><td>Math.sqrt(num)</td><td>返回num 的平方根</td></tr><tr><td>Math.acos(x)</td><td>返回x 的反余弦值</td></tr><tr><td>Math.asin(x)</td><td>返回x 的反正弦值</td></tr><tr><td>Math.atan(x)</td><td>返回x 的反正切值</td></tr><tr><td>Math.atan2(y,x)</td><td>返回y/x 的反正切值</td></tr><tr><td>Math.cos(x)</td><td>返回x 的余弦值</td></tr><tr><td>Math.sin(x)</td><td>返回x 的正弦值</td></tr><tr><td>Math.tan(x)</td><td>返回x 的正切值</td></tr></tbody></table><ul><li>ES6新增方法</li></ul><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>Math.trunc(num)</td><td>去除一个数的小数部分，返回整数部分，对于空值和无法截取整数的值，返回NaN</td></tr><tr><td>Math.sign(num)</td><td>判断一个数到底是正数、负数、还是零。参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。</td></tr><tr><td>Math.cbrt(num)</td><td>计算一个数的立方根</td></tr><tr><td>Math.clz32(num)</td><td>返回一个数的32位无符号整数二进制形式表示有多少个前导0。对于小数，只考虑整数部分，对于其他值，先转为数值，再计算</td></tr><tr><td>Math.imul(num1,num2)</td><td>回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。多数情况和`(a * b)</td></tr><tr><td>Math.fround(num)</td><td>Math.fround方法返回一个数的单精度浮点数形式。对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</td></tr><tr><td>Math.hypot()</td><td>返回所有参数的平方和的平方根，如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN</td></tr><tr><td>Math.expm1()</td><td>返回Math.exp(x) - 1</td></tr><tr><td>Math.log1p()</td><td>返回1 + x的自然对数。如果x小于-1，返回NaN</td></tr><tr><td>Math.log10()</td><td>返回以10为底的x的对数。如果x小于0，则返回NaN</td></tr><tr><td>Math.log2()</td><td>返回以2为底的x的对数。如果x小于0，则返回NaN</td></tr><tr><td>Math.sinh(x)</td><td>返回x的双曲正弦（hyperbolic sine）</td></tr><tr><td>Math.cosh(x)</td><td>返回x的双曲余弦（hyperbolic cosine）</td></tr><tr><td>Math.tanh(x)</td><td>返回x的双曲正切（hyperbolic tangent）</td></tr><tr><td>Math.asinh(x)</td><td>返回x的反双曲正弦（inverse hyperbolic sine）</td></tr><tr><td>Math.acosh(x)</td><td>返回x的反双曲余弦（inverse hyperbolic cosine）</td></tr><tr><td>Math.atanh(x)</td><td>返回x的反双曲正切（inverse hyperbolic tangent）</td></tr></tbody></table><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([iterable])</span><br></pre></td></tr></table></figure><p>Map对象属性：size，映射中的元素数</p><p>Map对象方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>clear()</td><td>清除所有成员，没有返回值。</td></tr><tr><td>delete(key)</td><td>删除某个键，返回true。如果删除失败，返回false。</td></tr><tr><td>forEach(callbackfn[, thisArg])</td><td>对映射中的每个元素执行指定操作。</td></tr><tr><td>get(key)</td><td>读取key对应的键值，如果找不到key，返回undefined。</td></tr><tr><td>has(key)</td><td>返回一个布尔值，表示某个键是否在Map数据结构中。</td></tr><tr><td>set(key,value)</td><td>设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</td></tr><tr><td>entries()</td><td>返回所有成员的Iterator对象。</td></tr><tr><td>keys()</td><td>返回键名的Iterator对象。</td></tr><tr><td>values()</td><td>返回键值的Iterator对象。</td></tr></tbody></table><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">WeakMap</span>([iterable])</span><br></pre></td></tr></table></figure><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p><p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p><p>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([iterable])</span><br></pre></td></tr></table></figure><p>Set 实例属性size，返回元素个数</p><p>Set 实例方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>clear()</td><td>清除所有成员，没有返回值。</td></tr><tr><td>delete(value)</td><td>删除某个键，返回true。如果删除失败，返回false。</td></tr><tr><td>forEach(callbackfn[, thisArg])</td><td>对映射中的每个元素执行指定操作。</td></tr><tr><td>has(value)</td><td>返回一个布尔值，表示某个键是否在Set数据结构中。</td></tr><tr><td>add(value)</td><td>设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</td></tr><tr><td>entries()</td><td>返回所有成员的Iterator对象。</td></tr><tr><td>keys()</td><td>返回键名的Iterator对象。</td></tr><tr><td>values()</td><td>返回键值的Iterator对象。</td></tr></tbody></table><p>entries，keys，values三个方法返回一样。</p><p>数组、Map、Set实例都有entries，keys，values这三个方法，都返回一个迭代器，实现了Iterable和Iterator接口。且其<code>Symbol.iterator</code>方法的返回值就是其本身</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">WeakSet</span>([iterable])</span><br></pre></td></tr></table></figure><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p><p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p><p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p><p>实例只有add，delete，has三个方法。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<code>new Proxy()</code>表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p><p>Proxy.revocable(target, handler)</p><table><thead><tr><th>处理程序方法（陷阱）语法</th><th>用法示例</th></tr></thead><tbody><tr><td>apply: function(target, thisArg, args)</td><td>函数调用陷阱。</td></tr><tr><td>construct: function(target, args)</td><td>构造函数陷阱。</td></tr><tr><td>defineProperty: function(target, propertyName, descriptor)</td><td>Object.defineProperty 函数 (JavaScript) 陷阱。</td></tr><tr><td>deleteProperty: function(target, propertyName)</td><td>delete 语句的陷阱。</td></tr><tr><td>enumerate: function(target)</td><td>for…in 语句、Object.getOwnPropertySymbols、Object.keys 函数和 JSON.stringify 的陷阱。</td></tr><tr><td>get: function(target, propertyName, receiver)</td><td>任何 getter 属性的陷阱。</td></tr><tr><td>getOwnPropertyDescriptor: function(target, propertyName)</td><td>Object.getOwnPropertyDescriptor 函数 (JavaScript) 的陷阱。</td></tr><tr><td>getPrototypeOf: function(target)</td><td>Object.getPrototypeOf 函数 (JavaScript) 的陷阱。</td></tr><tr><td>has: function(target, propertyName)</td><td>in 运算符、hasOwnProperty 方法 (Object) (JavaScript) 和其他方法的陷阱。</td></tr><tr><td>isExtensible: function(target)</td><td>Object.isExtensible 函数 (JavaScript) 的陷阱。</td></tr><tr><td>ownKeys: function(target)</td><td>Object.getOwnPropertyNames 函数 (JavaScript) 的陷阱。</td></tr><tr><td>preventExtensions: function(target)</td><td>Object.preventExtensions 函数 (JavaScript) 的陷阱。</td></tr><tr><td>set: function(target, propertyName, value, receiver)</td><td>任何 setter 属性的陷阱。</td></tr><tr><td>setPrototypeOf: function(target, prototype)</td><td>Object.setPrototypeOf 的陷阱。</td></tr></tbody></table><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>Reflect 方法通常与Proxy一起使用，因为后者允许你委托默认行为而无需在代码中实现该默认行为。</p><p>Reflect 提供与每个代理陷阱具有相同名称的静态方法</p><p>Reflect函数清单如下。</p><ul><li>Reflect.getOwnPropertyDescriptor(target,name)</li><li>Reflect.defineProperty(target,name,desc)</li><li>Reflect.getOwnPropertyNames(target)</li><li>Reflect.getPrototypeOf(target) 读取对象的<code>__proto__</code>属性，等同于<code>Object.getPrototypeOf(obj)</code>。</li><li>Reflect.setPrototypeOf(obj, newProto) 设置对象的<code>__proto__</code>属性，注意，Object对象没有对应这个方法的方法。</li><li>Reflect.deleteProperty(target,name) 等同于<code>delete obj[name]</code>。</li><li>Reflect.enumerate(target)</li><li>Reflect.freeze(target)</li><li>Reflect.seal(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.isFrozen(target)</li><li>Reflect.isSealed(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.has(target,name) 等同于<code>name in obj</code>。</li><li>Reflect.hasOwn(target,name)</li><li>Reflect.keys(target)</li><li>Reflect.get(target,name,receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数，则读取函数的this绑定receiver。</li><li>Reflect.set(target,name,value,receiver) 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</li><li>Reflect.apply(target,thisArg,args) 等同于<code>Function.prototype.apply.call(fun,thisArg,args)</code>。一般来说，如果要绑定一个函数的this对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的apply方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用Reflect对象可以简化这种操作。</li><li>Reflect.construct(target,args) 等同于<code>new target(...args)</code>，这提供了一种不使用new，来调用构造函数的方法。</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>Promise必须完成（返回一个值）或者必须被拒绝（返回一个原因）。Promise完成或被拒绝时（无论哪一个先发生），Promise 对象的 then 方法都会运行。如果承诺成功完成，则将运行 then 方法的履行处理程序函数。如果承诺被拒绝，则将运行 then 方法（或 catch 方法）的错误处理程序函数。</p><p>Promise对象有以下两个特点。</p><ol><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ol><p>Promise函数</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>Promise.all(iterable)</td><td>返回一个promise，该promise会在iterable参数内的所有promise都被解决后被解决。如果传入的可迭代数组中某项不是一个promise，该项会被用Promise.resolve转换为一个promise。如果任一传入的promise被拒绝了，all Promise立刻带着该promise的拒绝原因进入拒绝(rejected)状态，不再理会其它传入的promise是否被解决。</td></tr><tr><td>Promise.race(iterable)</td><td>返回一个promise，这个promise在iterable中的任意一个promise被解决或拒绝后，立刻以相同的解决值被解决或以相同的拒绝原因被拒绝。</td></tr><tr><td>Promise.reject(reason)</td><td>返回一个用reason拒绝的Promise</td></tr><tr><td>Promise.resolve(x)</td><td>返回一个以给定值resolve掉的Promise对象。但如果这个值是thenable的（就是说带有then方法），返回的promise会“追随”这个thenable的对象，接收它的最终状态（指resolved/rejected/pendding/settled）；否则这个被返回的promise对象会以这个值被fulfilled</td></tr></tbody></table><p>Promise对象方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>then(onFulfilled, onRejected)</td><td>返回一个Promise。它有两个参数，分别为Promise在 success 和 failure 情况下的回调函数</td></tr><tr><td>catch(onRejected)</td><td>只处理Promise被拒绝的情况，并返回一个Promise。该方法的行为和调用Promise.prototype.then(undefined, onRejected)相同</td></tr></tbody></table><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>异步编程对JavaScript语言很重要。JavaScript只有一个线程，如果没有异步编程，性能堪忧。</p><p>ES6之前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise 对象</li></ul><h2 id="异步基本概念"><a href="#异步基本概念" class="headerlink" title="异步基本概念"></a>异步基本概念</h2><p>所谓”异步”，简单说就好比把一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面回调函数会有多重嵌套，Promise允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><p>Thunkify模块和co模块可以自动执行Generator函数</p><p>基于Promise对象的自动执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的Generator函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>async函数现在是ES7的一个提案。上面例子写成 async 函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，async函数就是将Generator函数的星号（<code>*</code>）替换成async，将yield替换成await，仅此而已。</p><p>参考：</p><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">JavaScript秘密花园</a></p>]]></content>
    
    <summary type="html">
    
      JavaScript 总结，涉及变量，数据类型，操作符，语句，函数，模块，错误处理，垃圾回收，面向对象编程，原生类型，异步编程；声明提升，typeof，对象的类定义，undefined &amp; null，类型转换，Symbol，Number，模板字符串，标签模板，ES6中的`...`，解构赋值，for-in，with，for-of，函数声明和表达式，arguments，this，函数返回值，默认参数，rest参数，扩展运算符，箭头函数，Generator函数，尾调用优化，作用域，闭包，对象，继承，Object，Array，Date，RegExp，Function，Boolean，Number，String，Global，Math，Map，WeakMap，Set，WeakSet，Proxy，Reflect，Promise，回调函数，async函数；属性类型，对象使用和属性，原型，创建对象，class，共享变量，静态变量，私有变量，静态私有变量，模块模式，增强的模块模式，原型链，继承方法，extends
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象程序设计、函数表达式和异步编程</title>
    <link href="http://howiefh.github.io/2015/08/28/javascript-oop-function-expression-and-async/"/>
    <id>http://howiefh.github.io/2015/08/28/javascript-oop-function-expression-and-async/</id>
    <published>2015-08-28T04:23:08.000Z</published>
    <updated>2020-05-02T14:28:14.484Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="/2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="/2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记是对《JavaScript 高级程序设计》和 <a href="https://github.com/ruanyf/es6tutorial/tree/5a5f9d8d492d0f925cbb6e09b10ebed9d2078d40" target="_blank" rel="noopener">《ECMAScript 6入门》</a>两本书的总结整理。</p><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数</p><a id="more"></a><h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>ECMAScript 中有两种属性:数据属性和访问器属性。</p><ol><li><p>数据属性<br> 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。</p><ul><li><p>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</p></li><li><p>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</p></li><li><p>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</p></li><li><p>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</p><p>像例子中那样直接在对象上定义的属性,它们的 [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 特性都被设置为 true ,而 [[Value]] 特性被设置为”Nicholas”。例如: <code>var person = { name: &quot;Nicholas&quot; };</code></p><p>要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改对应的特性值。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line"><span class="keyword">Object</span>.defineProperty(person, "name", &#123;</span><br><span class="line">  writable: <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">value</span>: "Nicholas"</span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name); //"Nicholas"</span><br><span class="line">person.name = "Greg";</span><br><span class="line">alert(person.name); //"Nicholas"</span><br></pre></td></tr></table></figure><p>name属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。</p><p>把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且,一旦把属性定义为不可配置的,就不能再把它变回可配置了。此时,再调用 Object.defineProperty() 方法修改除 writable 之外的特性</p><p>可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。</p></li></ul></li><li><p>访问器属性<br> 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。</p><ul><li><p>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</p></li><li><p>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</p></li><li><p>[[Get]]：在读取属性时调用的函数。默认值为undefined。</p></li><li><p>[[Set]]：在写入属性时调用的函数。默认值为undefined。</p><p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="type">2004</span>,</span><br><span class="line">  edition: <span class="type">1</span></span><br><span class="line"><span class="type"></span>&#125;;</span><br><span class="line">Object.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="type">function</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: <span class="type">function</span>(<span class="keyword">new</span><span class="type">Value</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Value</span> &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>._year = <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">      <span class="built_in">this</span>.edition += <span class="keyword">new</span><span class="type">Value</span> - <span class="number">2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><code>_year</code>前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。</p><p>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">book.__defineGetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span></span>()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">&#125;);</span><br><span class="line">book.__defineSetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span></span>(<span class="keyword">new</span><span class="type">Value</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Value</span> &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._year = <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">    <span class="built_in">this</span>.edition += <span class="keyword">new</span><span class="type">Value</span> - <span class="number">2004</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>支持ECMAScript 5的这个方法的浏览器有IE9+（IE8只是部分实现）、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。<br>在不支持 Object.defineProperty() 方法的浏览器中不能修改 [[Configurable]] 和 [[Enumerable]] 。</p></li></ul></li></ol><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>由于为对象定义多个属性的可能性很大，ECMAScript 5又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(book, &#123;</span><br><span class="line">  _year: <span class="type"></span>&#123;</span><br><span class="line">    value: <span class="type">2004</span></span><br><span class="line"><span class="type">  </span>&#125;,</span><br><span class="line">  edition: <span class="type"></span>&#123;</span><br><span class="line">    value: <span class="type">1</span></span><br><span class="line"><span class="type">  </span>&#125;,</span><br><span class="line">  year: <span class="type"></span>&#123;</span><br><span class="line">    <span class="keyword">get</span>: <span class="type">function</span>()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="type">function</span>(<span class="keyword">new</span><span class="type">Value</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Value</span> &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._year = <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">        <span class="built_in">this</span>.edition += <span class="keyword">new</span><span class="type">Value</span> - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 ECMAScript 5的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var descriptor = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">OwnPropertyDescriptor(<span class="params">book</span>, <span class="string">"_year"</span>)</span>;</span><br><span class="line">alert(descriptor.value); <span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>用函数来封装以特定接口创建对象的细节</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：</p><ul><li>没有显式地创建对象；</li><li>直接将属性和方法赋给了this对象；</li><li>没有return语句。</li></ul><p>此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他OO语言，主要是为了区别于ECMAScript中的其他函数；本质上它和其它函数没有区别的，任何函数通过new调用就会被当做构造函数。 要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤： (1) 创建一个新对象； (2) 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； (3) 执行构造函数中的代码（为这个新对象添加属性）； (4) 返回新对象。</p><ol><li><p>将构造函数当作函数<br> 构造函数本身就是一个普通的函数，所以我们不使用new关键字，可以看下调用Person会有什么结果</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为普通函数调用，由于构造函数没有返回值，所以p将是undefined</span></span><br><span class="line">var p = <span class="constructor">Person(<span class="string">"Greg"</span>, 27, <span class="string">"Doctor"</span>)</span>; <span class="comment">// 在全局作用域中调用一个函数时, this 对象总是指向 Global 对象，这里就是添加到 window</span></span><br><span class="line">window.say<span class="constructor">Name()</span>; <span class="comment">//"Greg"</span></span><br><span class="line">say<span class="constructor">Name()</span>; <span class="comment">//"Greg"</span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line">var o = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.say<span class="constructor">Name()</span>; <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数的问题<br> 上面的声明函数等价于<code>this.sayName = new Function(&quot;alert(this.name)&quot;);</code></p><p> 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。可以通过将函数声明在全局作用域，通过<code>this.sayName = sayName</code>赋值，但在全局作用域添加函数不是一种好的做法。这个问题可以通过原型模式解决</p></li></ol><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.age = <span class="number">29</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.sayName = <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>理解原型对象<br> JavaScript中函数都是Function类型的实例，把Person当做一个指针，它指向一个Function类型的对象，每个Function实例都有prototype属性，其指向一个函数的原型对象，通过Person.prototype就可以访问到这个对象。默认情况下，每个原型对象都有一个constructor属性，这个属性指向 prototype 属性所在函数也就是Person。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。每个对象都有[[Prototype]]属性（内部属性），虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code>；而在其他实现中，这个属性对脚本则是完全不可见的。这个属性指向了构造函数的原型对象，也就是Person.prototype指向的对象。JavaScript中通过递归原型链来查找对象属性，因此person1和person2可以访问到其原型Person.prototype中的属性constructor。除了通过instanceof外也可以通过person1.constructor === Person来判断是否是Person类型，但是instanceof更加可靠，因为prototype对象完全可以被覆盖，其属性constructor也就不一定是Person了。</p> <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+ <span class="variable">&lt;------------------------------+</span></span><br><span class="line"><span class="variable">|      Person       |                                |</span></span><br><span class="line"><span class="variable">+-------------------+                                |</span></span><br><span class="line"><span class="variable">|prototype|        -|--+--&gt;</span>+----------------------+  |</span><br><span class="line"><span class="string">+-------------------+  </span>|<span class="string">   </span>|<span class="string">     Person prototype </span>|<span class="string">  </span>|</span><br><span class="line">                       |<span class="string">   +----------------------+  </span>|</span><br><span class="line">+--------------------+ |<span class="string">   </span>|<span class="string">constructor</span>|<span class="string">         -</span>|<span class="string">--+</span></span><br><span class="line">|<span class="string">      person1       </span>|<span class="string"> </span>|<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">+--------------------+ </span>|<span class="string">   </span>|<span class="string">name       </span>|<span class="string">"Nicholas"</span>|</span><br><span class="line">|<span class="string">[[Prototype]]</span>|<span class="string">     -</span>|<span class="string">-+   +----------------------+</span></span><br><span class="line"><span class="string">+--------------------+ </span>|<span class="string">   </span>|<span class="string">age        </span>|<span class="string">     29   </span>|</span><br><span class="line">                       |<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">+--------------------+ </span>|<span class="string">   </span>|<span class="string">job        </span>|<span class="string">"Soft...."</span>|</span><br><span class="line">|<span class="string">      person2       </span>|<span class="string"> </span>|<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">+--------------------+ </span>|<span class="string">   </span>|<span class="string">sayName    </span>|<span class="string">(function)</span>|</span><br><span class="line">|<span class="string">[[Prototype]]</span>|<span class="string">     -</span>|<span class="string">-+   +----------------------+</span></span><br><span class="line"><span class="string">+--------------------+</span></span><br></pre></td></tr></table></figure><p> 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回true</p><p> ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。</p><p> 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p><p> 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<code>person1.name = &quot;Greg&quot;;</code>将会覆盖原型中的name属性。</p><p> 不过，使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性</p><p> 使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。<code>person1.hasOwnProperty(&quot;name&quot;);person2.hasOwnProperty(&quot;name&quot;);</code>第一个返回true，第二个返回false</p><p> ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法只能用于实例属性,要取得原型属性的描述符,必须直接在原型对象上调用 Object.getOwnPropertyDescriptor() 方法。</p></li><li><p>原型与 in 操作符<br> 有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<code>&quot;name&quot; in person1</code>为true</p><p> 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。</p><p> 要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p><p> 为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(Person.prototype); <span class="regexp">//</span>[<span class="string">"name"</span>,<span class="string">"age"</span>,<span class="string">"jbo"</span>,<span class="string">"sayName"</span>]</span><br><span class="line">var keys = Object.getOwnPropertyNames(Person.prototype); <span class="regexp">//</span>[<span class="string">"constructor"</span>,<span class="string">"name"</span>,<span class="string">"age"</span>,<span class="string">"jbo"</span>,<span class="string">"sayName"</span>]</span><br></pre></td></tr></table></figure></li><li><p>更简单的原型语法<br> 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</p> <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; alert(<span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 这时constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值。</p> <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; alert(<span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。默认情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript 5的JavaScript引擎，可以试一试Object.defineProperty()。</p></li><li><p>原型的动态性<br> 由于在原型中查找值的过程是一次搜索,因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.sayHi = <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">  alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.say<span class="constructor">Hi()</span>; <span class="comment">//"hi"(没有问题!)</span></span><br></pre></td></tr></table></figure><p> 其原因可以归结为实例与原型之间的松散连接关系。当我们调用person.sayHi()时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。</p><p> 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数</p></li><li><p>原生对象的原型<br> 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。但是不推荐这么做。</p></li><li><p>原型对象的问题<br> 原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。</p></li></ol><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。这是用来定义引用类型的一种默认模式。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor : Person,</span><br><span class="line">  sayName : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时,很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if中这段代码只会在初次调用构造函数时才会执行。</p><p>使用动态原型模式时,不能使用对象字面量重写原型。前面已经解释过了,如果在已经创建了实例的情况下重写原型,那么就会切断现有实例与新原型之间的联系。</p><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。添加return可以重写调用构造函数时返回的值。</p><p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new 操作符调用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><p>除了调用 sayName() 方法外,没有别的方式可以访问其数据成员。</p><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, job)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = new Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。</p><p>如果对比前面的组合使用构造函数模式和原型模式，可以发现前面的Person构造函数对应现在Person类的构造方法constructor，前面Person原型上定义的sayName方法现在是类的内部方法。</p><p>ES6的类，完全可以看作构造函数的另一种写法。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Person <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><p>prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype<span class="function">.<span class="keyword">constructor</span> === <span class="title">Person</span><span class="comment">// true</span></span></span><br></pre></td></tr></table></figure><p>另外，类的内部所有定义的方法，都是不可枚举的（enumerable）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>keys(<span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">OwnPropertyNames(Person.<span class="params">prototype</span>)</span></span><br><span class="line"><span class="comment">// ["constructor","sayName"]</span></span><br></pre></td></tr></table></figure><p>上面代码中，sayName方法是Person类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p><h4 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h4><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p><h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p>生成实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p><p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p><p>与ES5一样，类的所有实例共享一个原型对象。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friend.__proto__</span> === Person.prototype  //<span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h4><p>由于本质上，ES6的Class只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>name</span><br></pre></td></tr></table></figure><h4 id="class-表达式"><a href="#class-表达式" class="headerlink" title="class 表达式"></a>class 表达式</h4><p>与函数一样，Class也可以使用表达式的形式定义。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="keyword">class</span> <span class="symbol">Me</span> &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。如果Class内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>采用Class表达式，可以写出立即执行的Class。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Foo</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把变量声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let <span class="type">Foo</span> = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><h4 id="class的取值函数（getter）和存值函数（setter）"><a href="#class的取值函数（getter）和存值函数（setter）" class="headerlink" title="class的取值函数（getter）和存值函数（setter）"></a>class的取值函数（getter）和存值函数（setter）</h4><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure><p>存值函数和取值函数是设置在属性的descriptor对象上的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">"html"</span>);</span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p><p>下面的例子针对所有属性，设置存值函数和取值函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jedi</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(key, <span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>[key] = <span class="keyword">val</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Jedi实例所有属性的存取，都会通过存值函数和取值函数。</p><h4 id="Class的Generator方法"><a href="#Class的Generator方法" class="headerlink" title="Class的Generator方法"></a>Class的Generator方法</h4><p>如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认Iterator对象，for…of循环会自动调用这个方法。</p><h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  static <span class="keyword">class</span><span class="constructor">Method()</span> &#123;</span><br><span class="line">    return 'hello';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span><span class="keyword">class</span><span class="constructor">Method()</span> <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line">var foo = <span class="keyword">new</span> <span class="constructor">Foo()</span>;</span><br><span class="line">foo.<span class="keyword">class</span><span class="constructor">Method()</span></span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（<code>Foo.classMethod()</code>），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>父类的静态方法，可以被子类继承。</p><p>静态方法也是可以从super对象上调用的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">'hell</span>o';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + ', too';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Bar</span>.classMethod();</span><br></pre></td></tr></table></figure><h4 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h4><p>new是从构造函数生成实例的命令。ES6为new命令引入了一个<code>new.target</code>属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，<code>new.target</code>会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>(name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type"></span>.target !== undefined) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>(name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type"></span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">'张三'</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码确保构造函数只能通过new命令调用。</p><p>Class内部调用<code>new.target</code>，返回当前Class。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">  constructor(length, <span class="built_in">width</span>) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    console.log(<span class="keyword">new</span>.target === <span class="type">Rectangle</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="type">Square</span>(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new.target</code>会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === <span class="type">Shape</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>('本类不能实例化');</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="type">Shape</span>();  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="type">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面代码中，Shape类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用<code>new.target</code>会报错。</p><h4 id="Mixin模式的实现"><a href="#Mixin模式的实现" class="headerlink" title="Mixin模式的实现"></a>Mixin模式的实现</h4><p>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mix(...mixins) &#123;</span><br><span class="line">  <span class="keyword">class</span> Mix &#123;&#125;</span><br><span class="line"></span><br><span class="line">  for (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    copy<span class="constructor">Properties(Mix, <span class="params">mixin</span>)</span>;</span><br><span class="line">    copy<span class="constructor">Properties(Mix.<span class="params">prototype</span>, <span class="params">mixin</span>.<span class="params">prototype</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Mix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> copy<span class="constructor">Properties(<span class="params">target</span>, <span class="params">source</span>)</span> &#123;</span><br><span class="line">  for (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="module-access"><span class="module"><span class="identifier">Reflect</span>.</span></span>own<span class="constructor">Keys(<span class="params">source</span>)</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key !== <span class="string">"constructor"</span></span><br><span class="line"><span class="operator">      &amp;&amp; </span>key !== <span class="string">"prototype"</span></span><br><span class="line"><span class="operator">      &amp;&amp; </span>key !== <span class="string">"name"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">let</span> desc = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">OwnPropertyDescriptor(<span class="params">source</span>, <span class="params">key</span>)</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>define<span class="constructor">Property(<span class="params">target</span>, <span class="params">key</span>, <span class="params">desc</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedEdit</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="params"><span class="type">Loggable</span>, <span class="type">Serializable</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">SuperType()</span>&#123;</span><br><span class="line">    this.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>prototype.getSuperValue = <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="constructor">SubType()</span>&#123;</span><br><span class="line">    this.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inherit from SuperType</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">SuperType()</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype.getSubValue = <span class="keyword">function</span> <span class="literal">()</span>&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = <span class="keyword">new</span> <span class="constructor">SubType()</span>;</span><br><span class="line">alert(instance.get<span class="constructor">SuperValue()</span>);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(instance instanceof Object);      <span class="comment">//true</span></span><br><span class="line">alert(instance instanceof SuperType);   <span class="comment">//true</span></span><br><span class="line">alert(instance instanceof SubType);     <span class="comment">//true</span></span><br><span class="line">alert(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>prototype.is<span class="constructor">PrototypeOf(<span class="params">instance</span>)</span>);    <span class="comment">//true</span></span><br><span class="line">alert(<span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>prototype.is<span class="constructor">PrototypeOf(<span class="params">instance</span>)</span>); <span class="comment">//true</span></span><br><span class="line">alert(<span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype.is<span class="constructor">PrototypeOf(<span class="params">instance</span>)</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>既然 SubType.prototype 现在是 SuperType的实例,那么 property 当然就位于该实例中了。此外,要注意 instance.constructor 现在指向的是 SuperType ,这是因为SubType 的原型指向了另一个对象—— SuperType 的原型,而这个原型对象的 constructor 属性指向的是 SuperType。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|<span class="string">      SuperType    </span>|<span class="string"> &lt;--------------------------------+</span></span><br><span class="line"><span class="string">+-------------------+                                  </span>|</span><br><span class="line">|<span class="string">prototype</span>|<span class="string">        -</span>|<span class="string">----+&gt;+------------------------+  </span>|</span><br><span class="line">+-------------------+    |<span class="string"> </span>|<span class="string">   SuperType prototype  </span>|<span class="string">  </span>|</span><br><span class="line">                         |<span class="string"> +------------------------+  </span>|</span><br><span class="line">+--------------------+   |<span class="string"> </span>|<span class="string">constructor  </span>|<span class="string">         -</span>|<span class="string">--+</span></span><br><span class="line">|<span class="string">      SubType       </span>|<span class="string">   </span>|<span class="string"> +------------------------+</span></span><br><span class="line"><span class="string">+--------------------+   </span>|<span class="string"> </span>|<span class="string">getSuperValue</span>|<span class="string">(function)</span>|</span><br><span class="line">|<span class="string">  prototype  </span>|<span class="string">     -</span>|<span class="string">-+ </span>|<span class="string"> +------------------------+</span></span><br><span class="line"><span class="string">+--------------------+ </span>|<span class="string"> +----------------------------+</span></span><br><span class="line"><span class="string">                       </span>|<span class="string">   +------------------------+ </span>|</span><br><span class="line">+--------------------+ |<span class="string">--&gt;</span>|<span class="string">    SubType prototype   </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string">      instance      </span>|<span class="string"> </span>|<span class="string">   +------------------------+ </span>|</span><br><span class="line">+--------------------+ |<span class="string">   </span>|<span class="string">[[Prototype]]</span>|<span class="string">         -</span>|<span class="string">-+</span></span><br><span class="line">|<span class="string">[[Prototype]]</span>|<span class="string">     -</span>|<span class="string">-+   +------------------------+</span></span><br><span class="line"><span class="string">+--------------------+     </span>|<span class="string">property     </span>|<span class="string">  true    </span>|</span><br><span class="line">|<span class="string">subproperty  </span>|<span class="string"> false</span>|<span class="string">     +------------------------+</span></span><br><span class="line"><span class="string">+--------------------+     </span>|<span class="string">getSubValue  </span>|<span class="string">(function)</span>|</span><br><span class="line">                           +------------------------+</span><br></pre></td></tr></table></figure><p>通过实现原型链,本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得,当以读取模式访问一个实例属性时,首先会在实例中搜索该属性。如果没有找到该属性,则会继续搜索实例的原型。在通过原型链实现继承的情况下,搜索过程就得以沿着原型链继续向上。就拿上面的例子来说,调用instance.getSuperValue() 会经历三个搜索步骤:1)搜索实例;2)搜索 SubType.prototype ; 3)搜索 SuperType.prototype ,最后一步才会找到该方法。在找不到属性或方法的情况下,搜索过程总是要一环一环地前行到原型链末端才会停下来。</p><ol><li><p>别忘记默认的原型<br> 事实上,前面例子中展示的原型链还少一环。我们知道,所有引用类型默认都继承了 Object ,而这个继承也是通过原型链实现的。大家要记住,所有函数的默认原型都是 Object 的实例,因此默认原型都会包含一个内部指针,指向 Object.prototype</p></li><li><p>确定原型和实例的关系<br> 第一种方式是使用 instanceof 操作符,只要用这个操作符来测试实例与原型链中出现过的构造函数,结果就会返回 true。<br> 第二种方式是使用 isPrototypeOf() 方法。同样,只要是原型链中出现过的原型,都可以说是该原型链所派生的实例的原型,因此 isPrototypeOf() 方法也会返回 true</p></li><li><p>谨慎地定义方法<br> 子类型有时候需要重写超类型中的某个方法,或者需要添加超类型中不存在的某个方法。但不管怎样,给原型添加方法的代码一定要放在替换原型的语句之后。</p> <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">//添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写超类型中的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 还有一点需要提醒读者,即在通过原型链实现继承时,不能使用对象字面量创建原型方法。因为这样做就会重写原型链</p></li><li><p>原型链的问题<br> 原型链虽然很强大,可以用它来实现继承,但它也存在一些问题。其中,最主要的问题来自包含引用类型值的原型。</p><p> 在通过原型来实现继承时,原型实际上会变成另一个类型的实例。于是,原先的实例属性也就顺理成章地变成了现在的原型属性了。这些继承的属性会被子类实例共享。</p> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span></span>()&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> <span class="type">SuperType</span>();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="type">SubType</span>();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="type">SubType</span>();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure><p> 原型链的第二个问题是:在创建子类型的实例时,不能向超类型的构造函数中传递参数。基于这两点原因实践中很少单独使用原型链</p></li></ol><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中,开发人员开始使用一种叫做借用构造函数(constructor stealing)的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单,即在子类型构造函数的内部调用超类型构造函数。别忘了,函数只不过是在特定环境中执行代码的对象,因此通过使用 apply() 和 call() 方法也可以在(将来)新创建的对象上执行构造函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//继承了 SuperType 同时还传递了参数</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">alert(instance2.name);</span><br><span class="line">alert(instance2.age);</span><br></pre></td></tr></table></figure><ol><li>传递参数<br> 这种方法解决了原型链的两个主要的问题，为了确保SuperType 构造函数不会重写子类型的属性,可以在调用超类型构造函数后,再添加应该在子类型中定义的属性。</li><li>借用构造函数的问题<br> 如果仅仅是借用构造函数,那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义,因此函数复用就无从谈起了。而且,在超类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式。考虑到这些问题,借用构造函数的技术也是很少单独使用的。</li></ol><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承(combination inheritance) ,有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">SuperType(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = <span class="literal">["<span class="identifier">red</span>", "<span class="identifier">blue</span>", "<span class="identifier">green</span>"]</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>prototype.sayName = <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">SubType(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>call(this, name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">SuperType()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype.constructor = SubType;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype.sayAge = <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">  alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = <span class="keyword">new</span> <span class="constructor">SubType(<span class="string">"Nicholas"</span>, 29)</span>;</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.say<span class="constructor">Name()</span>; <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.say<span class="constructor">Age()</span>; <span class="comment">//29</span></span><br><span class="line">var instance2 = <span class="keyword">new</span> <span class="constructor">SubType(<span class="string">"Greg"</span>, 27)</span>;</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.say<span class="constructor">Name()</span>; <span class="comment">//"Greg";</span></span><br><span class="line">instance2.say<span class="constructor">Age()</span>; <span class="comment">//27</span></span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>道格拉斯·克罗克福德在 2006 年写了一篇文章,题为 Prototypal Inheritance in JavaScript (JavaScript 中的原型式继承)。在这篇文章中,他介绍了一种实现继承的方法,这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象,同时还不必因此创建自定义类型。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 object() 函数内部,先创建了一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例。从本质上讲, object() 对传入其中的对象执行了一次浅复制。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  <span class="type">name</span>: "Nicholas",</span><br><span class="line">  friends: ["Shelby", "Court", "Van"]</span><br><span class="line">&#125;;</span><br><span class="line">//var anotherPerson = <span class="keyword">object</span>(person);</span><br><span class="line">var anotherPerson = <span class="keyword">Object</span>.<span class="keyword">create</span>(person);</span><br><span class="line">anotherPerson.name = "Greg";</span><br><span class="line">anotherPerson.friends.push("Rob");</span><br><span class="line">//var yetAnotherPerson = <span class="keyword">object</span>(person);</span><br><span class="line">var yetAnotherPerson = <span class="keyword">Object</span>.<span class="keyword">create</span>(person);</span><br><span class="line">yetAnotherPerson.name = "Linda";</span><br><span class="line">yetAnotherPerson.friends.push("Barbie");</span><br><span class="line">alert(person.friends); //"Shelby,Court,Van,Rob,Barbie"</span><br></pre></td></tr></table></figure><p>原型式继承,要求你必须有一个对象可以作为另一个对象的基础。通过object()函数返回的对象实际上是person的副本，它们共享这引用类型属性。</p><p>ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。这个方法接收两个参数:一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下,Object.create() 与 object() 方法的行为相同</p><p>Object.create() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同:每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p><p>在没有必要兴师动众地创建构造函数,而只想让一个对象与另一个对象保持类似的情况下,原型式继承是完全可以胜任的。不过别忘了,包含引用类型值的属性始终都会共享相应的值,就像使用原型模式一样。</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式(parasitic)继承是与原型式继承紧密相关的一种思路,并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真地是它做了所有工作一样返回对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">clone</span> = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;  <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">clone</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主要考虑对象而不是自定义类型和构造函数的情况下,寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object() 函数不是必需的;任何能够返回新对象的函数都适用于此模式。</p><p>使用寄生式继承来为对象添加函数,会由于不能做到函数复用而降低效率;这一点与构造函数模式类似。</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是 JavaScript 最常用的继承模式;不过,它也有自己的不足。组合继承最大的问题就是无论什么情况下,都会调用两次超类型构造函数:一次是在创建子类型原型的时候,另一次是在子类型构造函数内部。没错,子类型最终会包含超类型对象的全部实例属性,但我们不得不在调用子类型构造函数时重写这些属性。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(<span class="keyword">name</span>)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.colors = ["red", "blue", "green"];</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">SuperType</span>.<span class="title">prototype</span>.<span class="title">sayName</span> = <span class="title">function</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  alert(this.name);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(<span class="keyword">name</span>, age)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  SuperType.call(this, name); //第二次调用 SuperType()</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.age = age;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">SubType</span>.<span class="title">prototype</span> = <span class="title">new</span> <span class="title">SuperType</span><span class="params">()</span>;</span> <span class="comment">//第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype<span class="function">.<span class="keyword">constructor</span> = <span class="title">SubType</span>;</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  alert(this.age);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br></pre></td></tr></table></figure><p>在第一次调用 SuperType 构造函数时, SubType.prototype 会得到两个属性: name 和 colors ;它们都是 SuperType 的实例属性,只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时,又会调用一次 SuperType 构造函数,这一次又在新对象上创建了实例属性 name 和 colors 。</p><p>所谓寄生组合式继承,即通过借用构造函数来继承属性,通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数,我们所需要的无非就是超类型原型的一个副本而已。本质上,就是使用寄生式继承来继承超类型的原型,然后再将结果指定给子类型的原型。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">inherit</span><span class="constructor">Prototype(<span class="params">subType</span>, <span class="params">superType</span>)</span>&#123;</span><br><span class="line">  var prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部,第一步是创建超类型原型的一个副本。第二步是为创建的副本添加 constructor 属性,从而弥补因重写原型而失去的默认的 constructor 属性。最后一步,将新创建的对象(即副本)赋值给子类型的原型。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span></span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承</p><h3 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  constructor(name, age)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayAge()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">    <span class="keyword">super</span>.sayName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubType类通过extends关键字，继承了SuperType类的所有属性和方法，并且扩展了属性和方法。super关键字，它指代父类的实例（即父类的this对象）。</p><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp = <span class="keyword">new</span> <span class="type">SubType</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>对比前面的借用构造函数继承，实质是先创建子类的实例对象this，然后再将父类的属性添加到this上面（<code>Parent.apply(this)</code>）。ES6的继承机制则不同，实质是先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的属性修改this。</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(...args)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  super(...args);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  constructor(name, age)&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let st = <span class="keyword">new</span> <span class="keyword">SubType</span>(<span class="string">"Howie"</span>, <span class="number">26</span>);</span><br><span class="line">st instanceof <span class="keyword">SubType</span> <span class="type">// </span><span class="literal">true</span></span><br><span class="line">st instanceof SuperType // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例对象st同时是SubType和SuperType两个类的实例，这与ES5的行为完全一致。</p><h4 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和<code>__proto__</code>属性</h4><p>大部分浏览器实现中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ol><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li><li>子类prototype属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的prototype属性。</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span><span class="module"><span class="identifier">__proto__</span> </span><span class="operator">==</span></span>= SuperType <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype.__proto__<span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SuperType &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> SubType &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B的实例继承A的实例</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(SubType.<span class="params">prototype</span>, SuperType.<span class="params">prototype</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B继承A的静态属性</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(SubType, SuperType)</span>;</span><br><span class="line"><span class="comment">//而setPrototypeOf实现如下</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>setPrototypeOf = <span class="keyword">function</span> (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两条继承链，可以这样理解：作为一个对象，子类的原型（<code>__proto__</code>属性）是父类；作为一个构造函数，子类的原型（prototype属性）是父类的实例。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">SuperType()</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SubType</span>.</span></span>prototype.__proto__ = <span class="module-access"><span class="module"><span class="identifier">SuperType</span>.</span></span>prototype;</span><br></pre></td></tr></table></figure><h4 id="Extends-的继承目标"><a href="#Extends-的继承目标" class="headerlink" title="Extends 的继承目标"></a>Extends 的继承目标</h4><p>extends关键字后面可以跟多种类型的值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的SuperType，只要是一个有prototype属性的函数，就能被SubType继承。由于函数都有prototype属性，因此SuperType可以是任意函数。</p><p>下面，讨论三种特殊情况。</p><p>第一种特殊情况，子类继承Object类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span>.__proto__ === <span class="type">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">A</span>.prototype.__proto__ === <span class="type">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p><p>第二种特殊情况，不存在任何继承。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">A</span>.</span><span class="module"><span class="identifier">__proto__</span> </span><span class="operator">==</span></span>= <span class="module-access"><span class="module"><span class="identifier">Function</span>.</span></span>prototype <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>prototype.__proto__<span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Funciton.prototype</code>。但是，A调用后返回一个空对象（即Object实例），所以<code>A.prototype.__proto__</code>指向构造函数（Object）的prototype属性。</p><p>第三种特殊情况，子类继承null。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span>.__proto__ === <span class="type">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="type">A</span>.prototype.__proto__ === undefined <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承<code>Funciton.prototype</code>。但是，A调用后返回的对象不继承任何方法，所以它的<code>__proto__</code>指向<code>Function.prototype</code>，即实质上执行了下面的代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">  constructor() &#123; <span class="keyword">return</span> <span class="type">Object</span>.create(<span class="literal">null</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(SubType)</span><span class="operator"> === </span>SuperType <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>上面讲过，在子类中，super关键字代表父类实例。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._p * <span class="keyword">super</span>._p;</span><br><span class="line">  &#125;</span><br><span class="line">  set m() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>('该属性只读');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类通过super关键字，调用父类的实例。</p><p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  <span class="keyword">to</span><span class="constructor">String()</span> &#123;</span><br><span class="line">    return <span class="string">"MyObject: "</span> + super.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="keyword">to</span><span class="constructor">String()</span>; <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure><h4 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的__proto__属性"></a>实例的<code>__proto__</code>属性</h4><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="constructor">SuperType(<span class="string">"Howie"</span>)</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="constructor">SubType(<span class="string">"Howie"</span>, 26)</span>;</span><br><span class="line"></span><br><span class="line">s2.__proto__<span class="operator"> === </span>s1.__proto <span class="comment">// false</span></span><br><span class="line">s2.<span class="module-access"><span class="module"><span class="identifier">__proto__</span>.</span><span class="module"><span class="identifier">__proto__</span> </span><span class="operator">==</span></span>= s1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构，比如<code>Array()</code>。以前，这些原生构造函数是无法继承的，即不能自己定义一个Array的子类。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">MyArray()</span> &#123;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span>apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">MyArray</span>.</span></span>prototype = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span>prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="type">MyArray</span>();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">colors.length  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure><p>之所以会发生这种情况，是因为原生构造函数无法外部获取，通过<code>Array.apply()</code>或者分配给原型对象都不行。ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</p><p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p><p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionedArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.history = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  commit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.slice());</span><br><span class="line">  &#125;</span><br><span class="line">  revert() &#123;</span><br><span class="line">    <span class="keyword">this</span>.splice(<span class="number">0</span>, <span class="keyword">this</span>.length, <span class="keyword">this</span>.history[<span class="keyword">this</span>.history.length - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，VersionedArray结构会通过commit方法，将自己的上一个版本存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义Error子类的例子。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendableError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  constructor(message) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    <span class="keyword">this</span>.stack = (<span class="keyword">new</span> <span class="type">Error</span>()).stack;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">ExtendableError</span> </span>&#123;</span><br><span class="line">  constructor(m) &#123;</span><br><span class="line">    <span class="keyword">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myerror = <span class="keyword">new</span> <span class="type">MyError</span>(<span class="symbol">'l</span>l');</span><br><span class="line">myerror.message <span class="comment">// "ll"</span></span><br><span class="line">myerror instanceof <span class="type">Error</span> <span class="comment">// true</span></span><br><span class="line">myerror.name <span class="comment">// "MyError"</span></span><br><span class="line">myerror.stack</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//     at MyError.ExtendableError</span></span><br><span class="line"><span class="comment">//     ...</span></span><br></pre></td></tr></table></figure><h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>之前已经讲过函数声明和函数表达式区别了。</p><p>Firefox、Safari、Chrome 和 Opera 都给函数定义了一个非标准的 name 属性（ES6已经正式加入name属性）,通过这个属性可以访问到给函数指定的名字。这个属性的值永远等于跟在 function 关键字后面的标识符。</p><p>关于函数声明,它的一个重要特征就是函数声明提升(function declaration hoisting) ,意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="string">"Hi!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数表达式创建的函数叫做匿名函数(anonymous function),因为 function 关键字后面没有标识符。(匿名函数有时候也叫拉姆达函数)匿名函数的 name 属性是空字符串。</p><p>理解函数提升的关键,就是理解函数声明与函数表达式之间的区别。例如,执行以下代码的结果可能会让人意想不到。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要这样做!</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="string">"Hi!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="string">"Yo!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上,这在 ECMAScript 中属于无效语法,JavaScript 引擎会尝试修正错误,将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明,忽略condition ;Firefox 会在 condition 为 true 时返回第一个声明。因此这种使用方式很危险,不应该出现在你的代码中。不过,如果是使用函数表达式,那就没有什么问题了。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以这样做</span></span><br><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="string">"Hi!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="string">"Yo!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>之前说过可以递归时可以使用arguments.callee，但在严格模式下,不能通过脚本访问 arguments.callee ,访问这个属性会导致错误。不过,可以使用命名函数表达式来达成相同的结果。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">factorial</span> = (function f(<span class="built_in">num</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">num</span> &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">num</span> * f(<span class="built_in">num</span>-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码创建了一个名为 f() 的命名函数表达式,然后将它赋值给变量 factorial 。即便把函数赋值给了另一个变量,函数的名字 f 仍然有效,所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createComparisonFunction(propertyName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="keyword">object</span><span class="number">1</span>, <span class="keyword">object</span><span class="number">2</span>)&#123;</span><br><span class="line">        var <span class="keyword">value</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">1</span>[propertyName];</span><br><span class="line">        var <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">object</span><span class="number">2</span>[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使这个内部函数被返回了,而且是在其他地方被调用了,但它仍然可以访问外部函数的变量 propertyName。之所以还能够访问这个变量,是因为内部函数的作用域链中包含createComparisonFunction() 的作用域。</p><p>前面讲的有关如何创建作用域链以及作用域链有什么作用的细节,对彻底理解闭包至关重要。当某个函数被调用时,会创建一个执行环境(execution context)及相应的作用域链。然后,使用 arguments 和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中,外部函数的活动对象始终处于第二位,外部函数的外部函数的活动对象处于第三位,……直至作为作用域链终点的全局执行环境。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当调用 compare() 时,会创建一个包含 arguments 、 value1 和 value2 的活动对象。全局执行环境的变量对象(包含 result和 compare )在 compare() 执行环境的作用域链中则处于第二位。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+</span><br><span class="line">|<span class="string">     compare          </span>|</span><br><span class="line">|<span class="string">  execution context   </span>|<span class="string">&lt;-------------------------------------------------+</span></span><br><span class="line"><span class="string">+----------------------+    +------------+      +----------------------+  </span>|</span><br><span class="line">|<span class="string">(scope chain) </span>|<span class="string">      -</span>|<span class="string">---&gt;</span>|<span class="string">scope chain </span>|<span class="string">  +--&gt;</span>|<span class="string">global variable object</span>|<span class="string">  </span>|</span><br><span class="line">+----------------------+    +------------+  |<span class="string">   +----------------------+  </span>|</span><br><span class="line">                            |<span class="string">1     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   compare </span>|<span class="string">         -</span>|<span class="string">--+</span></span><br><span class="line"><span class="string">                            +------------+      +----------------------+</span></span><br><span class="line"><span class="string">                            </span>|<span class="string">0     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   result  </span>|<span class="string"> undefined</span>|</span><br><span class="line">                            +------------+  |<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">                                            </span>|</span><br><span class="line">                                            |<span class="string">   +----------------------+</span></span><br><span class="line"><span class="string">                                            +--&gt;</span>|<span class="string">    compare()         </span>|</span><br><span class="line">                                                |<span class="string">  activation object   </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string"> arguments </span>|<span class="string">  [5,10]  </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value1  </span>|<span class="string">  5       </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value2  </span>|<span class="string">  10      </span>|</span><br><span class="line">                                                +----------------------+</span><br></pre></td></tr></table></figure><p>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在,而像compare() 函数这样的局部环境的变量对象,则只在函数执行的过程中存在。在创建 compare() 函数时,会创建一个预先包含全局变量对象的作用域链,这个作用域链被保存在内部的 [[Scope]] 属性中。当调用 compare() 函数时,会为函数创建一个执行环境,然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。此后,又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中 compare() 函数的执行环境而言,其作用域链中包含两个变量对象:本地活动对象和全局变量对象。显然,作用域链本质上是一个指向变量对象的指针列表,它只引用但不实际包含变量对象。</p><p>无论什么时候在函数中访问一个变量时,就会从作用域链中搜索具有相应名字的变量。一般来讲,当函数执行完毕后,局部活动对象就会被销毁,内存中仅保存全局作用域(全局执行环境的变量对象)。但是,闭包的情况又有所不同。</p><p>在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中。因此,在 createComparisonFunction() 函数内部定义的匿名函数的作用域链中,实际上将会包含外部函数 createComparisonFunction() 的活动对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建函数</span></span><br><span class="line">var compareNames = create<span class="constructor">ComparisonFunction(<span class="string">"name"</span>)</span>;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">var result = compare<span class="constructor">Names(&#123; <span class="params">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="params">name</span>: <span class="string">"Greg"</span> &#125;)</span>;</span><br><span class="line"><span class="comment">//解除对匿名函数的引用(以便释放内存)</span></span><br><span class="line">compareNames = null;</span><br></pre></td></tr></table></figure><p>createComparisonFunction(“name”) 返回后其活动对象并没有被销毁，因为匿名函数（即被返回的比较函数）的作用域链中有对其的引用。通过将 compareNames 设置为等于 null解除该函数的引用,就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁,其他作用域(除了全局作用域)也都可以安全地销毁了。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+</span><br><span class="line">|<span class="string">  anonymous function  </span>|</span><br><span class="line">|<span class="string">  execution context   </span>|</span><br><span class="line">+----------------------+ +------------+</span><br><span class="line">|<span class="string">(scope chain) </span>|<span class="string">      -</span>|<span class="string">&gt;</span>|<span class="string"> scope chain</span>|</span><br><span class="line">+----------------------+ +------------+</span><br><span class="line">                         |<span class="string">2     </span>|<span class="string">    -</span>|<span class="string">--&gt;全局变量对象</span></span><br><span class="line"><span class="string">                         +------------+</span></span><br><span class="line"><span class="string">                         </span>|<span class="string">1     </span>|<span class="string">    -</span>|<span class="string">--&gt;createComparisonFunction()的活动对象</span></span><br><span class="line"><span class="string">                         +------------+</span></span><br><span class="line"><span class="string">                         </span>|<span class="string">0     </span>|<span class="string">    -</span>|<span class="string">--&gt;闭包的活动对象</span></span><br><span class="line"><span class="string">                         +------------+</span></span><br></pre></td></tr></table></figure><p>过度使用闭包可能会导致内存占用过多，只在绝对必要时使用闭包。</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用,即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象,而不是某个特殊的变量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span><span class="params">()</span>&#123;</span></span><br><span class="line">    var result = new Array();</span><br><span class="line">    <span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">10</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">        result[<span class="built_in">i</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组中每个函数都只会返回10，而不是0到9。i在createFunctions()的活动变量中，而每个匿名函数的作用域链第二个位置就是createFunctions()的活动变量，当createFunctions()返回后，i的值为10，此时每个函数都引用着保存变量 i 的同一个变量对象,所以在每个函数内部 i 的值都是 10。通过创建另一个匿名函数强制让闭包的行为符合预期</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span><span class="params">()</span>&#123;</span></span><br><span class="line">    var result = new Array();</span><br><span class="line">    <span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">10</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">        result[<span class="built_in">i</span>] = <span class="function"><span class="keyword">function</span><span class="params">(num)</span>&#123;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(<span class="built_in">i</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们没有直接把闭包赋值给数组,而是定义了一个匿名函数,并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数 num ,也就是最终的函数要返回的值。每个函数都有自己num变量的一个副本。</p><p>ECMASctipt6中你可以直接使用let声明i，这样i仅在for循环中有效，可以得到同样预期的结果。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span><span class="params">()</span>&#123;</span></span><br><span class="line">    var result = new Array();</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">10</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">        result[<span class="built_in">i</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h3><p>在闭包中使用 this 对象也可能会导致一些问题。我们知道, this 对象是在运行时基于函数的执行环境绑定的:在全局函数中, this 等于 window ,而当函数被作为某个对象的方法调用时, this 等于那个对象。不过,匿名函数的执行环境具有全局性,因此其 this 对象通常指向 window。当然,在通过 call() 或 apply() 改变函数执行环境的情况下, this 就会指向其他对象。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    key : <span class="string">"My Object"</span>,</span><br><span class="line">    getKeyFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getKeyFunc()()); <span class="comment">//"The Window"(在非严格模式下)</span></span><br></pre></td></tr></table></figure><p>为什么匿名函数没有取得其包含作用域(或外部作用域)的 this 对象呢? 前面曾经提到过,每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments 。内部函数在搜索这两个变量时,只会搜索到其活动对象为止,因此永远不可能直接访问外部函数中的这两个变量。不过,可以把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    key : <span class="string">"My Object"</span>,</span><br><span class="line">    getKeyFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.key;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getKeyFunc()()); <span class="comment">//"The Window"(在非严格模式下)</span></span><br></pre></td></tr></table></figure><p>arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象,必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> </span>= &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">object</span>.<span class="title">getName</span>(<span class="params"></span>)</span>; <span class="comment">//"My Object"</span></span><br><span class="line">(<span class="class"><span class="keyword">object</span>.<span class="title">getName</span>)(<span class="params"></span>)</span>; <span class="comment">//"My Object"</span></span><br><span class="line">(<span class="class"><span class="keyword">object</span>.<span class="title">getName</span> </span>= <span class="class"><span class="keyword">object</span>.<span class="title">getName</span>)(<span class="params"></span>)</span>; <span class="comment">//"The Window",在非严格模式下</span></span><br></pre></td></tr></table></figure><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>由于 IE9 之前的版本对 JScript 对象和 COM 对象使用引用计数器来回收垃圾。而闭包中存在对外部函数的活动对象的引用，有可能导致对象不能被正常回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于匿名函数保存了一个对 assignHandler() 的活动对象的引用,因此就会导致无法减少 element 的引用数。只要匿名函数存在, element 的引用数至少也是 1,因此它所占用的内存就永远不会被回收。不过,这个问题可以通过稍微改写一下代码来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;<span class="comment">//通过把 element.id 的一个副本保存在一个变量中,并且在闭包中引用该变量消除了循环引用</span></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element = <span class="literal">null</span>;<span class="comment">//解除对 DOM 对象的引用,顺利地减少其引用数,确保正常回收其占用的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>如前所述,JavaScript 没有块级作用域的概念。</p><p>用作块级作用域(通常称为私有作用域)的匿名函数的语法如下所示。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span>()&#123;</span><br><span class="line">//这里是块级作用域</span><br><span class="line">&#125;)()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中,表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;(); <span class="comment">//出错!</span></span><br></pre></td></tr></table></figure><p>这段代码会导致语法错误,是因为 JavaScript 将 function 关键字当作一个函数声明的开始,而函数声明后面不能跟圆括号。然而,函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式,只要给它加上一对圆括号即可。在下面的情况下可以不加圆括号。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span>&#123;<span class="keyword">return</span> i;&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这种技术经常在全局作用域中被用在函数外部,从而限制向全局作用域中添加过多的变量和函数。一般来说,我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中,过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域,每个开发人员既可以使用自己的变量,又不必担心搞乱全局作用域。</p><p>这种做法可以减少闭包占用的内存问题,因为没有指向匿名函数的引用。只要函数执行完毕,就可以立即销毁其作用域链了。</p><p>ECMASctipt6中支持块级作用域，所以ES6中可以不再使用上面的执行匿名函数（IIFE）。</p><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来讲,JavaScript 中没有私有成员的概念;所有对象属性都是公有的。不过,倒是有一个私有变量的概念。任何在函数中定义的变量,都可以认为是私有变量,因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p><p>我们把有权访问私有变量和私有函数的公有方法称为特权方法(privileged method)。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 MyObject 的实例后,除了使用 publicMethod() 这一个途径外,没有任何办法可以直接访问 privateVariable 和 privateFunction() 。</p><p>在构造函数中定义特权方法也有一个缺点,那就是你必须使用构造函数模式来达到这个目的。</p><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><p>通过在私有作用域中定义私有变量或函数,同样也可以创建特权方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>注意,这个模式在定义构造函数时并没有使用函数声明,而是使用了函数表达式。函数声明只能创建局部函数,但那并不是我们想要的。出于同样的原因,我们也没有在声明 MyObject 时使用 var 关键字。但也要知道,在严格模式下给未经声明的变量赋值会导致错误。</p><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式(module pattern)则是为单例创建私有变量和特权方法。所谓单例(singleton),指的就是只有一个实例的对象。按照惯例,JavaScript 是以对象字面量的方式来创建单例对象的。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    name : value,</span><br><span class="line">    method : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里是方法的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>有人进一步改进了模块模式,即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例,同时还必须添加某些属性和(或)方法对其加以增强的情况。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1><p>异步编程对JavaScript语言很重要。JavaScript只有一个线程，如果没有异步编程，根本没法用，非卡死不可。</p><p>ES6诞生以前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise 对象</li></ul><p>ES6将JavaScript异步编程带入了一个全新的阶段。</p><h2 id="异步基本概念"><a href="#异步基本概念" class="headerlink" title="异步基本概念"></a>异步基本概念</h2><p>所谓”异步”，简单说就好比把一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是”重新调用”。</p><p>读取文件进行处理，是这样写的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.read<span class="constructor">File(<span class="params">fileA</span>, <span class="params">function</span> (<span class="params">err</span>, <span class="params">data</span>)</span> &#123;</span><br><span class="line">  fs.read<span class="constructor">File(<span class="params">fileB</span>, <span class="params">function</span> (<span class="params">err</span>, <span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为“回调函数噩梦”（callback hell）。</p><p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程的运行流程大致如下。</p><ul><li>协程A开始执行。</li><li>协程A执行到一半，进入暂停，执行权转移到协程B。</li><li>（一段时间后）协程B交还执行权。</li><li>协程A恢复执行。</li></ul><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p><p>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p><h3 id="Generator函数的概念"><a href="#Generator函数的概念" class="headerlink" title="Generator函数的概念"></a>Generator函数的概念</h3><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function*</span> <span class="string">gen(x)&#123;</span></span><br><span class="line">  <span class="string">var</span> <span class="string">y</span> <span class="string">=</span> <span class="string">yield</span> <span class="string">x</span> <span class="string">+</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">y;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">g</span> <span class="string">=</span> <span class="string">gen(1);</span></span><br><span class="line"><span class="string">g.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">g.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="string">undefined,</span> <span class="attr">done:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Generator函数和普通函数最大不同就是会返回一个Iterator对象，调用该对象的next方法，会分阶段执行Generator函数，这种阶段由yield关键字划分。上例第一个next就是执行到第一个yield出现的位置。next 方法返回IteratorResult对象，含有value和done两个属性。前者是yield语句后面的值，后者表示Generator函数是否执行完毕。</p><h3 id="Generator函数的数据交换和错误处理"><a href="#Generator函数的数据交换和错误处理" class="headerlink" title="Generator函数的数据交换和错误处理"></a>Generator函数的数据交换和错误处理</h3><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function*</span> <span class="string">gen(x)&#123;</span></span><br><span class="line">  <span class="string">var</span> <span class="string">y</span> <span class="string">=</span> <span class="string">yield</span> <span class="string">x</span> <span class="string">+</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">y;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">g</span> <span class="string">=</span> <span class="string">gen(1);</span></span><br><span class="line"><span class="string">g.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">g.next(2)</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个next方法的value属性，返回表达式<code>x + 2</code>的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(<span class="built_in">url</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p><p>执行这段代码的方法如下。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line"></span><br><span class="line">result.<span class="keyword">value</span>.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">data</span>.json();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  g.next(<span class="keyword">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，首先执行Generator函数，获取Iterator对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h3 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h3><h4 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h4><p>Thunk函数早在上个世纪60年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面代码先定义函数f，然后向它传入表达式<code>x + 5</code>。这个表达式应该何时求值？</p><p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p><p>另一种意见是”传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Hskell语言采用这种策略。</p><p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><h4 id="Thunk函数的含义"><a href="#Thunk函数的含义" class="headerlink" title="Thunk函数的含义"></a>Thunk函数的含义</h4><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">f</span>(m)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">m</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var thunk = <span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">x</span> + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">f</span>(thunk)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">thunk()</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数f的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p><p>这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p><h4 id="JavaScript语言的Thunk函数"><a href="#JavaScript语言的Thunk函数" class="headerlink" title="JavaScript语言的Thunk函数"></a>JavaScript语言的Thunk函数</h4><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.read<span class="constructor">File(<span class="params">fileName</span>, <span class="params">callback</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line">var readFileThunk = <span class="constructor">Thunk(<span class="params">fileName</span>)</span>;</span><br><span class="line">read<span class="constructor">FileThunk(<span class="params">callback</span>)</span>;</span><br><span class="line"></span><br><span class="line">var Thunk = <span class="keyword">function</span> (fileName)&#123;</span><br><span class="line">  return <span class="keyword">function</span> (callback)&#123;</span><br><span class="line">    return fs.read<span class="constructor">File(<span class="params">fileName</span>, <span class="params">callback</span>)</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p><p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      args.push(callback);</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用上面的转换器，生成<code>fs.readFile</code>的Thunk函数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var readFileThunk = Thunk(<span class="name">fs</span>.readFile)<span class="comment">;</span></span><br><span class="line">readFileThunk(<span class="name">fileA</span>)(<span class="name">callback</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h4><p>生产环境的转换器，建议使用Thunkify模块。</p><p>安装。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> thunkify</span><br></pre></td></tr></table></figure><p>使用方式。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="keyword">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">read</span> = thunkify(fs.readFile);</span><br><span class="line"><span class="keyword">read</span>(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span><span class="params">(err, str)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  // ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br></pre></td></tr></table></figure><p>Thunkify的源码与前面那个简单的转换器非常像。主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b, callback)&#123;</span><br><span class="line">  <span class="built_in">var</span> <span class="keyword">sum</span> = a + b;</span><br><span class="line">  callback(<span class="keyword">sum</span>);</span><br><span class="line">  callback(<span class="keyword">sum</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="literal">ft</span> = thunkify(f);</span><br><span class="line"><span class="literal">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(console.<span class="keyword">log</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>由于thunkify只允许回调函数执行一次，所以只输出一行结果。</p><h4 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h4><p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p><p>以读取文件为例。下面的Generator函数封装了两个异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p><p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span><span class="params">(err, data)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">  r2.value(<span class="function"><span class="keyword">function</span><span class="params">(err, data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p><h4 id="Thunk函数的自动流程管理"><a href="#Thunk函数的自动流程管理" class="headerlink" title="Thunk函数的自动流程管理"></a>Thunk函数的自动流程管理</h4><p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(fn)</span></span> &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err, data)</span></span> &#123;</span><br><span class="line">    var result = gen.<span class="built_in">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">    result.value(<span class="built_in">next</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。前面的gen函数可以有更多读取文件操作，只要执行run函数，这些操作就会自动完成。</p><p>有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。</p><p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p><h3 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><a href="https://github.com/tj/co" target="_blank" rel="noopener">co模块</a>是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p><p>co模块可以让你不用编写Generator函数的执行器。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var co = require('co')<span class="comment">;</span></span><br><span class="line">co(<span class="name">gen</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面代码中，gen函数是前面定义的，Generator函数只要传入co函数，就会自动执行。</p><p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p><h4 id="co模块的原理"><a href="#co模块的原理" class="headerlink" title="co模块的原理"></a>co模块的原理</h4><p>为什么co可以自动执行Generator函数？</p><p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><ol><li>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</li><li>Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</li></ol><p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p><p>已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p><h4 id="基于Promise对象的自动执行"><a href="#基于Promise对象的自动执行" class="headerlink" title="基于Promise对象的自动执行"></a>基于Promise对象的自动执行</h4><p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的Generator函数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next().<span class="keyword">value</span>.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  g.next(<span class="keyword">data</span>).<span class="keyword">value</span>.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">    g.next(<span class="keyword">data</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> run(gen)&#123;</span><br><span class="line">  var g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span></span> next(<span class="keyword">data</span>)&#123;</span><br><span class="line">    var result = g.next(<span class="keyword">data</span>);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.<span class="keyword">value</span>;</span><br><span class="line">    result.<span class="keyword">value</span>.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">      next(<span class="keyword">data</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p><p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。增加了一些类型检查的操作。</p><h4 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h4><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line">  <span class="keyword">yield</span> values.map(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">somethingAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something async</span></span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>async 函数是什么？一句话，async函数就是Generator函数的语法糖。</p><p>前文有一个Generator函数，依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写成 async 函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p><p>async 函数对 Generator 函数的改进，体现在以下三点。</p><ol><li>内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async 函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 <code>var result = asyncReadFile();</code></li><li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li></ol><h3 id="async函数的实现"><a href="#async函数的实现" class="headerlink" title="async函数的实现"></a>async函数的实现</h3><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p><p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p><h3 id="async-函数的用法"><a href="#async-函数的用法" class="headerlink" title="async 函数的用法"></a>async 函数的用法</h3><p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p><p>下面的例子，指定多少毫秒后输出一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p><h3 id="与Promise、Generator的比较"><a href="#与Promise、Generator的比较" class="headerlink" title="与Promise、Generator的比较"></a>与Promise、Generator的比较</h3><p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p><p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是Promise的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空的Promise</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用then方法，添加所有动画</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">in</span> animations) &#123;</span><br><span class="line">    p = p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="keyword">return</span> anim(elem);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class="line">  <span class="keyword">return</span> p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p><p>接着是Generator函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> anim(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p><p>最后是Async函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>]]></content>
    
    <summary type="html">
    
      JavaScript 面向对象程序设计、函数表达式和异步编程，创建对象，继承，递归，闭包，块级作用域，私有变量，回调函数，Promise，Generator函数，async函数
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 引用类型</title>
    <link href="http://howiefh.github.io/2015/08/28/javascript-reference-type/"/>
    <id>http://howiefh.github.io/2015/08/28/javascript-reference-type/</id>
    <published>2015-08-28T04:18:03.000Z</published>
    <updated>2020-05-02T14:28:14.485Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="/2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="/2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记是对《JavaScript 高级程序设计》和 <a href="https://github.com/ruanyf/es6tutorial/tree/5a5f9d8d492d0f925cbb6e09b10ebed9d2078d40" target="_blank" rel="noopener">《ECMAScript 6入门》</a>两本书的总结整理。</p><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><a id="more"></a><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>创建Object实例有两种方式，第一种是使用new操作符后跟Object构造函数，如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object()<span class="comment">;</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span><span class="comment">;</span></span><br><span class="line">person.age = <span class="number">29</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p><p>另一种方式是使用对象字面量表示法。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var person</span> = &#123;</span><br><span class="line">  name : <span class="string">'Nicholas'</span>,</span><br><span class="line">  age : 9</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误。 在使用对象字面量语法时，属性名也可以使用字符串</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">'name'</span> : <span class="string">'Nicholas'</span>,</span><br><span class="line">  <span class="string">'age'</span> : <span class="number">9</span>,</span><br><span class="line">  <span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里5会被转换为字符串。</p><p>使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;<span class="comment">; //与 new Object()相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span><span class="comment">;</span></span><br><span class="line">person.age = <span class="number">29</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p><p>在通过对象字面量定义对象时，实际上不会调用Object构造函数</p><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  v,</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值，将会非常方便。</p><p>在 JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。方括号语法的主要优点是可以通过变量来访问属性，例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var propertyName = <span class="string">"name"</span><span class="comment">;</span></span><br><span class="line">alert(person[propertyName])<span class="comment">; //"Nicholas"</span></span><br></pre></td></tr></table></figure><p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例如： <code>person[&quot;first name&quot;] = &quot;Nicholas&quot;;</code></p><p>除非必须使用方括号，否则建议使用点表示法。</p><p>ES6允许字面量定义对象时，把表达式放在方括号内作为属性名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastWord = <span class="string">'last word'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</span><br><span class="line">  [lastWord]: <span class="string">'world'</span>,</span><br><span class="line">  [<span class="string">'h'</span>+<span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">'first word'</span>] <span class="comment">// "hello"</span></span><br><span class="line">a[lastWord] <span class="comment">// "world"</span></span><br><span class="line">a[<span class="string">'last word'</span>] <span class="comment">// "world"</span></span><br><span class="line">a.hello(); <span class="comment">//hi</span></span><br></pre></td></tr></table></figure><p>函数的name属性，返回函数名。ES6为对象方法也添加了name属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> firstName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName.name   <span class="comment">// "sayName"</span></span><br><span class="line">person.firstName.name <span class="comment">// "get firstName"</span></span><br></pre></td></tr></table></figure><p>上面代码中，方法的name属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。</p><p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(new <span class="function"><span class="keyword">Function</span><span class="params">()</span></span>).<span class="keyword">name</span> // <span class="string">"anonymous"</span></span><br><span class="line">var doSomething = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">doSomething.<span class="keyword">bind</span>().<span class="keyword">name</span> // <span class="string">"bound doSomething"</span></span><br></pre></td></tr></table></figure><p><strong>Object.is()</strong>用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> //<span class="keyword">true</span></span><br><span class="line"><span class="keyword">NaN</span> === <span class="keyword">NaN</span> // <span class="keyword">false</span></span><br><span class="line"><span class="keyword">Object</span>.<span class="keyword">is</span>(+<span class="number">0</span>, <span class="number">-0</span>) // <span class="keyword">false</span></span><br><span class="line"><span class="keyword">Object</span>.<span class="keyword">is</span>(<span class="keyword">NaN</span>, <span class="keyword">NaN</span>) // <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>Object.assign方法</strong>用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="comment">&#123; a: 1 &#125;</span>;</span><br><span class="line"><span class="keyword">var</span> source1 = <span class="comment">&#123; b: 2 &#125;</span>;</span><br><span class="line"><span class="keyword">var</span> source2 = <span class="comment">&#123; c: 3 &#125;</span>;</span><br><span class="line"><span class="keyword">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><p>assign方法有很多用处。</p><p><strong>1）为对象添加属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）为对象添加方法</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>assign(<span class="module-access"><span class="module"><span class="identifier">SomeClass</span>.</span></span>prototype, &#123;</span><br><span class="line">  some<span class="constructor">Method(<span class="params">arg1</span>, <span class="params">arg2</span>)</span> &#123; ··· &#125;,</span><br><span class="line">  another<span class="constructor">Method()</span> &#123; ··· &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3）克隆对象</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">clone</span>(origin) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Object.assign(&#123;&#125;,</span> origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> clone(origin) &#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">origin</span>)</span>;</span><br><span class="line">  return <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>assign(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）合并多个对象</strong></p><p>将多个对象合并到某个对象。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">merge</span> =</span><br><span class="line">  (<span class="keyword">target</span>, ...sources) =&gt; Object.<span class="keyword">assign</span>(<span class="keyword">target</span>, ...sources);</span><br></pre></td></tr></table></figure><p><strong>5）为属性指定默认值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//用户自定义参数options和默认配置会合并</span></span><br><span class="line">  <span class="keyword">let</span> options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__proto__属性</code> ，用来读取或设置当前对象的prototype对象。该属性一度被正式写入ES6草案，但后来又被移除。目前，所有浏览器（包括IE11）都部署了这个属性。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  __proto__: someOtherObj,</span></span><br><span class="line"><span class="comment">  method: function() &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = Object.create(someOtherObj);</span><br><span class="line">obj<span class="function">.<span class="keyword">method</span> = <span class="title">function</span><span class="params">()</span> <span class="comment">&#123; ... &#125;</span></span></span><br></pre></td></tr></table></figure><p><strong>Object.setPrototypeOf()</strong>方法的作用与<code>__proto__</code>相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(<span class="params">object</span>, <span class="params">prototype</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">var o = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(&#123;&#125;, <span class="params">null</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>Object.getPrototypeOf()</strong>方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">obj</span>)</span>;</span><br></pre></td></tr></table></figure><p>注意，Object.observe和Object.unobserve这两个方法不属于ES6，而是属于ES7的一部分。不过，Chrome浏览器从33版起就已经支持。</p><p><strong>Object.observe</strong>方法用来监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">user</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">Object</span>.observe(<span class="keyword">user</span>, <span class="keyword">function</span>(changes)&#123;</span><br><span class="line">  changes.<span class="keyword">forEach</span>(<span class="keyword">function</span>(change) &#123;</span><br><span class="line">    <span class="keyword">user</span>.fullName = <span class="keyword">user</span>.firstName+" "+<span class="keyword">user</span>.lastName;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span>.firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">user</span>.lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">user</span>.fullName // <span class="string">'Michael Jackson'</span></span><br></pre></td></tr></table></figure><p>上面代码中，Object.observer方法监听user对象。一旦该对象发生变化，就自动生成fullName属性。</p><p>一般情况下，Object.observe方法接受两个参数，第一个参数是监听的对象，第二个函数是一个回调函数。一旦监听对象发生变化（比如新增或删除一个属性），就会触发这个回调函数。很明显，利用这个方法可以做很多事情，比如自动更新DOM。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">"#foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.observe(user, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullName = user.firstName+<span class="string">" "</span>+user.lastName;</span><br><span class="line">    div.text(fullName);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，只要user对象发生变化，就会自动更新DOM。如果配合jQuery的change方法，就可以实现数据对象与DOM对象的双向自动绑定。</p><p>回调函数的changes参数是一个数组，代表对象发生的变化。下面是一个更完整的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发生变动的属性：'</span> + change.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变动前的值：'</span> + change.oldValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变动后的值：'</span> + change.object[change.name]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变动类型：'</span> + change.type);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.observe(o, observer);</span><br></pre></td></tr></table></figure><p>参照上面代码，Object.observe方法指定的回调函数，接受一个数组（changes）作为参数。该数组的成员与对象的变化一一对应，也就是说，对象发生多少个变化，该数组就有多少个成员。每个成员是一个对象（change），它的name属性表示发生变化源对象的属性名，oldValue属性表示发生变化前的值，object属性指向变动后的源对象，type属性表示变化的种类。基本上，change对象是下面的样子。</p><p>Object.observe方法目前共支持监听六种变化。</p><ul><li>add：添加属性</li><li>update：属性值的变化</li><li>delete：删除属性</li><li>setPrototype：设置原型</li><li>reconfigure：属性的attributes对象发生变化</li><li>preventExtensions：对象被禁止扩展（当一个对象变得不可扩展时，也就不必再监听了）</li></ul><p>Object.observe方法还可以接受第三个参数，用来指定监听的事件种类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.observe</span>(<span class="selector-tag">o</span>, <span class="selector-tag">observer</span>, <span class="selector-attr">[<span class="string">'delete'</span>]</span>);</span><br></pre></td></tr></table></figure><p>上面的代码表示，只在发生delete事件时，才会调用回调函数。</p><p><strong>Object.unobserve</strong>方法用来取消监听。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>unobserve(o, observer);</span><br></pre></td></tr></table></figure><p>目前，ES7有一个<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">提案</a>，将rest参数/扩展运算符（…）引入对象。Babel转码器已经支持这项功能。</p><p><strong>1）Rest参数</strong></p><p>Rest参数用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">&#123;</span> <span class="string">x,</span> <span class="string">y,</span> <span class="string">...z</span> <span class="string">&#125;</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="attr">x:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">y:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">a:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">b:</span> <span class="number">4</span> <span class="string">&#125;;</span></span><br><span class="line"><span class="string">x</span> <span class="string">//</span> <span class="number">1</span></span><br><span class="line"><span class="string">y</span> <span class="string">//</span> <span class="number">2</span></span><br><span class="line"><span class="string">z</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">a:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">b:</span> <span class="number">4</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量z是Rest参数所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们和它们的值拷贝过来。</p><p>注意，Rest参数的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest参数拷贝的是这个值的引用，而不是这个值的副本。</p><p>另外，Rest参数不会拷贝继承自原型对象的属性。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="meta">o1</span> = &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">let <span class="meta">o2</span> = &#123; b: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="meta">o2</span>.__proto__ = <span class="meta">o1</span>;</span><br><span class="line">let <span class="meta">o3</span> = &#123; ...<span class="meta">o2</span> &#125;;</span><br><span class="line"><span class="meta">o3</span> <span class="comment">// &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象o3是o2的复制，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p><p><strong>2）扩展运算符</strong></p><p>扩展运算符用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">z</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="attr">a:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">b:</span> <span class="number">4</span> <span class="string">&#125;;</span></span><br><span class="line"><span class="string">let</span> <span class="string">n</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="string">...z</span> <span class="string">&#125;;</span></span><br><span class="line"><span class="string">n</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">a:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">b:</span> <span class="number">4</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这等同于使用<code>Object.assign</code>方法。</p><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为x属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  <span class="keyword">get</span> x() &#123;</span><br><span class="line">    throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not thrown yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为x属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    <span class="keyword">get</span> x() &#123;</span><br><span class="line">      throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'thrown now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyObject = &#123; <span class="params">...</span><span class="built_in">null</span>, <span class="params">...</span>undefined &#125;; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>ECMAScript 数组的每一项可以保存任何类型的数据</p><p>创建数组的基本方式有两种。第一种是使用 Array 构造函数。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="type">Array</span>();</span><br></pre></td></tr></table></figure><p>如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值。例如，下面的代码将创建length值为20的数组。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="type">Array</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>也可以向Array构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="type">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure><p>当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。下面就两个例子：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="type">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="type">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure><p>另外,在使用 Array 构造函数时也可以省略 new 操作符。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure><p>创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含3 个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！这样会创建一个包含2 或3 项的数组，对于IE早期版本(&lt;=8)这里将会是三项，最后一项是undefined，下面同理</span></span><br><span class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含5 或6 项的数组</span></span><br></pre></td></tr></table></figure><p>ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p><p>与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数</p><p>数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。请看下面的例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>当把一个值放在超出当前数组大小的位置上时,数组就会重新计算其长度值,即长度值<br>等于最后一项的索引加 1:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>;</span><br><span class="line">alert(colors.length); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>位置3到位置98实际上都是不存在的，所以访问它们都将返回undefined。</p><p>数组最多可以包含4 294 967 295个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>instanceof 操作符的问题在于,它假定只有一个全局执行环境。如果网页中包含多个框架,那实际上就存在两个以上不同的全局执行环境,从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组,那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p><p>ECMAScript 5新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的</p><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。toLocaleString()与toString()有些类似，只不过是调用每项的toLocaleString()。而调用 valueOf()返回的还是数组。</p><p>如果使用 join() 方法,则可以使用不同的分隔符来构建这个字符串。 join() 方法只接收一个参数,即用作分隔符的字符串,然后返回包含所有数组项的字符串。如果不给 join() 方法传入任何值,或者给它传入 undefined ,则使用逗号作为分隔符。IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">alert(colors.<span class="keyword">join</span>()); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors.<span class="keyword">join</span>(<span class="string">"||"</span>)); <span class="comment">//red||green||blue</span></span><br></pre></td></tr></table></figure><p>如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、toLocaleString()、toString() 和 valueOf() 方法返回的结果中以空字符串表示。</p><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。这两个方法会改变length的值</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var colors = <span class="keyword">new</span> Array();<span class="comment">// 创建一个数组</span></span><br><span class="line">var <span class="keyword">count</span> = colors.<span class="keyword">push</span>(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(<span class="keyword">count</span>); <span class="comment">//2</span></span><br><span class="line">var item = colors.<span class="keyword">pop</span>();<span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br><span class="line">alert(colors.length); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>shift() 能够移除数组中的第一个项并返回该项,同时将数组长度减 1。结合使用 shift() 和 push() 方法,可以像使用队列一样使用数组。</p><p>unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort()</p><p>sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串</p><p>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">compare</span>(value1, value2) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="built_in">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">values</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="built_in">values</span>.<span class="built_in">sort</span>(<span class="built_in">compare</span>);</span><br><span class="line">alert(<span class="built_in">values</span>); //<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span></span><br><span class="line"><span class="built_in">values</span>.<span class="built_in">sort</span>();</span><br><span class="line">alert(<span class="built_in">values</span>); //<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>对于数值类型或者其 valueOf() 方法会返回数值类型的对象类型,可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。正数减负数可能溢出</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span><span class="number">2</span> - <span class="keyword">value</span><span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p><p>slice()能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下, slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数,该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意, slice() 方法不会影响原始数组。注意, slice() 方法不会影响原始数组。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line">var colors<span class="number">2</span> = colors.slice<span class="comment">(1)</span>;</span><br><span class="line">var colors<span class="number">3</span> = colors.slice<span class="comment">(1,4)</span>;</span><br><span class="line">alert<span class="comment">(colors2)</span>; <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">alert<span class="comment">(colors3)</span>; <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure><p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p><p>splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。</p><ul><li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。</li><li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串”red”和”green”。</li><li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red”和”green”。</li></ul><p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。</p><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p><p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。</p><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。</p><ul><li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回 true。</li><li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li><li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li><li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li><li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li></ul><p>以上方法都不会修改数组中的包含的值。</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ECMAScript 5还新增了两个归并数组的方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p><p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, <span class="built_in">array</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br><span class="line">var values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>第一次执行回调函数, prev 是 1, cur 是 2。第二次, prev 是 3(1 加 2 的结果), cur 是 3(数组的第三项)。这个过程会持续到把数组中的每一项都访问一遍,最后返回结果。</p><h3 id="ES6-新增方法"><a href="#ES6-新增方法" class="headerlink" title="ES6 新增方法"></a>ES6 新增方法</h3><ul><li><p>Array.from()<br>  用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</p><p>  Array.from方法可以将函数的arguments对象，转为数组。</p><p>  任何有length属性的对象，都可以通过Array.from方法转为数组。</p><p>  Array.from()还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。<code>Array.from(arrayLike, x =&gt; x * x);</code>等同于<code>Array.from(arrayLike).map(x =&gt; x * x);</code></p><p>  Array.from()的一个应用是，将字符串转为数组，然后返回字符串的长度。这样可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。</p></li><li><p>Array.of()<br>  用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。<code>Array(3) // [undefined, undefined, undefined]</code></p></li><li><p>数组实例的find()和findIndex()<br>  数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<code>var found = [1, 4, -5, 10].find((n) =&gt; n &lt; 0);</code></p><p>  find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>  数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><p>  这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p></li><li><p>数组实例的fill()<br>  使用给定值，填充一个数组。fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p></li><li><p>数组实例的entries()，keys()和values()<br>  ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个既实现了Iterable又实现了Iterator接口的对象，且该对象<code>Symbol.iterator</code>方法返回其自身，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>  <figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="keyword">let</span> [<span class="keyword">index</span>, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  console.log(<span class="keyword">index</span>, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ES7-将加入的方法"><a href="#ES7-将加入的方法" class="headerlink" title="ES7 将加入的方法"></a>ES7 将加入的方法</h3><ul><li><p>数组实例的includes()<br>  返回一个布尔值，表示某个数组是否包含给定的值。该方法属于ES7。该方法的第二个参数表示搜索的起始位置，默认为0。</p></li><li><p>Array.observe()，Array.unobserve()<br>  这两个方法用于监听（取消监听）数组的变化，指定回调函数。</p><p>  它们的用法与Object.observe和Object.unobserve方法完全一致，也属于ES7的一部分，唯一的区别是，对象可监听的变化一共有六种，而数组只有四种：add、update、delete、splice（数组的length属性发生变化）</p></li></ul><p>此外ES7将加入数组推导（array comprehension），以提供简洁写法，允许直接通过现有数组生成新数组。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">a1</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">];</span></span><br><span class="line"><span class="string">var</span> <span class="string">a2</span> <span class="string">=</span> <span class="string">[for</span> <span class="string">(i</span> <span class="string">of</span> <span class="string">a1)</span> <span class="string">i</span> <span class="string">*</span> <span class="number">2</span><span class="string">];</span></span><br><span class="line"><span class="string">a2</span> <span class="string">//</span> <span class="string">[2,</span> <span class="number">4</span><span class="string">,</span> <span class="number">6</span><span class="string">,</span> <span class="number">8</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>上面代码表示，通过for…of结构，数组a2直接在a1的基础上生成。</p><p>注意，数组推导中，for…of结构总是写在最前面，返回的表达式写在最后面。</p><p>for…of后面还可以附加if语句，用来设定循环的限制条件。</p><p>需要注意的是，数组推导的方括号构成了一个单独的作用域，在这个方括号中声明的变量类似于使用let语句声明的变量。</p><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。</p><p>在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象,必须传入表示该日期的毫秒数(即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数)。为了简化这一计算过程,ECMAScript 提供了两个方法: Date.parse()和 Date.UTC() 。</p><p>Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。</p><p>如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()</p><p>Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于 0的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1到 31）、小时数（0到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p><p>Date 构造函数会模仿 Date.parse()和 Date.UTC()，但模仿后者有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date 构造函数接收的参数仍然与Date.UTC()相同。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y2k1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">var</span> y2k2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> someDate1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);</span><br></pre></td></tr></table></figure><p>ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Data对象分析代码的工作。</p><p>使用+操作符把Data对象转换成数值，也可以达到同样的目的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//取得开始时间 和<span class="type">Date</span>.now()等效</span><br><span class="line">var start = +<span class="built_in">new</span> <span class="type">Date</span>();</span><br></pre></td></tr></table></figure><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。</p><p>至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。</p><h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。</p><ul><li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li><li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li><li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li><li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li><li>toUTCString()——以特定于实现的格式完整的UTC日期。</li></ul><p>与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p><p>除了前面介绍的方法之外,还有一个名叫 toGMTString() 的方法,这是一个与toUTCString() 等价的方法,其存在目的在于确保向后兼容。不过,ECMAScript 推荐现在编写的代码一律使用 toUTCString() 方法。</p><h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>剩下还未介绍的Date类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC日期指的是在没有时区偏差的情况下（将日期转换为GMT时间）的日期值。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getTime()</td><td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td></tr><tr><td>setTime( 毫秒 )</td><td>以毫秒数设置日期,会改变整个日期</td></tr><tr><td>getFullYear()</td><td>取得4位数的年份(如2007而非仅07)</td></tr><tr><td>getUTCFullYear()</td><td>返回UTC日期的4位数年份</td></tr><tr><td>setFullYear( 年 )</td><td>设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td></tr><tr><td>setUTCFullYear( 年 )</td><td>设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td></tr><tr><td>getMonth()</td><td>返回日期中的月份,其中0表示一月,11表示十二月</td></tr><tr><td>getUTCMonth()</td><td>返回UTC日期中的月份,其中0表示一月,11表示十二月</td></tr><tr><td>setMonth( 月 )</td><td>设置日期的月份。传入的月份值必须大于0,超过11则增加年份</td></tr><tr><td>setUTCMonth( 月 )</td><td>设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份</td></tr><tr><td>getDate()</td><td>返回日期月份中的天数(1到31)</td></tr><tr><td>getUTCDate()</td><td>返回UTC日期月份中的天数(1到31)</td></tr><tr><td>setDate( 日 )</td><td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td></tr><tr><td>setUTCDate( 日 )</td><td>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td></tr><tr><td>getDay()</td><td>返回日期中星期的星期几(其中0表示星期日,6表示星期六)</td></tr><tr><td>getUTCDay()</td><td>返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)</td></tr><tr><td>getHours()</td><td>返回日期中的小时数(0到23)</td></tr><tr><td>getUTCHours()</td><td>返回UTC日期中的小时数(0到23)</td></tr><tr><td>setHours( 时 )</td><td>设置日期中的小时数。传入的值超过了23则增加月份中的天数</td></tr><tr><td>setUTCHours( 时 )</td><td>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</td></tr><tr><td>getMinutes()</td><td>返回日期中的分钟数(0到59)</td></tr><tr><td>getUTCMinutes()</td><td>返回UTC日期中的分钟数(0到59)</td></tr><tr><td>setMinutes( 分 )</td><td>设置日期中的分钟数。传入的值超过59则增加小时数</td></tr><tr><td>setUTCMinutes( 分 )</td><td>设置UTC日期中的分钟数。传入的值超过59则增加小时数</td></tr><tr><td>getSeconds()</td><td>返回日期中的秒数(0到59)</td></tr><tr><td>getUTCSeconds()</td><td>返回UTC日期中的秒数(0到59)</td></tr><tr><td>setSeconds( 秒 )</td><td>设置日期中的秒数。传入的值超过了59会增加分钟数</td></tr><tr><td>setUTCSeconds( 秒 )</td><td>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</td></tr><tr><td>getMilliseconds()</td><td>返回日期中的毫秒数</td></tr><tr><td>getUTCMilliseconds()</td><td>返回UTC日期中的毫秒数</td></tr><tr><td>setMilliseconds( 毫秒 )</td><td>设置日期中的毫秒数</td></tr><tr><td>setUTCMilliseconds( 毫秒 )</td><td>设置UTC日期中的毫秒数</td></tr><tr><td>getTimezoneOffset()</td><td>返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化</td></tr></tbody></table><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><p>使用下面类似 Perl 的语法,就可以创建一个正则表达式。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure><p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式,可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志(flags),用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志。</p><ul><li>g :表示全局(global)模式,即模式将被应用于所有字符串,而非在发现第一个匹配项时立即停止;</li><li>i :表示不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写;</li><li>m :表示多行(multiline)模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>ES6中新增两个标志</li><li>u :表示“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li><li>y :表示“粘连”（sticky）模式。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷"</span>;</span><br><span class="line"><span class="string">//</span>如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</span><br><span class="line">/^.$<span class="string">/.test</span><span class="params">(s)</span> <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">/^.$<span class="string">/u.test</span><span class="params">(s)</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span>如果不加u修饰符，正则表达式无法识别\u&#123;61&#125;这种表示法，只会认为这匹配61个连续的u。</span><br><span class="line">/\u&#123;61&#125;<span class="string">/u.test</span><span class="params">('a')</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line">/\u&#123;20BB7&#125;<span class="string">/u.test</span><span class="params">('𠮷')</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span>使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。</span><br><span class="line">/𠮷&#123;2&#125;<span class="string">/.test</span><span class="params">('𠮷𠮷')</span> <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">/𠮷&#123;2&#125;<span class="string">/u.test</span><span class="params">('𠮷𠮷')</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//u</span>修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。\S是预定义模式</span><br><span class="line">/^\S$<span class="string">/.test</span><span class="params">('𠮷')</span> <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">/^\S$<span class="string">/u.test</span><span class="params">('𠮷')</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span>有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</span><br><span class="line">/[a-z]<span class="string">/i.test</span><span class="params">('\u212A')</span> <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">/[a-z]<span class="string">/iu.test</span><span class="params">('\u212A')</span> <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>y修饰符号隐含了头部匹配的标志<code>ˆ</code>。y修饰符的设计本意，就是让头部匹配的标志ˆ在全局匹配中都有效。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"aaa_aa_a"</span>;</span><br><span class="line">var r1 = <span class="string">/a</span>+<span class="string">/g</span>;</span><br><span class="line">var r2 = <span class="string">/a</span>+<span class="string">/y</span>;</span><br><span class="line">r1.exec<span class="params">(s)</span> <span class="string">//</span> [<span class="string">"aaa"</span>]</span><br><span class="line">r2.exec<span class="params">(s)</span> <span class="string">//</span> [<span class="string">"aaa"</span>]</span><br><span class="line">r1.exec<span class="params">(s)</span> <span class="string">//</span> [<span class="string">"aa"</span>]</span><br><span class="line"><span class="string">//</span>和g一样都是从_aa_a开始，但是y标志要求必须以a开头，所以返回null</span><br><span class="line">r2.exec<span class="params">(s)</span> <span class="string">//</span> null</span><br></pre></td></tr></table></figure><p>如果同时使用g修饰符和y修饰符，则y修饰符覆盖g修饰符。</p><p>模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： <code>( [ { \ ^ $ | ) ? * + .]}</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有以"at"结尾的 3 个字符的组合,不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"><span class="comment">// 匹配所有".at",不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure><p>这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp 构造函数,它接收两个参数:一个是要匹配的字符串模式,另一个是可选的标志字符串。可以使用字面量定义的任何表达式,都可以使用构造函数来定义,如下面的例子所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个"bat"或"cat",不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 与 pattern1 相同,只不过是使用构造函数创建的</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure><p>要注意的是，传递给RegExp构造函数的两个参数都是字符串（ES5不能把正则表达式字面量传递给RegExp构造函数，ES6支持传递正则表达式字面量，如果同时有第二个标识参数，将覆盖字面量中的标识）。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如<code>\n</code>（字符<code>\</code>在字符串中通常被转义为<code>\\</code>，而在正则表达式字符串中就会变成<code>\\\\</code>）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6中</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">RegExp(<span class="operator">/</span><span class="params">abc</span><span class="operator">/</span><span class="params">ig</span>, '<span class="params">i</span>')</span>.flags; <span class="comment">//"i"</span></span><br></pre></td></tr></table></figure><p>使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">re</span> = <span class="literal">null</span>, i;</span><br><span class="line">for (<span class="attr">i=0;</span> i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="attr">re</span> = /cat/g;</span><br><span class="line">  re.test(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环中,即使是循环体中指定的,但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性(下一节介绍实例属性)不会重置,所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 “cat” ,但第二次调用是从索引为 3 的字符(上一次匹配的末尾)开始的,所以就找不到它了。由于会测试到字符串末尾,所以下一次再调用 test() 就又从开头开始了。</p><p>ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例</p><h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p><ul><li>global：布尔值，表示是否设置了g标志。</li><li>ignoreCase：布尔值，表示是否设置了i标志。</li><li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li><li>multiline：布尔值，表示是否设置了m标志。</li><li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>ES6新增属性</li><li>sticky:布尔值，表示是否设置了y标志。</li><li>flags: 字符串，表示正则表达式的标志</li></ul><p>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。</p><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = /mom( <span class="keyword">and</span> dad( <span class="keyword">and</span> baby)?)?/gi;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">matches</span> = pattern<span class="variable">.exec</span>(text);</span><br><span class="line">alert(<span class="keyword">matches</span><span class="variable">.index</span>); <span class="comment">// 0</span></span><br><span class="line">alert(<span class="keyword">matches</span><span class="variable">.input</span>); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(<span class="keyword">matches</span>[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert(<span class="keyword">matches</span>[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></span><br><span class="line">alert(<span class="keyword">matches</span>[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure><p>对于 exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项</p><p>IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。</p><p>正则表达式的第二个方法是 test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回 false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便</p><p>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</p><p>正则表达式的valueOf()方法返回正则表达式本身。</p><h3 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h3><p>RegExp 构造函数属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串。Opera未实现此属性</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项。Opera未实现此属性</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组。Opera未实现此属性</td></tr><tr><td>leftContext</td><td>$`</td><td>input字符串中lastMatch之前的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值,表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td></tr><tr><td>rightContext</td><td>$’</td><td>Input字符串中lastMatch之后的文本</td></tr></tbody></table><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line">var pattern = /(.)hort/g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">  alert(<span class="module-access"><span class="module"><span class="identifier">RegExp</span>.</span></span>input); <span class="comment">// this has been a short summer</span></span><br><span class="line">  alert(<span class="module-access"><span class="module"><span class="identifier">RegExp</span>.</span></span>leftContext); <span class="comment">// this has been a</span></span><br><span class="line">  alert(<span class="module-access"><span class="module"><span class="identifier">RegExp</span>.</span></span>rightContext); <span class="comment">// summer</span></span><br><span class="line">  alert(<span class="module-access"><span class="module"><span class="identifier">RegExp</span>.</span></span>lastMatch); <span class="comment">// short</span></span><br><span class="line">  alert(<span class="module-access"><span class="module"><span class="identifier">RegExp</span>.</span></span>lastParen); <span class="comment">// s</span></span><br><span class="line">  alert(<span class="module-access"><span class="module"><span class="identifier">RegExp</span>.</span></span>multiline); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegExp构造函数的各个属性返回了下列值：</p><ul><li>input属性返回了原始字符串；</li><li>leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；</li><li>lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short；</li><li>lastParen 属性返回最近一次匹配的捕获组,即例子中的s</li></ul><p>由于短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们</p><p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是 RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</span><br><span class="line">  alert(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">  alert(<span class="built_in">RegExp</span>.$<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串必须转义，才能作为正则模式。有人提议作为RegExp对象的静态方法RegExp.escape()，放入ES7。该方法用于将字符串转义，但是最终这个方法没有被加入。</p><p>目前，该方法可以用下面的escapeRegExp函数或者垫片模块<a href="https://github.com/ljharb/regexp.escape" target="_blank" rel="noopener">regexp.escape</a>实现。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function escapeRegExp(str) &#123;</span><br><span class="line">  return str.replace(/[<span class="symbol">\-</span><span class="symbol">\[</span><span class="symbol">\]</span><span class="symbol">\/</span><span class="symbol">\&#123;</span><span class="symbol">\&#125;</span><span class="symbol">\(</span><span class="symbol">\)</span><span class="symbol">\*</span><span class="symbol">\+</span><span class="symbol">\?</span><span class="symbol">\.</span><span class="symbol">\\</span><span class="symbol">\^</span><span class="symbol">\$</span><span class="symbol">\|</span>]/g, "<span class="symbol">\\</span>$&amp;");</span><br><span class="line">&#125;</span><br><span class="line">let str = '/path/to/resource.html?search=query';</span><br><span class="line">escapeRegExp(str)</span><br><span class="line">// "<span class="symbol">\/</span>path<span class="symbol">\/</span>to<span class="symbol">\/</span>resource<span class="symbol">\.</span>html<span class="symbol">\?</span>search=query"</span><br></pre></td></tr></table></figure><h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>ECMAScript 正则表达式不支持的特性(要了解更多相关信息。</p><ul><li>匹配字符串开始和结尾的 \A 和 \Z 锚，但支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾。</li><li>向后查找(lookbehind),但完全支持向前查找(lookahead)<br>。</li><li>并集和交集类</li><li>原子组(atomic grouping)</li><li>Unicode 支持(单个字符除外,如 \uFFFF )</li><li>命名的捕获组，但支持编号的捕获组。</li><li>s (single,单行)和 x (free-spacing,无间隔)匹配模式</li><li>条件匹配</li><li>正则表达式注释</li></ul><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>说起来 ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。<strong>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</strong>。</p><p>函数通常是使用函数声明语法定义的。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">sum</span> (num1, num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">num1</span> + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用函数表达式定义函数的方式，和上面效果是一样的。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用函数表达式定义函数时，没有必要使用函数名——通过变量sum即可以引用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。</p><p>最后一种定义函数的方式是使用Function构造函数。Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>)</span></span>; <span class="comment">// 不推荐，因为这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码,第二次是解析传入构造函数中的字符串)</span></span><br></pre></td></tr></table></figure><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1, num2)</span>&#123;</span></span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">var anotherSum = <span class="built_in">sum</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p><strong>使用不带圆括号的函数名是访问函数指针，而非调用函数</strong></p><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>将函数名想象为指针，也有助于理解为什么 ECMAScript中没有函数重载的概念。在创建第二个同名函数时,实际上覆盖了引用第一个函数的函数名变量。</p><h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</p><p>在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title">sum</span>(num1, num2)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">num1</span> + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子可以正常运行，但是下面的运行时会抛出错误</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">var <span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回（将函数返回这是一种很有用的技巧）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> call<span class="constructor">SomeFunction(<span class="params">someFunction</span>, <span class="params">someArgument</span>)</span>&#123; <span class="comment">//someFunction是一个函数</span></span><br><span class="line">  return some<span class="constructor">Function(<span class="params">someArgument</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>在函数内部，有两个特殊的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">factorial</span>(<span class="built_in">num</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">num</span> &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // <span class="built_in">return</span> <span class="built_in">num</span> * <span class="built_in">factorial</span>(<span class="built_in">num</span> - <span class="number">1</span>); 和下面效果相同，但是如果引用函数的变量名不是<span class="built_in">factorial</span>而是<span class="built_in">var</span> a = <span class="built_in">factorial</span>，同时<span class="built_in">factorial</span>被指向另一个函数，通过a调用该方法，那么这样就会有问题了</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">num</span> * arguments.callee(<span class="built_in">num</span>-<span class="number">1</span>); //通过这种方法，消除了和函数名的耦合</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部的另一个特殊对象是 this ,其行为与 Java 和 C#中的 this 大致类似。this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。</p><p>一定要牢记，函数的名字仅仅是一个包含指针的变量而已。</p><p>ECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p><p>同样，为了实现更松散的耦合，可以通过arguments.callee.caller访问调用当前函数的函数的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。ECMAScript 5 还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller 和函数的caller 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。 严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。</p><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length 和prototype。其中，length 属性表示函数希望接收的命名参数（形参）的个数</p><p>对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的（第6章将详细介绍）。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p><p>每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments对象</p><p>下例中，因为是在全局作用域中调用的,所以传入的就是 window 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用 apply()或 call()，否则 this 值将是undefined</p><p>call() 方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时,传递给函数的参数必须逐个列举出来</p><p>传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>);<span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(o); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure><p>使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。如上sayColor方法就没有和具体对象耦合</p><p>ECMAScript 5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure><p>每个函数继承的 toLocaleString()和 toString()方法始终都返回函数的代码</p><p>另外一个继承的valueOf()方法同样也只返回函数代码。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function log(<span class="symbol">x</span>, <span class="symbol">y</span> = <span class="string">'World'</span>) &#123;</span><br><span class="line">  console.log(<span class="symbol">x</span>, <span class="symbol">y</span>);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><p>默认值的写法非常灵活，下面是一个为对象属性设置默认值的例子。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">fetch</span>(url, &#123; body = <span class="string">''</span>, <span class="keyword">method</span> = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;)&#123;</span><br><span class="line">  console.log(<span class="keyword">method</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，传入函数fetch的第二个参数是一个对象，调用的时候可以为它的三个属性设置默认值。</p><p>甚至还可以设置双重默认值。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(</span>url, &#123; <span class="function"><span class="keyword">method</span> =</span> <span class="comment">'GET' &#125; = &#123;&#125;)&#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p><p>定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。</p><p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, b, c = 5)</span></span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throwIfMissing() &#123;</span><br><span class="line">  throw new Error(&#39;Missing parameter&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(mustBeProvided &#x3D; throwIfMissing()) &#123;</span><br><span class="line">  return mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">&#x2F;&#x2F; Error: Missing parameter</span><br></pre></td></tr></table></figure><p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（即函数名之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行），这与python语言不一样。</p><p>另一个需要注意的地方是，参数默认值所处的作用域，不是全局作用域，而是函数作用域。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="symbol">x</span> = <span class="number">1</span>;</span><br><span class="line">function foo(<span class="symbol">x</span>, <span class="symbol">y</span> = <span class="symbol">x</span>) &#123;</span><br><span class="line">  console.log(<span class="symbol">y</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数y的默认值等于x，由于处在函数作用域，所以y等于参数x，而不是全局变量x。</p><p>参数默认值可以与解构赋值，联合起来使用。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;<span class="symbol">x</span>, <span class="symbol">y</span> = <span class="number">5</span>&#125;) &#123;</span><br><span class="line">  console.log(<span class="symbol">x</span>, <span class="symbol">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></span><br><span class="line">foo(&#123;<span class="symbol">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></span><br><span class="line">foo(&#123;<span class="symbol">x</span>: <span class="number">1</span>, <span class="symbol">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，foo函数的参数是一个对象，变量x和y用于解构赋值，y有默认值5。</p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。（和Java的变长参数类似）</p><p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><p>函数的length属性，不包括rest参数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, <span class="rest_arg">...b</span>)</span> </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面max,push 方法不接受数组</span></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line">Math.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Math.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line">var arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">var arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line">var arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">var arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"></span><br><span class="line">var a = [<span class="number">1</span>];</span><br><span class="line">var b = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">var c = [<span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">var d = [<span class="number">0</span>, ...a, ...b, <span class="number">5</span>, ...c];</span><br></pre></td></tr></table></figure><p>上面代码其实也提供了，将一个数组拷贝进另一个数组的便捷方法。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr2 = [...arr1]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>扩展运算符也可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><p>任何类似数组的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodeList = document.querySelectorAll('div');</span><br><span class="line">var<span class="built_in"> array </span>= [...node<span class="class">List];</span></span><br></pre></td></tr></table></figure><p>上面代码中，querySelectorAll方法返回的是一个nodeList对象，扩展运算符可以将其转为真正的数组。</p><p>扩展运算符内部调用的是数据结构的Iterable接口，因此只要具有Iterable接口的对象，都可以使用扩展运算符，比如Map结构。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>(<span class="meta">[</span></span><br><span class="line">  <span class="meta">[</span><span class="number">1</span>, <span class="string">'one'</span><span class="meta">]</span>,</span><br><span class="line">  <span class="meta">[</span><span class="number">2</span>, <span class="string">'two'</span><span class="meta">]</span>,</span><br><span class="line">  <span class="meta">[</span><span class="number">3</span>, <span class="string">'three'</span><span class="meta">]</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr = <span class="meta">[</span><span class="params">...</span><span class="built_in">map</span>.keys()<span class="meta">]</span>; // <span class="meta">[</span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span><span class="meta">]</span></span><br></pre></td></tr></table></figure><p>Generator函数运行后，返回一个同时实现了Iterator和Iterable接口的对象，因此也可以使用扩展运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量go是一个Generator函数，执行后返回的是一个Iterable对象，对这个对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var i = 1 <span class="string">.toString</span><span class="params">()</span>; <span class="string">//</span>注意空格，否则会被当浮点数解析，然后抛错，还可以写为<span class="params">(1)</span><span class="string">.toString</span><span class="params">()</span>  1.<span class="string">.toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>上例中实际执行了三步：1. 创建Number类型的一个实例 2. 在实例上调用指定方法 3. 销毁这个实例</p><p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">s1</span> = <span class="string">"some text"</span>;</span><br><span class="line"><span class="built_in">s1</span>.color = <span class="string">"red"</span>;</span><br><span class="line">alert(<span class="built_in">s1</span>.color)<span class="comment">; //undefined</span></span><br></pre></td></tr></table></figure><p>在此,第二行代码试图为字符串 s1 添加一个 color 属性。但是,当第三行代码再次访问 s1 时, 其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。第三行代码又创建自己的 String 对象,而该对象没有 color 属性。</p><p>Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">number</span> = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="built_in">number</span>); <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>Boolean 对象在 ECMAScript 中的用处不大,因为它经常会造成人们的误解。所以不推荐使用。</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = new <span class="type">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(<span class="literal">result</span>); //这里返回的是<span class="literal">true</span> 布尔表达式中的所有对象都会被转换为<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>和Boolean类型类似，不推荐直接创建Number类型的实例，而应该使用基本类型。</p><p>toFixed()方法会按照指定的小数位返回数值的字符串表示。J如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert((<span class="number">10</span>).toFixed(<span class="number">2</span>)); <span class="comment">//"10.00"</span></span><br><span class="line">alert((<span class="number">10.005</span>).toFixed(<span class="number">2</span>)); <span class="comment">//"10.01"</span></span><br></pre></td></tr></table></figure><p>toFixed() 方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范围,有些浏览器也可能支持更多位数。</p><p>另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法（也称e表示法）表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert((<span class="number">10</span>).toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></span><br></pre></td></tr></table></figure><p>如果你想得到表示某个数值的最合适的格式,就应该使用 toPrecision() 方法。对于一个数值来说，toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num = <span class="number">99</span><span class="comment">;</span></span><br><span class="line">alert(<span class="name">num</span>.toPrecision(<span class="number">1</span>))<span class="comment">; //"1e+2"</span></span><br><span class="line">alert(<span class="name">num</span>.toPrecision(<span class="number">2</span>))<span class="comment">; //"99"</span></span><br><span class="line">alert(<span class="name">num</span>.toPrecision(<span class="number">3</span>))<span class="comment">; //"99.0"</span></span><br></pre></td></tr></table></figure><p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> // <span class="literal">true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>八进制不再允许使用前缀0表示，而改为使用前缀0o。</p><p>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法，用来检查无穷（infinity）和NaN这两个特殊值。它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</p><p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p><p>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。<code>Number.isInteger(25.0) // true</code></p><p>JavaScript能够准确表示的整数范围在-2ˆ53 and 2ˆ53之间。ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>和Java中的String有点类似，String类型的方法只是返回一个新的字符串，不会改变原字符串。</p><p>String类型的每个实例都有一个length属性，表示字符串中包含多个字符。应该注意的是，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。</p><p>两个用于访问字符串中特定字符的方法是：charAt()和 charCodeAt()。这两个方法都接收一个参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符</p><p>如果你想得到的不是字符而是字符编码，那么就要像下面这样使用charCodeAt()了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">string</span>Value = <span class="string">"hello world"</span>; alert(<span class="built_in">string</span>Value.charCodeAt(<span class="number">1</span>)); <span class="comment">//输出"101"</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符</p><p>concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。应用更多的还是加号操作符。</p><p>ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr() 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和 substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。</p><p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">string</span>Value = <span class="string">"hello world"</span>;</span><br><span class="line">alert(<span class="built_in">string</span>Value.slice(<span class="number">-3</span>)); <span class="comment">//"rld" slice(8)</span></span><br><span class="line">alert(<span class="built_in">string</span>Value.substring(<span class="number">-3</span>)); <span class="comment">//"hello world" substring(0)</span></span><br><span class="line">alert(<span class="built_in">string</span>Value.substr(<span class="number">-3</span>)); <span class="comment">//"rld" substr(8)</span></span><br><span class="line">alert(<span class="built_in">string</span>Value.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"lo w" slice(3, 7)</span></span><br><span class="line">alert(<span class="built_in">string</span>Value.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//"hel" substring(3,0) 而由于这个方法会将较小的数作为开始位置,将较大的数作为结束位置, 因此最终相当于调用了 substring(0,3)</span></span><br><span class="line">alert(<span class="built_in">string</span>Value.substr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">//""(空字符串) substr(3,0)</span></span><br></pre></td></tr></table></figure><p>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索</p><p>trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。Firefox 3.5+、Safari 5+和Chrome 8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。</p><p>接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript 中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</p><p>String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与调用 RegExp 的 exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象</p><p>另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。</p><p>为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志</p><p>如果第二个参数是字符串,那么还可以使用一些特殊的字符序列,将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。</p><table><thead><tr><th>字符序列</th><th>替换文本</th></tr></thead><tbody><tr><td>$$</td><td>$</td></tr><tr><td>$&amp;</td><td>匹配整个模式的子字符串。与 RegExp.lastMatch 的值相同</td></tr><tr><td>$’</td><td>匹配的子字符串之前的子字符串。与 RegExp.leftContext 的值相同</td></tr><tr><td>$`</td><td>匹配的子字符串之后的子字符串。与 RegExp.rightContext 的值相同</td></tr><tr><td>$n</td><td>匹配第n个捕获组的子字符串,其中n等于0~9。例如, $1 是匹配第一个捕获组的子字符串, $2 是匹配第二个捕获组的子字符串,以此类推。如果正则表达式中没有定义捕获组,则使用空字符串</td></tr><tr><td>$nn</td><td>匹配第nn个捕获组的子字符串,其中nn等于01~99。例如, $01 是匹配第一个捕获组的子字符串, $02是匹配第二个捕获组的子字符串,以此类推。如果正则表达式中没有定义捕获组,则使用空字符串</td></tr></tbody></table><p>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace()方法的第二个参数可以实现更加精细的替换操作</p><p>最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p><p>对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别,但对于未发现匹配项以及带有捕获组的模式,匹配的行为就不大相同了。以下是几种常见的差别。</p><ul><li>IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地在结果中包含捕获组。</li><li>Firefox 3.6 及之前版本在捕获组未找到匹配项时,会在结果数组中包含空字符串;ECMA-262 规定没有匹配项的捕获组在结果数组中应该用 undefined 表示。</li></ul><p>ES6将match()、replace()、search()和split()这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p><ul><li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li><li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li><li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li><li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li></ul><p>与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：</p><ul><li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；</li><li>如果字符串等于字符串参数，则返回0；</li><li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）。</li></ul><p>另外，String 构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串</p><p>一些被浏览器扩展的方法，应该尽量不使用这些方法,因为它们创建的标记通常无法表达语义。</p><table><thead><tr><th>方法</th><th>输出结果</th></tr></thead><tbody><tr><td>anchor(name)</td><td><code>&lt;a name= &quot;name&quot;&gt;string&lt;/a&gt;</code></td></tr><tr><td>big()</td><td><code>&lt;big&gt;string&lt;/big&gt;</code></td></tr><tr><td>bold()</td><td><code>&lt;b&gt;string&lt;/b&gt;</code></td></tr><tr><td>fixed()</td><td><code>&lt;tt&gt;string&lt;/tt&gt;</code></td></tr><tr><td>fontcolor(color)</td><td><code>&lt;font color=&quot;color&quot;&gt;string&lt;/font&gt;</code></td></tr><tr><td>fontsize(size)</td><td><code>&lt;font size=&quot;size&quot;&gt;string&lt;/font&gt;</code></td></tr><tr><td>italics()</td><td><code>&lt;i&gt;string&lt;/i&gt;</code></td></tr><tr><td>link(url)</td><td><code>&lt;a href=&quot;url&quot;&gt;string&lt;/a&gt;</code></td></tr><tr><td>small()</td><td><code>&lt;small&gt;string&lt;/small&gt;</code></td></tr><tr><td>strike()</td><td><code>&lt;strike&gt;string&lt;/strike&gt;</code></td></tr><tr><td>sub()</td><td><code>&lt;sub&gt;string&lt;/sub&gt;</code></td></tr><tr><td>sup()</td><td><code>&lt;sup&gt;string&lt;/sup&gt;</code></td></tr></tbody></table><p>ECMAScript6中对String进行了扩展。</p><p>对于Unicode字符，之前<code>\u20BB7</code>会被解析为<code>\u20BB+7</code>。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。<code>\u{20BB7}</code></p><p>ES6提供了String.fromCodePoint方法，可以识别码点大于0xFFFF（辅助平面）的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x20BB7)</span>;<span class="comment">// "ஷ"</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CodePoint(0x20BB7)</span>;<span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p><p>ES6提供了String.codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷a"</span>;</span><br><span class="line"></span><br><span class="line">s.code<span class="constructor">PointAt(0)</span> <span class="comment">// 134071</span></span><br><span class="line">s.code<span class="constructor">PointAt(1)</span> <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">CodeAt(0)</span> <span class="comment">// 55362</span></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">CodeAt(1)</span> <span class="comment">// 57271</span></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">CodeAt(2)</span> <span class="comment">// 97</span></span><br></pre></td></tr></table></figure><p>上面代码中，汉字“𠮷”的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。</p><p>codePointAt方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。</p><p>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</p><p>ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。Chrome浏览器已经支持该方法。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𠮷'</span>.charAt<span class="comment">(0)</span> <span class="comment">// "\uD842"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.at<span class="comment">(0)</span> <span class="comment">// "a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.at<span class="comment">(0)</span> <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><p>为了表示语调和重音符号，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.<span class="keyword">normalize</span>() === <span class="string">'\u004F\u030C'</span>.<span class="keyword">normalize</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>normalize方法可以接受四个参数。</p><ul><li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li><li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li><li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。</li><li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li></ul><p>不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。</p><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li></ul><p>这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p><p>repeat()返回一个新字符串，表示将原字符串重复n次。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.<span class="keyword">repeat</span><span class="comment">(3)</span> <span class="comment">// "hellohellohello"</span></span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`<span class="keyword">In</span> JavaScript <span class="string">'\n'</span> <span class="keyword">is</span> a <span class="type">line</span>-feed.`</span><br><span class="line">// 多行字符串</span><br><span class="line">`<span class="keyword">In</span> JavaScript this <span class="keyword">is</span></span><br><span class="line"> <span class="keyword">not</span> legal.`</span><br><span class="line">console.log(`string <span class="type">text</span> <span class="type">line</span> <span class="number">1</span></span><br><span class="line">string <span class="type">text</span> <span class="type">line</span> <span class="number">2</span>`);</span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">var <span class="type">name</span> = "Bob", <span class="type">time</span> = "today";</span><br><span class="line">console.log(`\`Hello $&#123;<span class="type">name</span>&#125;, how are you $&#123;<span class="type">time</span>&#125;?\`</span><br><span class="line">$&#123;<span class="string">'Mr. '</span> + <span class="type">name</span>&#125;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数</p><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><p>标签模板</p><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p><p>函数tag依次会接收到多个参数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, value1, value2)</span></span>&#123; <span class="comment">// ...  &#125;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, <span class="rest_arg">...values</span>)</span></span>&#123; <span class="comment">// ...  &#125;</span></span><br></pre></td></tr></table></figure><p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p><p>tag函数所有参数的实际值如下。</p><ul><li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li><li>第二个参数: 15</li><li>第三个参数：50</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// "Hello "</span></span><br><span class="line"><span class="comment">// " world "</span></span><br><span class="line"><span class="comment">// ""</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// "OK"</span></span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// "First line\\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么strings.raw数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将<code>\n</code>视为<code>\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><p>ES6还为原生的String对象，提供了一个raw方法。String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 'Hi\\u000A!'</span></span><br></pre></td></tr></table></figure><p>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw(&#123; raw: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 't0e1s2t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; raw: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>Global（全局）对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ,实际上全都是 Global 对象的方法。</p><ul><li><p>URI 编码方法<br>  对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 其中，encodeURI()主要用于整个URI（例如，<code>http://www.wrox.com/illegal value.htm</code>），而 encodeURIComponent()主要用于对URI中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p><p>  一般来说，我们使用 encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI进行编码。</p><p>  与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和decodeURIComponent()</p></li><li><p>eval()方法<br>  现在，我们介绍最后一个——大概也是整个ECMAScript语言中最强大的一个方法：eval()。eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。看例子： eval(“alert(‘hi’)”); 这行代码的作用等价于代码： alert(“hi”);</p><p>  当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过 eval() 执行的代码可以引用在包<br>含环境中定义的变量 <code>var msg = &quot;hello world&quot;; eval(&quot;alert(msg)&quot;);</code></p><p>  在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。 严格模式下，在外部访问不到eval()中创建的任何变量或函数，在严格模式下,为 eval 赋值也会导致错误</p></li><li><p>Global 对象的属性<br>  特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下表列出了Global对象的所有属性。</p></li></ul><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>undefined</td><td>特殊值 undefined</td></tr><tr><td>NaN</td><td>特殊值 NaN</td></tr><tr><td>Infinity</td><td>特殊值 Infinity</td></tr><tr><td>Date</td><td>构造函数 Date</td></tr><tr><td>RegExp</td><td>构造函数 RegExp</td></tr><tr><td>Error</td><td>构造函数 Error</td></tr><tr><td>Object</td><td>构造函数 Object</td></tr><tr><td>Array</td><td>构造函数 Array</td></tr><tr><td>Function</td><td>构造函数 Function</td></tr><tr><td>Boolean</td><td>构造函数 Boolean</td></tr><tr><td>String</td><td>构造函数 String</td></tr><tr><td>Number</td><td>构造函数 Number</td></tr><tr><td>EvalError</td><td>构造函数 EvalError</td></tr><tr><td>RangeError</td><td>构造函数 RangeError</td></tr><tr><td>ReferenceError</td><td>构造函数 ReferenceError</td></tr><tr><td>SyntaxError</td><td>构造函数 SyntaxError</td></tr><tr><td>TypeError</td><td>构造函数 TypeError</td></tr><tr><td>URIError</td><td>构造函数 URIError</td></tr></tbody></table><p>ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。</p><ul><li>window 对象<br>  ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</li></ul><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><p>Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。下表列出了这些属性。</p><ul><li>Math 对象的属性</li></ul><table><thead><tr><th>属 性</th><th>说 明</th></tr></thead><tbody><tr><td>Math.E</td><td>自然对数的底数，即常量e的值</td></tr><tr><td>Math.LN10</td><td>10的自然对数</td></tr><tr><td>Math.LN2</td><td>2的自然对数</td></tr><tr><td>Math.LOG2E</td><td>以2为底e的对数</td></tr><tr><td>Math.LOG10E</td><td>以10为底e的对数</td></tr><tr><td>Math.PI</td><td>π的值</td></tr><tr><td>Math.SQRT1_2</td><td>1/2的平方根（即2的平方根的倒数）</td></tr><tr><td>Math.SQRT2</td><td>2的平方根</td></tr></tbody></table><ul><li><p>min() 和 max() 方法<br>  这两个方法都可以接收任意多个数值参数，要查找数组中的最大值可以使用apply方法。</p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">var max = Math.max.apply(Math, values);</span><br></pre></td></tr></table></figure></li><li><p>舍入方法</p><ul><li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li><li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li><li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li></ul></li><li><p>random() 方法<br>  Math.random() 方法返回大于等于 0 小于 1 的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。 <code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code></p></li><li><p>其他方法</p></li></ul><table><thead><tr><th>方 法</th><th>说 明</th></tr></thead><tbody><tr><td>Math.abs(num)</td><td>返回num 的绝对值</td></tr><tr><td>Math.exp(num)</td><td>返回Math.E 的num 次幂</td></tr><tr><td>Math.log(num)</td><td>返回num 的自然对数</td></tr><tr><td>Math.pow(num,power)</td><td>返回num 的power 次幂</td></tr><tr><td>Math.sqrt(num)</td><td>返回num 的平方根</td></tr><tr><td>Math.acos(x)</td><td>返回x 的反余弦值</td></tr><tr><td>Math.asin(x)</td><td>返回x 的反正弦值</td></tr><tr><td>Math.atan(x)</td><td>返回x 的反正切值</td></tr><tr><td>Math.atan2(y,x)</td><td>返回y/x 的反正切值</td></tr><tr><td>Math.cos(x)</td><td>返回x 的余弦值</td></tr><tr><td>Math.sin(x)</td><td>返回x 的正弦值</td></tr><tr><td>Math.tan(x)</td><td>返回x 的正切值</td></tr></tbody></table><ul><li><p>ES6新增方法</p><ul><li>Math.trunc(num)：去除一个数的小数部分，返回整数部分，对于空值和无法截取整数的值，返回NaN</li><li>Math.sign(num)：判断一个数到底是正数、负数、还是零。参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。</li><li>Math.cbrt(num)：计算一个数的立方根</li><li>Math.clz32(num)：返回一个数的32位无符号整数二进制形式表示有多少个前导0。对于小数，只考虑整数部分，对于其他值，先转为数值，再计算</li><li>Math.imul(num1,num2)：回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。多数情况和<code>(a * b)|0</code>效果相同，但JavaScript对于超过2的53次方的值无法精确表示，该方法可以得到正确值</li><li>Math.fround(num)：Math.fround方法返回一个数的单精度浮点数形式。对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</li><li>Math.hypot()：返回所有参数的平方和的平方根，如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN</li><li>Math.expm1()：返回Math.exp(x) - 1</li><li>Math.log1p()：返回1 + x的自然对数。如果x小于-1，返回NaN</li><li>Math.log10()：返回以10为底的x的对数。如果x小于0，则返回NaN</li><li>Math.log2()：返回以2为底的x的对数。如果x小于0，则返回NaN</li><li>Math.sinh(x)：返回x的双曲正弦（hyperbolic sine）</li><li>Math.cosh(x)：返回x的双曲余弦（hyperbolic cosine）</li><li>Math.tanh(x)：返回x的双曲正切（hyperbolic tangent）</li><li>Math.asinh(x)：返回x的反双曲正弦（inverse hyperbolic sine）</li><li>Math.acosh(x)：返回x的反双曲余弦（inverse hyperbolic cosine）</li><li>Math.atanh(x)：返回x的反双曲正切（inverse hyperbolic tangent）</li></ul></li></ul><h2 id="键集合类型"><a href="#键集合类型" class="headerlink" title="键集合类型"></a>键集合类型</h2><h3 id="Map-类型"><a href="#Map-类型" class="headerlink" title="Map 类型"></a>Map 类型</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = &#123;&#125;;</span></span><br><span class="line"><span class="title">var</span> element = document.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span>[element] = metadata;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>["[<span class="type">Object</span> <span class="type">HTMLDivElement</span>]"] // metadata</span></span><br></pre></td></tr></table></figure><p>上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串<code>[Object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p><p>作为构造函数，Map可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([ [<span class="string">"name"</span>, <span class="string">"张三"</span>], [<span class="string">"title"</span>, <span class="string">"Author"</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">size</span> <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">"name"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"name"</span>) <span class="comment">// "张三"</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">"title"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"title"</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><p>如果读取一个未知的键，则返回undefined。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().<span class="keyword">get</span>(<span class="string">'asfddfsasadf'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line">var k1 = [<span class="string">'a'</span>];</span><br><span class="line">var k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(k1, <span class="number">111</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(k1) <span class="comment">// 111</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，</p><p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</p><h4 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h4><p>Map结构的实例有以下属性和操作方法。</p><ul><li>size：返回成员总数。</li><li>set(key, value)：设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li><li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li><li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。</li><li>delete(key)：删除某个键，返回true。如果删除失败，返回false。</li><li>clear()：清除所有成员，没有返回值。</li></ul><p>set()方法返回的是Map本身，因此可以采用链式写法。</p><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><p>Map原生提供三个Iterable对象，这三个对象同样实现了Iterator接口。</p><ul><li>keys()：返回键名的Iterable对象。</li><li>values()：返回键值的Iterable对象。</li><li>entries()：返回所有成员的Iterable对象。</li></ul><p>下面是使用实例。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="built_in">[key</span>, <span class="keyword">value</span>] <span class="keyword">of</span> <span class="keyword">map</span>.entries()) &#123;</span><br><span class="line">  console.log<span class="built_in">(key</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于使用<span class="keyword">map</span>.entries()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="built_in">[key</span>, <span class="keyword">value</span>] <span class="keyword">of</span> <span class="keyword">map</span>) &#123;</span><br><span class="line">  console.log<span class="built_in">(key</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示Map结构的Symbol.iterator属性，就是entries方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[Symbol.iterator] === <span class="built_in">map</span>.entries <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let map = new <span class="symbol">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[...map.values()]</span><br><span class="line">// [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</span><br><span class="line">[...map]</span><br><span class="line">// [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</span><br></pre></td></tr></table></figure><p>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure><p>此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>.forEach(<span class="keyword">function</span>(<span class="keyword">value</span>,<span class="built_in"> key</span>, <span class="keyword">map</span>)) &#123;</span><br><span class="line">  console.log(<span class="string">"Key: %s, Value: %s"</span>,<span class="built_in"> key</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>forEach方法还可以接受第二个参数，用来绑定this。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reporter = &#123;</span><br><span class="line">  report: <span class="keyword">function</span><span class="built_in">(key</span>, <span class="keyword">value</span>) &#123;</span><br><span class="line">    console.log(<span class="string">"Key: %s, Value: %s"</span>,<span class="built_in"> key</span>, <span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">map</span>.forEach(<span class="keyword">function</span>(<span class="keyword">value</span>,<span class="built_in"> key</span>, <span class="keyword">map</span>) &#123;</span><br><span class="line">  this.report<span class="built_in">(key</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure><p>上面代码中，forEach方法的回调函数的this，就指向reporter。</p><h4 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h4><ol><li><p><strong>Map转为数组</strong></p><p> 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p></li><li><p><strong>数组转为Map</strong></p><p> 将数组转入Map构造函数，就可以转为Map。</p></li><li><p><strong>Map转为对象</strong></p><p> 如果所有Map的键都是字符串，通过遍历，它可以转为对象。</p></li><li><p><strong>对象转为Map</strong></p><p>通过遍历Object.keys(obj)，调用map.set方法添加键值对</p></li><li><p><strong>Map转为JSON</strong></p><p> Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。JSON.stringify(strMapToObj(strMap));</p><p> 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 JSON.stringify([…map]);</p></li><li><p><strong>JSON转为Map</strong></p><p> JSON转为Map，正常情况下，所有键名都是字符串。JSON.parse(jsonStr)先转为对象，再把对象转为Map</p><p> 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。new Map(JSON.parse(jsonStr));</p></li></ol><h3 id="WeakMap-类型"><a href="#WeakMap-类型" class="headerlink" title="WeakMap 类型"></a>WeakMap 类型</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p><p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p><p>下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wm = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">".element"</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="keyword">set</span>(element, <span class="string">"Original"</span>);</span><br><span class="line">wm.<span class="keyword">get</span>(element) <span class="comment">// "Original"</span></span><br><span class="line"></span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line">element = <span class="keyword">null</span>;</span><br><span class="line">wm.<span class="keyword">get</span>(element) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量wm是一个WeakMap实例，我们将一个DOM节点element作为键名，然后销毁这个节点，element对应的键就自动消失了，再引用这个键名就返回undefined。</p><p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p><p>WeakMap的另一个用处是部署私有属性。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _counter = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">let</span> _action = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Countdown</span> &#123;</span><br><span class="line">  constructor(counter, action) &#123;</span><br><span class="line">    _counter.<span class="keyword">set</span>(<span class="keyword">this</span>, counter);</span><br><span class="line">    _action.<span class="keyword">set</span>(<span class="keyword">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  dec() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.<span class="keyword">get</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.<span class="keyword">set</span>(<span class="keyword">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.<span class="keyword">get</span>(<span class="keyword">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; console.log(<span class="string">'DONE'</span>));</span><br><span class="line"></span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure><p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p><h3 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set();</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].map(x =&gt; s.add(x))</span><br><span class="line">s<span class="comment">// Set [ 2, 3, 5, 4 ]</span></span><br></pre></td></tr></table></figure><p>Set函数可以接受一个数组作为参数，用来初始化。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var items = new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>向Set加入值的时候，不会发生类型转换，所以5和“5”是两个不同的值。Set内部判断两个值是否不同，使用的算法类似于精确相等运算符（===），这意味着，两个对象总是不相等的。唯一的例外是NaN等于自身（精确相等运算符认为NaN不等于自身）。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">set</span> = <span class="keyword">new</span> Set();</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(&#123;&#125;)</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">size</span> <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(&#123;&#125;)</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不是精确相等，所以它们被视为两个值。</p><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><p>Set结构的实例有以下属性。</p><ul><li>Set.prototype.constructor：构造函数，默认就是Set函数。</li><li>Set.prototype.size：返回Set实例的成员总数。</li></ul><p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li>add(value)：添加某个值，返回Set结构本身。</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>clear()：清除所有成员，没有返回值。</li></ul><p>Array.from方法可以将Set结构转为数组。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var items =<span class="built_in"> new </span>Set([1, 2, 3, 4, 5]);</span><br><span class="line">var<span class="built_in"> array </span>= Array.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了一种去除数组的重复元素的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><strong>遍历操作</strong></p><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li>keys()：返回一个键名的Iterable对象</li><li>values()：返回一个键值的Iterable对象</li><li>entries()：返回一个键值对的Iterable对象</li><li>forEach()：使用回调函数遍历每个成员</li></ul><p>key方法、value方法、entries方法返回的都是Iterable对象，该对象同样实现了Iterator接口。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">set</span> = <span class="built_in">new</span> <span class="keyword">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( let item <span class="keyword">of</span> <span class="keyword">set</span>.entries() )&#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// ["red", "red"]</span><br><span class="line">// ["green", "green"]</span><br><span class="line">// ["blue", "blue"]</span><br></pre></td></tr></table></figure><p>Set结构的实例默认可遍历，它的默认Symbol.iterator方法就是它的values方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype<span class="literal">[S<span class="identifier">ymbol</span>.<span class="identifier">iterator</span>]</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略values方法，直接用for…of循环遍历Set。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="meta">set</span> = new <span class="meta">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line">for (let <span class="meta">x</span> of <span class="meta">set</span>) &#123;</span><br><span class="line">  console<span class="meta">.log(</span><span class="meta">x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">set</span> = <span class="literal">new</span> <span class="built_in">Set</span>(<span class="meta">[</span><span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span><span class="meta">]</span>);</span><br><span class="line">let arr = <span class="meta">[</span><span class="params">...</span><span class="built_in">set</span><span class="meta">]</span>;</span><br><span class="line">// <span class="meta">[</span><span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span><span class="meta">]</span></span><br></pre></td></tr></table></figure><p>这就提供了另一种便捷的去除数组重复元素的方法。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line">let unique = [...new Set(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure><p>而且，通过扩展运算符，数组的map和filter方法也可以用于Set了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">set = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">set</span>].<span class="params">map</span>(<span class="params">x</span> =&gt; <span class="params">x</span> <span class="operator">*</span> 2)</span>);</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3, 4, 5])</span>;</span><br><span class="line">set = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">set</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; (<span class="params">x</span> % 2)</span><span class="operator"> == </span><span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>因此使用Set，可以很容易地实现并集（Union）和交集（Intersect）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>;</span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>, <span class="operator">...</span><span class="params">b</span>])</span>;</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; <span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>));</span><br><span class="line"><span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><p>Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">set</span>.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(value * <span class="number">2</span>) )</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。</p><p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">set = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">set</span>].<span class="params">map</span>(<span class="params">val</span> =&gt; <span class="params">val</span> <span class="operator">*</span> 2)</span>);</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line">set = <span class="keyword">new</span> <span class="constructor">Set(Array.<span class="params">from</span>(<span class="params">set</span>, <span class="params">val</span> =&gt; <span class="params">val</span> <span class="operator">*</span> 2)</span>);</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。</p><h3 id="WeakSet-类型"><a href="#WeakSet-类型" class="headerlink" title="WeakSet 类型"></a>WeakSet 类型</h3><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p><p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p><p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WeakSet();</span><br><span class="line">ws.<span class="keyword">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的对象。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">[[1,2], [3,4]]</span>;</span><br><span class="line">var ws = new WeakSet(a);</span><br></pre></td></tr></table></figure><p>上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。</p><p>WeakSet结构有以下三个方法。</p><ul><li><strong>WeakSet.prototype.add(value)</strong>：向WeakSet实例添加一个新成员。</li><li><strong>WeakSet.prototype.delete(value)</strong>：清除WeakSet实例的指定成员。</li><li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li></ul><p>WeakSet没有size属性，没有办法遍历它的成员。</p><p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><h2 id="反射类型"><a href="#反射类型" class="headerlink" title="反射类型"></a>反射类型</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。（与Java中动态代理类似）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> proxy </span>= new Proxy(target, handler)</span><br></pre></td></tr></table></figure><p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<code>new Proxy()</code>表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> Proxy(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>一个技巧是将Proxy对象，设置到<code>object.proxy</code>属性，从而可以在object对象上调用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; proxy: <span class="keyword">new</span> <span class="constructor">Proxy(<span class="params">target</span>, <span class="params">handler</span>)</span> &#125;</span><br></pre></td></tr></table></figure><p>Proxy实例也可以作为其他对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所有根据原型链，会在proxy对象上读取该属性，导致被拦截。</p><p>下面是Proxy支持的拦截操作一览。</p><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><ol><li><p><strong>get(target, propKey, receiver)</strong></p><p> 拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>，返回类型不限。最后一个参数receiver可选，当target对象设置了propKey属性的get函数时，receiver对象会绑定get函数的this对象。</p></li><li><p><strong>set(target, propKey, value, receiver)</strong></p><p> 拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p></li><li><p><strong>has(target, propKey)</strong></p><p> 拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p></li><li><p><strong>deleteProperty(target, propKey)</strong></p><p> 拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p></li><li><p><strong>enumerate(target)</strong></p><p> 拦截<code>for (var x in proxy)</code>，返回一个Iterable对象。</p></li><li><p><strong>hasOwn(target, propKey)</strong></p><p> 拦截<code>proxy.hasOwnProperty(&#39;foo&#39;)</code>，返回一个布尔值。</p></li><li><p><strong>ownKeys(target)</strong></p><p> 拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>，返回一个数组。该方法返回对象所有自身的属性，而<code>Object.keys()</code>仅返回对象可遍历的属性。</p></li><li><p><strong>getOwnPropertyDescriptor(target, propKey)</strong></p><p> 拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p></li><li><p><strong>defineProperty(target, propKey, propDesc)</strong></p><p> 拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p></li><li><p><strong>preventExtensions(target)</strong></p><p>拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p></li><li><p><strong>getPrototypeOf(target)</strong></p><p>拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p></li><li><p><strong>isExtensible(target)</strong></p><p>拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p></li><li><p><strong>setPrototypeOf(target, proto)</strong></p><p>拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</p></li></ol><p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p><ol><li><p><strong>apply(target, object, args)</strong></p><p> 拦截Proxy实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p></li><li><p><strong>construct(target, args, proxy)</strong></p><p> 拦截Proxy实例作为构造函数调用的操作，比如new proxy(…args)。</p></li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> Proxy(person, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReferenceError(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name <span class="comment">// "张三"</span></span><br><span class="line">proxy.age <span class="comment">// 抛出一个错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> <span class="params">(receiver, <span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">p() === <span class="string">'I am the proxy'</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。</p><ol><li>将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回false。</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  <span class="keyword">set</span>: <span class="keyword">function</span>(target, <span class="type">name</span>, <span class="keyword">value</span>, receiver) &#123;</span><br><span class="line">    var success = Reflect.<span class="keyword">set</span>(target,<span class="type">name</span>, <span class="keyword">value</span>, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      log(<span class="string">'property '</span>+<span class="type">name</span>+<span class="string">' on '</span>+target+<span class="string">' set to '</span>+<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Reflect对象的方法清单如下。</p><ul><li>Reflect.getOwnPropertyDescriptor(target,name)</li><li>Reflect.defineProperty(target,name,desc)</li><li>Reflect.getOwnPropertyNames(target)</li><li>Reflect.getPrototypeOf(target) 读取对象的<code>__proto__</code>属性，等同于<code>Object.getPrototypeOf(obj)</code>。</li><li>Reflect.setPrototypeOf(obj, newProto) 设置对象的<code>__proto__</code>属性，注意，Object对象没有对应这个方法的方法。</li><li>Reflect.deleteProperty(target,name) 等同于<code>delete obj[name]</code>。</li><li>Reflect.enumerate(target)</li><li>Reflect.freeze(target)</li><li>Reflect.seal(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.isFrozen(target)</li><li>Reflect.isSealed(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.has(target,name) 等同于<code>name in obj</code>。</li><li>Reflect.hasOwn(target,name)</li><li>Reflect.keys(target)</li><li>Reflect.get(target,name,receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数，则读取函数的this绑定receiver。</li><li>Reflect.set(target,name,value,receiver) 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</li><li>Reflect.apply(target,thisArg,args) 等同于<code>Function.prototype.apply.call(fun,thisArg,args)</code>。一般来说，如果要绑定一个函数的this对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的apply方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用Reflect对象可以简化这种操作。</li><li>Reflect.construct(target,args) 等同于<code>new target(...args)</code>，这提供了一种不使用new，来调用构造函数的方法。</li></ul><p>注意，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。</p><h2 id="控制抽象类型"><a href="#控制抽象类型" class="headerlink" title="控制抽象类型"></a>控制抽象类型</h2><h3 id="Iteration-接口"><a href="#Iteration-接口" class="headerlink" title="Iteration 接口"></a>Iteration 接口</h3><p>ECMAScript 中一个接口是一组键值对属性，这些属性的键所对应的值符合特定的规范。如果一个对象提供了一个接口描述的所有属性，那么这个对象就实现了这个接口。一个接口并不是被单独的一个对象表示。可能有很多单独的对象实现符合某个接口，一个单独的对象可能实现多个接口。</p><p>通过统一的接口机制，可以使用for-of来遍历不同的数据结构。</p><h4 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h4><p>这个接口只有一个属性，即Symbol.iterator，它是一个函数，这个函数返回一个实现了Iterator接口的对象。</p><p>在ES6中，有些数据结构原生实现了这个接口（比如数组），不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为实现了Iterable接口。调用这个接口，就会返回一个Iterator对象。</p><h4 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4><p>这个接口有一个属性，next，这个属性是一个函数，它返回一个实现了IteratorResult接口的对象。如果上一步调用next返回的对象的done属性已经是true了，那么之后调用next函数也要返回一个done属性为true的IteratorResult对象。这个要求并不是强制的。</p><p>该接口还有两个可选的属性return 和 throw。这两个属性都是方法，并且方法返回值都是IteratorResult对象。</p><p>done为true，即遍历结束时，如果存在return方法，value的值会被设置为return方法。这并不是强制要求的。</p><h4 id="IteratorResult-接口"><a href="#IteratorResult-接口" class="headerlink" title="IteratorResult 接口"></a>IteratorResult 接口</h4><p>包含value和done两个属性的对象。其中，value属性是当前成员的值，如果iterator提供了return方法的花，done为true时，这个value应该是iterator的return属性的值即return函数，否则done为true时value就是undefined，这种情况下可以没有value属性；done属性是一个布尔值，表示遍历是否结束，如果不存在done，就认为done属性为false。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>如果使用TypeScript的写法，可以描述如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Iterable &#123;</span><br><span class="line">  [Symbol.iterator]() : Iterator,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Iterator &#123;</span><br><span class="line">  next(value?: any) : IterationResult,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IterationResult &#123;</span><br><span class="line">  value: any,</span><br><span class="line">  done: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一个例子</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Obj</span>(<span class="params"><span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.prototype[Symbol.iterator] = function()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> iterator = &#123;</span><br><span class="line">    next: next,</span><br><span class="line">    <span class="keyword">return</span>: returnFn</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current)&#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="keyword">value</span> = current.<span class="keyword">value</span>;</span><br><span class="line">      <span class="keyword">var</span> done = current === <span class="literal">null</span>;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        <span class="keyword">value</span>: <span class="keyword">value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">value</span>: iterator.<span class="keyword">return</span>,</span><br><span class="line">        done: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">function <span class="title">returnFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      done: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">value</span>: <span class="string">'return'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = one[Symbol.iterator]();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next().<span class="keyword">value</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a of one)&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍Iterator对象，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><h4 id="默认实现Iterable接口的数据结构"><a href="#默认实现Iterable接口的数据结构" class="headerlink" title="默认实现Iterable接口的数据结构"></a>默认实现Iterable接口的数据结构</h4><p>Iterable接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterable接口。</p><p>ES6规定，默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，或者一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。也就是说，调用<code>Symbol.iterator</code>方法，就会得到当前数据结构的默认Iterator对象。<code>Symbol.iterator</code>本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。</p><p>在ES6中，有三类数据结构原生具备Iterable接口：数组、某些类似数组的对象、Set和Map结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">let</span> iter = arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: <span class="string">'c'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，变量arr是一个数组，原生就具有Iterable接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到Iterator对象。</p><p>上面提到，原生就部署Iterable接口的数据结构有三类，对于这三类数据结构，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterable接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。</p><p>对象（Object）之所以没有默认部署Iterable接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历是一种线性处理，对于任何非线性的数据结构，部署Iterable接口，就等于部署一种线性转换。不过，严格地说，对象部署Iterable接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。</p><p>一个对象如果要有可被for…of循环调用的Iterable接口，就必须有Symbol.iterator方法（原型链上的对象具有该方法也可）。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RangeIterator</span> &#123;</span><br><span class="line">  constructor(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">value</span> = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="meta">Symbol.iterator</span>]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">value</span> = <span class="keyword">this</span>.<span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">value</span>++;</span><br><span class="line">      <span class="keyword">return</span> &#123;done: <span class="literal">false</span>, <span class="keyword">value</span>: <span class="keyword">value</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;done: <span class="literal">true</span>, <span class="keyword">value</span>: undefined&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">range</span>(<span class="params">start, stop</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="function"><span class="keyword">var</span> <span class="keyword">value</span> of <span class="title">range</span>(<span class="params"><span class="number">0</span>, <span class="number">3</span></span>))</span> &#123;</span><br><span class="line">  console.log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是另一个为对象添加Iterator接口的例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  <span class="keyword">data</span>: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    let index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.<span class="keyword">data</span>.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.<span class="keyword">data</span>[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; value: undefined, done: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于类似数组的对象（存在数值键名和length属性），部署Iterable接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的Iterable接口。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];</span><br><span class="line">// 或者</span><br><span class="line">NodeList.prototype[<span class="string">Symbol.iterator</span>] = [][Symbol.iterator];</span><br><span class="line">[...document.querySelectorAll('div')] // 可以执行了</span><br></pre></td></tr></table></figure><p>如果Symbol.iterator方法返回的不是Iterator对象，解释引擎将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[...obj] <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>有了Iterable接口，数据结构就可以用for…of循环遍历，也可以使用while循环遍历。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="symbol">$iterator</span> = ITERABLE[Symbol.iterator]();</span><br><span class="line"><span class="keyword">var</span> <span class="symbol">$result</span> = <span class="symbol">$iterator</span>.next();</span><br><span class="line"><span class="keyword">while</span> (!<span class="symbol">$result</span>.done) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="symbol">$result</span>.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="symbol">$result</span> = <span class="symbol">$iterator</span>.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，ITERABLE代表某种可遍历的数据结构</p><h4 id="Iterable接口默认的应用场合"><a href="#Iterable接口默认的应用场合" class="headerlink" title="Iterable接口默认的应用场合"></a>Iterable接口默认的应用场合</h4><p>有一些场合会默认使用Iterable接口（即调用Symbol.iterator方法），除了for…of循环，还有几个别的场合。</p><p><strong>解构赋值</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set().<span class="keyword">add</span>(<span class="string">'a'</span>).<span class="keyword">add</span>(<span class="string">'b'</span>).<span class="keyword">add</span>(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y] = <span class="keyword">set</span>;</span><br><span class="line"><span class="comment">// x='a'; y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = <span class="keyword">set</span>; <span class="comment">// first='a'; rest=['b','c'];</span></span><br></pre></td></tr></table></figure><p><strong>扩展运算符</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">var str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] //  [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">let arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br><span class="line">// [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure><p>实际上，这提供了一种简便机制，可以将任何实现了Iterable接口的数据结构，转为数组。也就是说，只要某个数据结构实现了Iterable接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="meta">[</span><span class="params">...</span>iterable<span class="meta">]</span>;</span><br></pre></td></tr></table></figure><p><strong><code>yield*</code></strong></p><p><code>yield*</code>后面跟的是一个实现了Iterable的对象，它会调用该对象的Symbol.iterator方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">generator</span> <span class="string">=</span> <span class="string">function*</span> <span class="string">()</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">yield</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">  <span class="string">yield*</span> <span class="string">[2,3,4];</span> <span class="string">//use</span> <span class="string">an</span> <span class="string">iterable,</span> <span class="string">is</span> <span class="string">looped,</span> <span class="string">and</span> <span class="string">added</span> <span class="string">as</span> <span class="string">yields</span></span><br><span class="line">  <span class="string">yield</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">iterator</span> <span class="string">=</span> <span class="string">generator();</span></span><br><span class="line"></span><br><span class="line"><span class="string">iterator.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">iterator.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">iterator.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">iterator.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">4</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">iterator.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">5</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">iterator.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="string">undefined,</span> <span class="attr">done:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>其他场合</strong></p><p>由于数组的遍历会调用Symbol.iterator方法，所以任何接受数组作为参数的场合，其实都调用了Symbol.iterator。下面是一些例子。</p><ul><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h4 id="原生具备Iterable接口的数据结构"><a href="#原生具备Iterable接口的数据结构" class="headerlink" title="原生具备Iterable接口的数据结构"></a>原生具备Iterable接口的数据结构</h4><p>ES6对数组提供entries()、keys()和values()三个方法，就是返回三个Iterable对象。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 5, 7];</span><br><span class="line">var arrEntries = arr.entries();</span><br><span class="line"></span><br><span class="line">arrEntries.toString() // "[object Array Iterator]"</span><br><span class="line"></span><br><span class="line">arrEntries === arrEntries[<span class="string">Symbol.iterator</span>](<span class="link"></span>) // true</span><br></pre></td></tr></table></figure><p>上面代码中，entries方法返回的是一个Iterator对象，本质上就是调用了<code>Symbol.iterator</code>方法。</p><p>字符串是一个类似数组的对象，也原生具有Iterable接口。</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line">typeof someString[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]</span><br><span class="line">// <span class="string">"function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">iterator</span> = someString[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">iterator</span>.next()  // &#123; value: <span class="string">"h"</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next()  // &#123; value: <span class="string">"i"</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next()  // &#123; value: undefined, done: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改Iterator对象行为的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>);</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ["h", "i"]</span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">        <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">"bye"</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _first: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ["bye"]</span></span><br><span class="line">str <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串str的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（…）返回的值变成了bye，而字符串本身还是hi。</p><h4 id="Iterable接口与Generator函数"><a href="#Iterable接口与Generator函数" class="headerlink" title="Iterable接口与Generator函数"></a>Iterable接口与Generator函数</h4><p><code>Symbol.iterator</code>方法的最简单实现，还是使用后面要介绍的Generator函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。</p><h3 id="Promise-类型"><a href="#Promise-类型" class="headerlink" title="Promise 类型"></a>Promise 类型</h3><h4 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h4><p>Promise在JavaScript语言早有实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><p>所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。</p><p>Promise对象有以下两个特点。</p><ol><li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ol><p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p><p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p><p>下面代码创造了一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>下面是一个Promise对象的简单例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to = timeout(<span class="number">8000</span>);</span><br><span class="line">to.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//没有输出done前命令行查看to，输出后再查看，两次状态不同</span></span><br></pre></td></tr></table></figure><p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。</p><p>下面是一个用Promise对象实现的Ajax操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p><p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//可以在这里加resolve或reject方法，观察p1和p2的状态</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</p><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(json)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用then方法，依次指定了两个回调函数。第一个then方法的回调函数完成以后，会将返回结果作为参数，传入第二个then方法的回调函数。</p><p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(posts)</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="comment">// 处理前一个回调函数运行时发生的错误</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'发生错误！'</span>, <span class="built_in">error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>如果Promise状态已经变成resolved，再抛出错误是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"ok"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span><span class="params">(comments)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p><p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有调用catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"ok"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定try-catch语句，就冒泡到最外层，成了未捕获的错误。</p><p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="keyword">on</span><span class="params">('unhandledRejection', function <span class="params">(err, p)</span> &#123;</span></span><br><span class="line"><span class="params">  console.error<span class="params">(err.stack)</span></span></span><br><span class="line"><span class="params">&#125;)</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。。</p><p>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>catch方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'oh no'</span>, <span class="built_in">error</span>);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'carry on'</span>, <span class="built_in">error</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">var</span> p = Promise.all([<span class="built_in">p1</span>,<span class="built_in">p2</span>,<span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。（Promise.all方法的参数不一定是数组，但是必须具有Iterable接口，且返回的每个成员都是Promise实例。）</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><ol><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">"/post/"</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">var</span> p = Promise.race([<span class="built_in">p1</span>,<span class="built_in">p2</span>,<span class="built_in">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p><p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure><p>上面代码将jQuery生成deferred对象，转为一个新的Promise对象。</p><p>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p><p>Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。</p><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p><h4 id="Generator函数与Promise的结合"><a href="#Generator函数与Promise的结合" class="headerlink" title="Generator函数与Promise的结合"></a>Generator函数与Promise的结合</h4><p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(value));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。async函数并不属于ES6，而是被列入了ES7，但是traceur、Babel.js、regenerator等转码器已经支持这个功能，转码后立刻就能使用。</p>]]></content>
    
    <summary type="html">
    
      JavaScript 引用类型，Object，Array，Date，RegExp，Function，Number，Boolean，String，Global，Math，Map，Set，WeakMap，WeakSet，Proxy，Reflect，Promise，Iterator
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基本语法</title>
    <link href="http://howiefh.github.io/2015/08/28/javascript-grammar/"/>
    <id>http://howiefh.github.io/2015/08/28/javascript-grammar/</id>
    <published>2015-08-28T04:14:28.000Z</published>
    <updated>2020-05-02T14:28:14.483Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="/2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="/2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记是对《JavaScript 高级程序设计》和 <a href="https://github.com/ruanyf/es6tutorial/tree/5a5f9d8d492d0f925cbb6e09b10ebed9d2078d40" target="_blank" rel="noopener">《ECMAScript 6入门》</a>两本书的总结整理。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个完整的JavaScript实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）</p><p>JavaScript实现了ECMAScript，Adobe ActionScript同样也实现了ECMAScript。</p><a id="more"></a><h1 id="HTML中使用JavaScript"><a href="#HTML中使用JavaScript" class="headerlink" title="HTML中使用JavaScript"></a>HTML中使用JavaScript</h1><h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h2><p>使用<code>&lt;script&gt;</code>元素的方式有两种：直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript文件。 在使用<code>&lt;script&gt;</code>元素嵌入 JavaScript代码时，只须为<code>&lt;script&gt;</code>指定 type 属性。</p><p>包含在<code>&lt;script&gt;</code>元素内部的JavaScript代码将被从上至下依次解释。就拿前面这个例子来说，解释器会解释一个函数的定义，然后将该定义保存在自己的环境当中。在解释器对<code>&lt;script&gt;</code>元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。 在使用<code>&lt;script&gt;</code>嵌入JavaScript代码时，记住不要在代码中的任何地方出现<code>&lt;/script&gt;</code>字符串。例如，浏览器在加载下面所示的代码时就会产生一个错误： <code>&lt;script type=&quot;text/javascript&quot;&gt; function sayScript(){ alert(&quot;&lt;/script&gt;&quot;); } &lt;/script&gt;</code> 因为按照解析嵌入式代码的规则，当浏览器遇到字符串<code>&lt;/script&gt;</code>时，就会认为那是结束的<code>&lt;/script&gt;</code></p><p>如果是在 XHTML文档中，也可以省略前面示例代码中结束的<code>&lt;/script&gt;</code>标签，例如： <code>&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; /&gt;</code> 但是，不能在 HTML文档使用这种语法。原因是这种语法不符合 HTML规范</p><p>为了避免延迟浏览器出现空白，现代Web应用程序一般都把全部JavaScript引用放在<code>&lt;body&gt;</code>元素中页面内容的后面，</p><p>按照惯例，外部 JavaScript文件带有.js扩展名。但这个扩展名不是必需的，因为浏览器不会检查包含 JavaScript的文件的扩展名。这样一来，使用 JSP、PHP或其他服务器端语言动态生成 JavaScript代码也就成为了可能。但是，服务器通常还是需要看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的MIME类型。 需要注意的是，带有 src 属性的<code>&lt;script&gt;</code>元素不应该在其<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间再包含额外的 JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p><p>无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它们依次进行解析</p><p>HTML 4.01为<code>&lt;script&gt;</code>标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置defer</p><p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。 前面提到过，defer 属性只适用于外部脚本文件。这一点在 HTML5 中已经明确规定，因此支持HTML5的实现会忽略给嵌入脚本设置的 defer 属性</p><p>指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p><p>同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照指定它们的先后顺序执行。</p><p>保证让相同代码在 XHTML中正常运行的第二个方法，就是用一个 CData片段来包含 JavaScript代码。在XHTML（XML）中，CData片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。</p><p>但由于所有浏览器都已经支持 JavaScript，因此也就没有必要再使用下面这种格式了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">代码</span></span><br><span class="line"><span class="comment">//--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="嵌入代码和外部文件"><a href="#嵌入代码和外部文件" class="headerlink" title="嵌入代码和外部文件"></a>嵌入代码和外部文件</h2><p>一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript代码。可维护性，可缓存，适应未来</p><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><p>文档模式是：混杂模式（quirks mode）和标准模式（standards mode）。混杂模式会让IE的行为与（包含非标准特性的）IE5相同，而标准模式则让IE的行为更接近标准行为。虽然这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到 JavaScript的解释执行。</p><p>对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，</p><p>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</p><h2 id="noscript"><a href="#noscript" class="headerlink" title="noscript"></a>noscript</h2><p>包含在<code>&lt;noscript&gt;</code>元素中的内容只有在这些情况下才会显示出来：浏览器不支持脚本；浏览器支持脚本，但脚本被禁用。</p><h2 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h2><p>在 Chrome 地址栏中输入 chrome://flags/#enable-javascript-harmony，启用实验性 JavaScript</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="noopener">Firefox 支持的 ECMAScript 6 特性</a></p><p>各个平台对ECMAScript 6的支持情况可以查看 <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">https://kangax.github.io/compat-table/es6/</a></p><p>鉴于现在浏览器并没有完全支持ECMASctipt6，所以可以用ES6的方式编写代码，之后用<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>或谷歌的<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a>进行转码</p><p>另外node中使用可以加参数<code>--harmony</code></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript中的一切（变量、函数名和操作符）都区分大小写</p><p>标识符可以是按照下列格式规则组合起来的一或多个字符：第一个字符必须是一个字母、下划线（<code>_</code>）或一个美元符号（<code>$</code>）；其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如À和Æ），但我们不推荐这样做。 按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写</p><p>C风格的注释，包括单行注释和块级注释</p><p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。最好不省略分号，省略分号，解释器会猜测在什么位置加分号，这样可能会照成与预期不同的结果。如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="comment">//浏览器在这里加入分号，然后1+2就不会被返回了</span></span><br><span class="line">    <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure><p>要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”;</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="通过var声明"><a href="#通过var声明" class="headerlink" title="通过var声明"></a>通过var声明</h3><p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。定义变量应该使用var操作符（不使用var操作符将会定义一个全局变量，这种方式不被推荐），后面跟一个变量名。<code>var message</code>像这样只是声明一个变量，并没有初始化，它的值将是undefined。</p><p>变量声明具有hoisting机制，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="string">"hello"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">"world"</span>;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>执行结果是undefined。这就是因为变量提升，上面的代码实际上会是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v;</span><br><span class="line">v = <span class="string">"hello"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//覆盖全局的v变量，并且没有初始化所以是undefined</span></span><br><span class="line">  <span class="keyword">var</span> v,f;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  v = <span class="string">"world"</span>;</span><br><span class="line">  <span class="comment">//函数表达式不会被提升，但是函数声明会，后面还会讲</span></span><br><span class="line">  f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。</p><h3 id="通过let声明"><a href="#通过let声明" class="headerlink" title="通过let声明"></a>通过let声明</h3><p>ES6中还可以使用let生命变量不同的是let声明的变量只在其所在代码块内有效（意味着ES6支持块级作用域了），并且不会发生“变量提升“现象（注意引号，当进入包含let的作用域，let所声明的变量以创建但是不可以使用，读写都会抛错，直到声明语句）。let不允许在相同作用域内，重复声明同一个变量。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span>()&#123;</span><br><span class="line">  var v = <span class="string">"world"</span><span class="comment">;</span></span><br><span class="line">  if (<span class="name">true</span>) &#123;</span><br><span class="line">    v = 'hello';</span><br><span class="line">    let v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。上面的代码中if块内v通过let声明，不再受外部变量v影响，但是由于在let声明前对v赋值，所以会报错。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p><p>下面两个函数中使用let重复声明变量都会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过const声明"><a href="#通过const声明" class="headerlink" title="通过const声明"></a>通过const声明</h3><p>ECMAScript6中const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。const的作用域与let命令相同：只在声明所在的块级作用域内有效；不存在“变量提升“现象，只能在声明的位置后面使用；也不可重复声明。和Java中final有点类似，不可变是指其指向的对象不可变，但是对象内部属性可以变。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.<span class="keyword">prop</span> = 123;</span><br><span class="line">foo.<span class="keyword">prop</span> <span class="comment">// 123</span></span><br><span class="line">foo = &#123;&#125; <span class="comment">// 不起作用</span></span><br></pre></td></tr></table></figure><p>如果真的想将对象冻结，应该使用Object.freeze方法。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo = <span class="keyword">Object</span>.<span class="keyword">freeze</span>(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>; // 不起作用</span><br></pre></td></tr></table></figure><p>除了将对象本身冻结，对象的属性也应该冻结。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var constantize = (obj) =&gt; &#123;</span><br><span class="line">  <span class="keyword">Object</span>.<span class="keyword">freeze</span>(obj);</span><br><span class="line">  <span class="keyword">Object</span>.keys(obj).<span class="keyword">forEach</span>( (key, <span class="keyword">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( typeof obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>const声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>ES6规定，var和function声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里this即全局变量，在浏览器中就是window，node中是global</span></span><br><span class="line"><span class="keyword">this</span>.a;</span><br><span class="line">let b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>模块中运行的全局变量，都是当前模块的属性，而不是node顶层对象的属性。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，其本质是一组<strong>无序</strong>的名值对组成</p><p>ES6引入了一种新的基本数据类型Symbol，是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</p><p>现在共有七种数据类型：Undefined, Null, Boolean, String, Symbol, Number和Object.</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof的返回值</p><ul><li>“undefined” 如果这个值未定义</li><li>“boolean” 如果这个值是布尔值</li><li>“string” 如果这个值是字符串</li><li>“number” 如果这个值是数值</li><li>“object” 如果这个值是对象或者null</li><li>“function” 如果这个值是函数</li><li>“symbol” 如果这个值是Symbol类型（ES6新增）</li></ul><p><strong>从技术角度讲，函数在ECMAScript中是对象</strong></p><p>typeof操作符的操作数可以是变量（message），也可以是数值字面量。注意，typeof是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。</p><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined</p><p>对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值，但是如果直接访问未声明的变量就会报错了。</p><p>对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型，这也是typeof存在的最大意义了。</p><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>Null类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</p><p>实际上，undefined值是派生自null值的，<code>null == undefined</code>将会返回true。</p><p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null 值就可以知道相应的变量是否已经保存了一个对象的引用</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值，你也可以在任何数据前加<code>!!</code>使其转化为Boolean类型。</p><p>转换规则</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>非空字符串</td><td>“”</td></tr><tr><td>Number</td><td>非零数字值（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>n/a（不适用）</td><td>undefined</td></tr></tbody></table><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>八进制字面量在严格模式下是无效的</p><p>默认情况下，ECMAScript会将那些小数点后面带有 6个零以上的浮点数值转换为以 e表示法表示的数值（例如，0.0000003会被转换成3e-7）</p><p>如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数</p><p>永远不要测试某个特定的浮点数值。 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMAScript并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p><p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法</p><p>isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”</p><p>ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值</p><p>要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 isFinite()函数</p><p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以0会返回NaN（实际上只有0除以0才会返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity），因此不会影响其他代码的执行。 NaN本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身</p><p>有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()（可以在字符串前加<code>+</code>将其转为数字，如<code>+&#39;10&#39;</code>）。第一个函数，即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值</p><p>parseInt这个函数提供第二个参数：转换时使用的基数（即多少进制）。</p><p>parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。</p><p>除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成0。由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>与PHP中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript中的这两种语法形式没有什么区别。</p><p>转义字符被作为一个字符来解析</p><p>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。 多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数</p><p>不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。</p><p>可以使用加号<code>+</code>操作符把某个值与以空字符加在一起来转换为字符串。<br>要把某个值转换为字符串，可以使用加号操作符（3.5 节讨论）把它与一个字符串（””）加在一起。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol，表示独一无二的值。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p>Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>注意，Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p><p>Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以转为字符串。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var sym = <span class="constructor">Symbol('My <span class="params">symbol</span>')</span>;</span><br><span class="line">var a = <span class="string">"your symbol is "</span> + sym; <span class="comment">//报错</span></span><br><span class="line"><span class="constructor">String(<span class="params">sym</span>)</span> <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.<span class="keyword">to</span><span class="constructor">String()</span> <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><p>对象属性名使用Symbol</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [<span class="meta">mySymbol</span>]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; <span class="keyword">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><p>注意，Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  [<span class="string">s</span>](<span class="link">arg</span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">log</span>.levels = &#123;</span><br><span class="line">  <span class="keyword">DEBUG</span>: Symbol(<span class="string">'debug'</span>),</span><br><span class="line">  <span class="keyword">INFO</span>: Symbol(<span class="string">'info'</span>),</span><br><span class="line">  WARN: Symbol(<span class="string">'warn'</span>),</span><br><span class="line">&#125;;</span><br><span class="line">log(<span class="keyword">log</span>.levels.<span class="keyword">DEBUG</span>, <span class="string">'debug message'</span>);</span><br><span class="line">log(<span class="keyword">log</span>.levels.<span class="keyword">INFO</span>, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure><p>还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</p><p><strong>属性名遍历</strong><br>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。</p><p>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。</p><p><strong>Symbol.for</strong>方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a === s2 <span class="comment">// false</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。由于Symbol()写法没有登记机制</p><p><strong>Symbol.keyFor</strong>方法返回一个已登记的Symbol类型值的key。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = <span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>key<span class="constructor">For(<span class="params">s1</span>)</span> <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line">var s2 = <span class="constructor">Symbol(<span class="string">"foo"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>key<span class="constructor">For(<span class="params">s2</span>)</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>Symbol.for</code>为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe = document.create<span class="constructor">Element('<span class="params">iframe</span>')</span>;</span><br><span class="line">iframe.src = <span class="constructor">String(<span class="params">window</span>.<span class="params">location</span>)</span>;</span><br><span class="line">document.body.append<span class="constructor">Child(<span class="params">iframe</span>)</span>;</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.<span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>for('foo')<span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Symbol</span>.</span></span>for('foo') <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>内置的Symbol值</strong></p><p>除了定义自己使用的Symbol值以外，ES6还提供一些内置的Symbol值，指向语言内部使用的方法。</p><p><strong>对象的Symbol.hasInstance属性</strong>，指向一个内部方法。该对象使用instanceof运算符时，会调用这个方法，判断该对象是否为某个构造函数的实例。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><p><strong>对象的Symbol.isConcatSpreadable属性</strong>，指向一个方法。该对象使用Array.prototype.concat()时，会调用这个方法，返回一个布尔值，表示该对象是否可以扩展成数组。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  [<span class="type">Symbol</span>.isConcatSpreadable]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  [<span class="type">Symbol</span>.isConcatSpreadable]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a1 = <span class="keyword">new</span> <span class="type">A1</span>();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">let a2 = <span class="keyword">new</span> <span class="type">A2</span>();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p><strong>对象的Symbol.isRegExp属性</strong>，指向一个方法。该对象被用作正则表达式时，会调用这个方法，返回一个布尔值，表示该对象是否为一个正则对象。</p><p><strong>对象的Symbol.match属性</strong>，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><p><strong>对象的Symbol.replace属性</strong>，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p><p><strong>对象的Symbol.search属性</strong>，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</p><p><strong>对象的Symbol.split属性</strong>，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p><p><strong>对象的Symbol.iterator属性</strong>，指向一个方法，即该对象进行for…of循环时，会调用这个方法，返回该对象的Iterator对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>对象的Symbol.toPrimitive属性</strong>，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><strong>对象的Symbol.toStringTag属性</strong>，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中object后面的那个字符串。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Collection &#123;</span><br><span class="line">  get [<span class="string">Symbol.toStringTag</span>](<span class="link"></span>) &#123;</span><br><span class="line"><span class="code">    return 'xxx';</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var x = new Collection();</span><br><span class="line">Object.prototype.toString.call(x) // "[object xxx]"</span><br></pre></td></tr></table></figure><p><strong>对象的Symbol.unscopables属性</strong>，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Array.prototype[Symbol.unscopables]</span></span><br><span class="line"><span class="string">//</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">copyWithin:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">entries:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">fill:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">find:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">findIndex:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">keys:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span> <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">Object.keys(Array.prototype[Symbol.unscopables])</span></span><br><span class="line"><span class="string">//</span> <span class="string">['copyWithin',</span> <span class="string">'entries'</span><span class="string">,</span> <span class="string">'fill'</span><span class="string">,</span> <span class="string">'find'</span><span class="string">,</span> <span class="string">'findIndex'</span><span class="string">,</span> <span class="string">'keys'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组有6个属性，会被with命令排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.unscopables]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。</p><p>Object每个实例都具有下列属性和方法</p><ul><li>Constructor：保存用于创建当前对象的函数，即构造函数</li><li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，propertyName必须是字符串</li><li>isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型</li><li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。参数必须是字符串</li><li>toLocaleString()：返回对象的字符串表示，与执行环境的地区对应</li><li>toString()：返回对象的字符串表示</li><li>valueOf()：分返回对象的字符串、数值或布尔值表示。通常与toString方法返回值相同。</li></ul><p>在ECMAScript中，（就像 Java 中的 java.lang.Object 对象一样）Object 类型是所有它的实例的基础</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符(++,--,+,-)"></a>一元操作符(<code>++,--,+,-</code>)</h3><p>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p><p>应用于非数值的值时，递增和递减操作符执行前，该值会被转换为数值，然后在执行递增递减。对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。</p><p>在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。如<code>+&#39;10&#39; === 10 //true</code></p><h3 id="位操作符-amp-lt-lt-gt-gt-gt-gt-gt"><a href="#位操作符-amp-lt-lt-gt-gt-gt-gt-gt" class="headerlink" title="位操作符(~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;)"></a>位操作符(<code>~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</code>)</h3><p>负数同样以二进制码存储，但使用的格式是二进制补码</p><p>ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理</p><p>默认情况下，ECMAScript 中的所有整数都是有符号整数</p><p>计算补码的过程</p><p>(1) 求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）； (2) 求二进制反码，即将0替换为1，将1替换为0； (3) 得到的二进制反码加1</p><p>按位非操作的本质：操作数的负值减1</p><p>按位异或操作符由一个插入符号（^）表示</p><p>左移操作会以0来填充空位</p><p>有符号右移在移位过程中，原数值中也会出现空位。只不过空位出现在原数值的左侧、符号位的右侧。而此时ECMAScript会用符号位的值来填充所有空位</p><p>首先，无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示，无符号右移是以0来填充空位，其次，无符号右移操作符会把负数的二进制码当成正数的二进制码</p><h3 id="布尔操作符-amp-amp"><a href="#布尔操作符-amp-amp" class="headerlink" title="布尔操作符(!,&amp;&amp;,||)"></a>布尔操作符(<code>!,&amp;&amp;,||</code>)</h3><p>逻辑非操作符首先会将操作数转换为布尔值然后再计算。参考前面的Boolean转换表</p><p>同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。如<code>!!&#39;&#39; //false</code></p><p>逻辑与和逻辑或在有一个操作数不是布尔值情况下不一定返回布尔值，遵循下列规则：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数</li><li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才返回该对象</li><li>如果两个操作数都是对象，则返回第二个操作数</li><li>如果有一个操作数是null，则返回null</li><li>如果有一个操作数是NaN，则返回NaN</li><li>如果有一个操作数是undefined，则返回undefined</li></ul><p>逻辑或遵循规则</p><ul><li>如果第一个操作数是对象，则返回第一个操作数</li><li>如果第一个操作数是求值结果为false，则返回第二个操作数</li><li>如果两个操作数都是对象，则返回第一个操作数</li><li>如果两个操作数都是null，则返回null</li><li>如果两个操作数都是NaN，则返回NaN</li><li>如果两个操作数都是undefined，则返回undefined</li></ul><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符(*,/,%)"></a>乘性操作符(<code>*,/,%</code>)</h3><p>在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值true将被当作1。</p><p>乘法</p><ul><li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li><li>如果有一个操作数是NaN，则结果是NaN；</li><li>如果是Infinity与0相乘，则结果是NaN；</li><li>如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li><li>如果是Infinity与Infinity相乘，则结果是Infinity；</li><li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li></ul><p>除法</p><ul><li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li><li>如果有一个操作数是NaN，则结果是NaN；</li><li>如果是Infinity被Infinity除，则结果是NaN；</li><li>如果是零被零除，则结果是NaN；</li><li>如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li><li>如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li><li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li></ul><p>求模</p><ul><li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li><li>如果被除数是无穷大值而除数是有限大的数值，返回NaN；</li><li>如果被除数是有限大的数值而除数是零，返回NaN；</li><li>如果Infinity被Infinity除，返回NaN；</li><li>如果被除数是有限大的数值而除数是无穷大值，返回被除数；</li><li>如果被除数是零，返回零；</li><li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li></ul><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符(+,-)"></a>加性操作符(<code>+,-</code>)</h3><p>加法</p><ul><li>如果有一个操作数是NaN，则结果是NaN；</li><li>如果是Infinity加Infinity，则结果是Infinity；</li><li>如果是-Infinity加-Infinity，则结果是-Infinity；</li><li>如果是Infinity加-Infinity，则结果是NaN；</li><li>如果是+0加+0，则结果是+0；</li><li>如果是-0加-0，则结果是-0；</li><li>如果是+0加-0，则结果是+0。</li></ul><p>不过，如果有一个操作数是字符串，那么就要应用如下规则：</p><ul><li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li><li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串”undefined”和”null”。</li></ul><p>减法</p><ul><li>如果两个操作数都是数值，则执行常规的算术减法操作并返回结果；</li><li>如果有一个操作数是NaN，则结果是NaN；</li><li>如果是Infinity减Infinity，则结果是NaN；</li><li>如果是-Infinity减-Infinity，则结果是NaN；</li><li>如果是Infinity减-Infinity，则结果是Infinity；</li><li>如果是-Infinity减Infinity，则结果是-Infinity；</li><li>如果是+0减+0，则结果是+0；</li><li>如果是+0减-0，则结果是-0；</li><li>如果是-0减-0，则结果是+0；</li><li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；</li><li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。</li></ul><h3 id="关系操作符-gt-lt-gt-lt"><a href="#关系操作符-gt-lt-gt-lt" class="headerlink" title="关系操作符(&gt;,&lt;,&gt;=,&lt;=)"></a>关系操作符(<code>&gt;,&lt;,&gt;=,&lt;=</code>)</h3><p>对于字符串实际比较的是两个字符串中对应位置的每个字符的字符编码值</p><ul><li>如果两个操作数都是数值，则执行数值比较。</li><li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li><li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li><li>如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。</li><li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。<br>任何操作数与NaN比较都将返回false</li></ul><p>按照常理，如果一个值不小于另一个值，则一定大于或等于那个值，然而，在与NaN进行比较时，下面两个比较操作的结果都返回了false。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>  <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> res2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符(===,!==,==,!=)"></a>相等操作符(<code>===,!==,==,!=</code>)</h3><p>相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。</p><p>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p><ul><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较； 这两个操作符在进行比较时则要遵循下列规则。</li><li>null和undefined是相等的。</li><li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li><li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li></ul><p>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。</p><h3 id="条件操作符-boolean-expression-true-value-false-value"><a href="#条件操作符-boolean-expression-true-value-false-value" class="headerlink" title="条件操作符(boolean_expression?true_value:false_value)"></a>条件操作符(<code>boolean_expression?true_value:false_value</code>)</h3><p>和Java中一样</p><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符(,)"></a>逗号操作符(<code>,</code>)</h3><p>在用于赋值时，逗号操作符总会返回表达式中的最后一项</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num = (<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>) <span class="comment">//num值为0</span></span><br></pre></td></tr></table></figure><h3 id="赋值操作符-以及-、-等复合赋值运算符"><a href="#赋值操作符-以及-、-等复合赋值运算符" class="headerlink" title="赋值操作符(=以及*=、+=等复合赋值运算符)"></a>赋值操作符(<code>=以及*=、+=等复合赋值运算符</code>)</h3><p>赋值与复合赋值和其他语言无太大区别。</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ECMAScript6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。下面是数组解构赋值的例子</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; // a即为<span class="number">1</span>，b为<span class="number">2</span>，c为<span class="number">3</span></span><br><span class="line">let [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];//third为<span class="string">"baz"</span></span><br><span class="line">let [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; //head为<span class="number">1</span>，tail为[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，...操作符后面再说</span><br><span class="line">var [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>如果解构不成功，变量的值就等于undefined。以下几种情况都属于解构不成功，foo的值都会等于undefined（下面的代码在一些环境下会抛异常）。这是因为原始类型的值，会自动转为对象，比如数值1转为new Number(1)，从而导致foo取到undefined。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo] = [];</span><br><span class="line"><span class="keyword">var</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//x = 1, y = 2</span></span><br><span class="line">let [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];<span class="comment">// a = 1, b = 2, d = 4</span></span><br></pre></td></tr></table></figure><p>如果对undefined或null进行解构，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>这是因为解构只能用于数组或对象。其他原始类型的值都可以转为相应的对象，但是，undefined和null不能转为对象，因此报错。</p><p>解构赋值允许指定默认值。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo = <span class="literal">true</span>] = []; <span class="comment">//foo = true</span></span><br><span class="line">[<span class="symbol">x</span>, <span class="symbol">y</span>=<span class="string">'b'</span>] = [<span class="string">'a'</span>] <span class="comment">// x='a', y='b'</span></span><br><span class="line">[<span class="symbol">x</span>, <span class="symbol">y</span>=<span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>] <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [<span class="symbol">x</span> = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">var</span> [<span class="symbol">x</span> = <span class="number">1</span>] = [null]; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p><p>解构赋值不仅适用于var命令，也适用于let和const命令。对于Set结构（ECMAScript6新增），也可以使用数组的解构赋值。事实上，只要某种数据结构具有Iterable接口，都可以采用数组形式的解构赋值。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* fibs() &#123;</span><br><span class="line">  <span class="built_in">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> [<span class="built_in">first</span>, <span class="built_in">second</span>, <span class="built_in">third</span>, <span class="built_in">fourth</span>, <span class="built_in">fifth</span>, <span class="built_in">sixth</span>] = fibs();</span><br><span class="line"><span class="built_in">sixth</span> // <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面代码中，fibs是一个Generator函数，原生具有Iterable接口。解构赋值会依次从这个接口获取值。</p><p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;<span class="comment">//bar = "bbb", foo = "aaa"</span></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = undefined</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">"Hello"</span>,</span><br><span class="line">    &#123; <span class="symbol">y</span>: <span class="string">"World"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; p: [<span class="symbol">x</span>, &#123; <span class="symbol">y</span> &#125;] &#125; = obj; <span class="comment">//x = "Hello", y = "World"</span></span><br></pre></td></tr></table></figure><p>如果左边变量名和右边属性名不一致</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">"aaa"</span>, <span class="string">bar:</span> <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = "aaa"</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于undefined。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="symbol">x</span> = <span class="number">3</span>&#125; = &#123;<span class="symbol">x</span>: <span class="literal">undefined</span>&#125;; <span class="comment">//x = 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="symbol">x</span> = <span class="number">3</span>&#125; = &#123;<span class="symbol">x</span>: null&#125;; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="symbol">x</span>;</span><br><span class="line">&#123;<span class="symbol">x</span>&#125; = &#123;<span class="symbol">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">(&#123;<span class="symbol">x</span>&#125; = &#123;<span class="symbol">x</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="built_in">log</span>, <span class="built_in">sin</span>, <span class="built_in">cos</span> &#125; = Math;</span><br></pre></td></tr></table></figure><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = 'hello';//<span class="attr">a</span> = <span class="string">"h"</span>, <span class="attr">b</span> = <span class="string">"e"</span>, <span class="attr">c</span> = <span class="string">"l"</span>, <span class="attr">d</span> = <span class="string">"l"</span>, <span class="attr">e</span> = <span class="string">"o"</span></span><br><span class="line"><span class="keyword">let</span> &#123;length : len&#125; = 'hello'; //<span class="attr">len</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>函数的参数也可以使用解构。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add([<span class="symbol">x</span>, <span class="symbol">y</span>])&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="symbol">x</span> + <span class="symbol">y</span>;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function move(&#123;<span class="symbol">x</span> = <span class="number">0</span>, <span class="symbol">y</span> = <span class="number">0</span>&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="symbol">x</span>, <span class="symbol">y</span>];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="symbol">x</span>: <span class="number">3</span>, <span class="symbol">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="symbol">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>注意，指定函数参数的默认值时，不能采用下面的写法。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function move(&#123;<span class="symbol">x</span>, <span class="symbol">y</span>&#125; = &#123; <span class="symbol">x</span>: <span class="number">0</span>, <span class="symbol">y</span>: <span class="number">0</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="symbol">x</span>, <span class="symbol">y</span>];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="symbol">x</span>: <span class="number">3</span>, <span class="symbol">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="symbol">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p><p>变量的解构赋值用途很多。</p><p>1）交换变量的值</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">x</span>, <span class="symbol">y</span>] = [<span class="symbol">y</span>, <span class="symbol">x</span>];</span><br></pre></td></tr></table></figure><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p>2）从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example();</span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p>3）函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(&#123;x, y, z&#125;)</span> </span>&#123; ... &#125;</span><br><span class="line">f(&#123;x:<span class="number">1</span>, y:<span class="number">2</span>, z:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>4）提取JSON数据</p><p>解构赋值对提取JSON对象中的数据，尤其有用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>)</span><br><span class="line">// <span class="number">42</span>, OK, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure><p>上面代码可以快速提取JSON数据的值。</p><p>5）函数参数的默认值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  global = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// ... more config</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p><p>6）遍历Map结构</p><p>任何部署了Iterable接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterable接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="built_in">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.set('<span class="built_in">first</span>', 'hello');</span><br><span class="line"><span class="built_in">map</span>.set('<span class="built_in">second</span>', 'world');</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [<span class="built_in">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span> + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// <span class="built_in">first</span> <span class="built_in">is</span> hello</span><br><span class="line">// <span class="built_in">second</span> <span class="built_in">is</span> world</span><br></pre></td></tr></table></figure><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7）输入模块的指定方法</p><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>if, do-while,while,for,label,break,continue,switch和Java没有太大差别。</p><p>推崇始终使用代码块，即使要执行的只有一行代码</p><p>像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p><p>加标签的语句一般都要与for语句等循环语句配合使用。</p><p>break和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下</p><p>建议如果使用label语句，一定要使用描述性的标签，同时不要嵌套过多的循环</p><p>switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串”10”不等于数值10）。</p><p>首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。</p><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>由于 ECMAScript中不存在块级作用域（ES6已有），因此在循环内部定义的变量也可以在外部访问到</p><p>ECMAScript对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的</p><p>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。</p><p>建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。</p><p>定义with语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var qs = <span class="keyword">location</span>.<span class="keyword">search</span>.substring(<span class="number">1</span>);</span><br><span class="line">var hostName = <span class="keyword">location</span>.hostname;</span><br><span class="line">var url = <span class="keyword">location</span>.href;</span><br></pre></td></tr></table></figure><p>上面几行代码都包含location对象。如果使用with 语句，可以把上面的代码改写成如下所示：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(location)&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> hostName = hostname;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">url</span> = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个重写后的例子中，使用with 语句关联了location 对象。这意味着在with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。 严格模式下不允许使用with语句，否则将视为语法错误</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><p>ES6借鉴C++、Java、C#和Python语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了<code>Symbol.iterator</code>方法，就被视为具有Iterable接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p>for…of循环可以使用的范围包括数组、Set和Map结构及其entries,values,keys方法返回的对象、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</p><p>数组原生具备Iterable接口，for…of循环本质上就是调用<code>Symbol.iterator</code>产生的Iterator对象，可以用下面的代码证明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> iterator  = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];</span><br><span class="line"><span class="keyword">for</span> (a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set和Map结构也原生具有Iterable接口，可以直接使用for…of循环。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = Set([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e of engines) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> Map();</span><br><span class="line">es6.<span class="keyword">set</span>(<span class="string">"edition"</span>, <span class="number">6</span>);</span><br><span class="line">es6.<span class="keyword">set</span>(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.<span class="keyword">set</span>(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, <span class="keyword">value</span>] of es6) &#123;</span><br><span class="line">  console.log(name + <span class="string">": "</span> + <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。</p><p>并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123; <span class="meta">length</span>: 2, 0: <span class="string">'a'</span>, 1: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">for (let <span class="meta">x</span> of arrayLike) &#123;</span><br><span class="line">  console<span class="meta">.log(</span><span class="meta">x</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 正确</span><br><span class="line">for (let <span class="meta">x</span> of <span class="meta">Array</span>.<span class="meta">from</span>(arrayLike)) &#123;</span><br><span class="line">  console<span class="meta">.log(</span><span class="meta">x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过for-of遍历对象，一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">var</span> <span class="built_in">key</span> of Object.keys(someObject)) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span> + <span class="string">": "</span> + someObject[<span class="built_in">key</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象上部署iterator接口的代码，参见本章前面部分。一个方便的方法是将数组的<code>Symbol.iterator</code>属性，直接赋值给其他对象的<code>Symbol.iterator</code>属性。比如，想要让for…of循环遍历jQuery对象，只要加上下面这一行就可以了。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jQuery</span>.proto<span class="keyword">type</span>[<span class="type">Symbol</span>.iterator] =</span><br><span class="line">  <span class="type">Array</span>.proto<span class="keyword">type</span>[<span class="type">Symbol</span>.iterator];</span><br></pre></td></tr></table></figure><p>另一个方法是使用Generator函数将对象重新包装一下。</p><p><strong>与其他遍历语法的比较</strong></p><p>以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; myArray.<span class="built_in">length</span>; <span class="keyword">index</span>++) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(myArray[<span class="keyword">index</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的forEach方法。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span></span> (<span class="keyword">value</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。</p><p>for…in循环可以遍历数组的键名。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var <span class="keyword">index</span> <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(myArray[<span class="keyword">index</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for…in循环有几个缺点。</p><ol><li><p>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</p></li><li><p>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</p></li><li><p>某些情况下，for…in循环会以任意顺序遍历键名。</p></li></ol><p>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p>for…of循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  console.log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li><li>不同用于forEach方法，它可以与break、continue和return配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>严格模式对函数有一些限制：</p><ul><li>不能把函数命名为eval或arguments；</li><li>不能把参数命名为eval或arguments；</li><li>不能出现两个命名参数同名的情况。 如果发生以上情况，就会导致语法错误，代码无法执行。</li></ul><p>return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。</p><p>即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p><p>其实，arguments对象只是与数组类似（它并不是Array的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是arguments[0]，第二个元素是arguments[1]，以此类推），使用length属性来确定传递进来多少个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arguments对象为其内部属性以及函数形式参数创建getter和setter函数。因此改变形参的值会影响arguments对象的值，但是严格模式不允许创建getter和setter方法。</p><p>严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 arguments[1]设置为 10，num2 的值仍然还是 undefined。其次，重写arguments的值会导致语法错误（代码将不会执行）。 ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</p><p><strong>没有重载</strong><br>没有函数签名，真正的重载是不可能做到的。 如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6允许使用“箭头”（=&gt;）定义函数（和Java8中lambda表达式有点类似）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line">(param1, param2, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, paramN) =&gt; expression <span class="comment">// equivalent to:  =&gt; &#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数可以省略圆括号</span></span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有参数，则需要一个圆括号</span></span><br><span class="line"><span class="literal">()</span> =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回一个对象，必须在对象外面加上括号。</span></span><br><span class="line">params =&gt; (&#123;foo: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持Rest参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line"><span class="comment">// 支持变量解构</span></span><br><span class="line">(&#123;param1, param2&#125;) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>箭头函数的一个用处是简化回调函数。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(function (<span class="symbol">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="symbol">x</span> * <span class="symbol">x</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="symbol">x</span> =&gt; <span class="symbol">x</span> * <span class="symbol">x</span>);</span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>箭头函数有几个使用注意点。</p><ul><li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。</li><li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li></ul><p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。下面的代码是一个例子，将this对象绑定定义时所在的对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + <span class="keyword">type</span>  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的init方法中，使用了箭头函数，这导致this绑定handler对象，否则回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p><p>由于this在箭头函数中被绑定，所以不能用call()、apply()、bind()这些方法去改变this的指向。</p><h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</p><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pipeline參數是...funcs，返回值是val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</span></span><br><span class="line"><span class="comment">//addThenMult參數是val，返回值是 funcs.reduce((a, b) =&gt; b(a), val);</span></span><br><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span></span><br><span class="line">  val =&gt; funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line">mult2(plus1(<span class="number">5</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>箭头函数还有一个功能，就是可以很方便地改写λ演算。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// λ演算的写法</span></span><br><span class="line">fix = λf.(λ<span class="symbol">x</span>.f(λv.<span class="symbol">x</span>(<span class="symbol">x</span>)(v)))(λ<span class="symbol">x</span>.f(λv.<span class="symbol">x</span>(<span class="symbol">x</span>)(v)))</span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> fix = f =&gt; (<span class="symbol">x</span> =&gt; f(v =&gt; <span class="symbol">x</span>(<span class="symbol">x</span>)(v)))</span><br><span class="line">               (<span class="symbol">x</span> =&gt; f(v =&gt; <span class="symbol">x</span>(<span class="symbol">x</span>)(v)));</span><br></pre></td></tr></table></figure><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成一个函数的内部状态的遍历器（也就是说，Generator函数是一个状态机）。它每调用一次，就进入下一个内部状态。Generator函数可以控制内部状态的变化，依次遍历这些状态。</p><p>形式上，Generator函数是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态（yield语句在英语里的意思就是“产出”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。</p><p>然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个Iterator对象（该对象同时实现了Iterable接口，并且调用该对象的<code>Symbol.iterator</code>方法返回该对象自身）。</p><p>下一步，必须调用Iterator对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield命令是暂停执行的标记，而next方法可以恢复执行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hw.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="string">'hello'</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">hw.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="string">'world'</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">hw.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="string">'ending'</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">hw.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="string">undefined,</span> <span class="attr">done:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</p><p>总结一下，调用Generator函数，返回一个实现了Iterator接口的对象，用来操作内部指针。以后，每次调用Iterator对象的next方法，就会返回一个实现了IteratorResult接口的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p><h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><p>由于Generator函数返回的Iterator对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。</p><p>Iterator对象next方法的运行逻辑如下。</p><ol><li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li><li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li></ol><p>需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span></span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>  <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，yield后面的表达式<code>123 + 456</code>，不会立即求值，只会在next方法将指针移到这一句时，才会求值。</p><p>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。</p><p>Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  generator.next()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。</p><p>另外需要注意，yield语句不能用在普通函数中，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure><p>上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。</p><p>下面是另外一个例子。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="string">[[2, 3], 4], [5, 6]]</span>;</span><br><span class="line"></span><br><span class="line">var flat = <span class="function"><span class="keyword">function</span>* <span class="params">(a)</span></span>&#123;</span><br><span class="line">  a.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof item !== <span class="string">'number'</span>)&#123;</span><br><span class="line">      <span class="built_in">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var f of flat(arr))&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句。一种修改方法是改用for循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>)&#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><h3 id="与Iterator的关系"><a href="#与Iterator的关系" class="headerlink" title="与Iterator的关系"></a>与Iterator的关系</h3><p>调用Generator函数返回一个Iterator对象。这里的Iterator对象也实现了Iterable接口，Symbol.iterator方法执行后，返回自身。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var i = gen();</span><br><span class="line"></span><br><span class="line">i[<span class="string">Symbol.iterator</span>](<span class="link"></span>) === i // true</span><br></pre></td></tr></table></figure><h3 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h3><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function*</span> <span class="string">f()</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">for(var</span> <span class="string">i=0;</span> <span class="literal">true</span><span class="string">;</span> <span class="string">i++)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">var</span> <span class="string">reset</span> <span class="string">=</span> <span class="string">yield</span> <span class="string">i;</span></span><br><span class="line">    <span class="string">if(reset)</span> <span class="string">&#123;</span> <span class="string">i</span> <span class="string">=</span> <span class="number">-1</span><span class="string">;</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">g</span> <span class="string">=</span> <span class="string">f();</span></span><br><span class="line"></span><br><span class="line"><span class="string">g.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">g.next()</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">g.next(true)</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">done:</span> <span class="literal">false</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p><p>这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>再看一个例子。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* foo(<span class="symbol">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="symbol">y</span> = <span class="number">2</span> * (yield (<span class="symbol">x</span> + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = yield (<span class="symbol">y</span> / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="symbol">x</span> + <span class="symbol">y</span> + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行next方法的时候不带参数，导致y的值等于<code>2 * undefined</code>（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于<code>5 + NaN + undefined</code>，即NaN。</p><p>如果向next方法提供参数，返回结果就完全不一样了。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> it = foo(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">it.<span class="built_in">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">it.<span class="built_in">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">it.<span class="built_in">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码第一次调用next方法时，返回<code>x+1</code>的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回<code>y / 3</code>的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。</p><p>注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</p><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>上面代码使用for…of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。</p><p>下面是一个利用generator函数和for…of循环，实现斐波那契数列的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可见，使用for…of语句时不需要使用next方法。</p><h3 id="throw方法"><a href="#throw方法" class="headerlink" title="throw方法"></a>throw方法</h3><p>Generator函数还有一个特点，它可以在函数体外抛出错误，然后在函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，迭代器i连续抛出两个错误。第一个错误被Generator函数体内的catch捕获，然后Generator函数执行完成，于是第二个错误被函数体外的catch捕获。</p><p>注意，上面代码的错误，是用Iterator对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续执行try语句块了。</p><p>如果Generator函数内部部署了try…catch代码块，那么Iterator对象的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  g.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面代码只输出hello就结束了，因为第二次调用next方法时，遍历器状态已经变成终止了。但是，如果使用throw命令抛出错误，不会影响遍历器状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  g.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都取到了正确的操作。</p><p>这种函数体内捕获错误的机制，大大方便了对错误的处理。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数写一个错误处理语句。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">foo('a', function (<span class="name">a</span>) &#123;</span><br><span class="line">  if (<span class="name">a</span>.error) &#123;</span><br><span class="line">    throw new Error(<span class="name">a</span>.error)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo('b', function (<span class="name">b</span>) &#123;</span><br><span class="line">    if (<span class="name">b</span>.error) &#123;</span><br><span class="line">      throw new Error(<span class="name">b</span>.error)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo('c', function (<span class="name">c</span>) &#123;</span><br><span class="line">      if (<span class="name">c</span>.error) &#123;</span><br><span class="line">        throw new Error(<span class="name">c</span>.error)<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      console.log(<span class="name">a</span>, b, c)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>使用Generator函数可以大大简化上面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> foo(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> foo(<span class="string">'b'</span>);</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> foo(<span class="string">'c'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来，Generator函数内抛出的错误，也可以被函数体外的catch捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x.toUpperCase();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.next(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。</p><p>一旦Generator执行过程中抛出错误，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p><h3 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield*语句"></a><code>yield*</code>语句</h3><p>如果yield命令后面跟的是一个Iterable对象，需要在yield命令后面加上星号，表明它返回的是一个Iterable对象。这被称为<code>yield*</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Hello!'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Bye!'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Greetings!'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Ok, bye.'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "Greetings!</span></span><br><span class="line"><span class="comment">// "Hello!"</span></span><br><span class="line"><span class="comment">// "Bye!"</span></span><br><span class="line"><span class="comment">// "Ok, bye."</span></span><br></pre></td></tr></table></figure><p>上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个Iterable对象，所以要用星号表示。运行结果就是使用一个Iterable对象，遍历了多个Generator函数，有递归的效果。</p><p><code>yield*</code>语句等同于在Generator函数内部，部署一个for…of循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，<code>yield*</code>不过是for…of的一种简写形式，完全可以用后者替代前者。</p><p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持Iterable对象，因此就会遍历数组成员。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">yield</span>* [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen().<span class="built_in">next</span>() // &#123; value:<span class="string">"a"</span>, done:<span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是Iterable对象。</p><p>如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span> *foo();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"v: "</span> + v );</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">//</span></span><br><span class="line">it.next(); <span class="comment">//</span></span><br><span class="line">it.next(); <span class="comment">//</span></span><br><span class="line">it.next(); <span class="comment">// "v: foo"</span></span><br><span class="line">it.next(); <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。</p><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [ <span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> iterTree(tree)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，</span></span><br><span class="line"><span class="comment">// 三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span><span class="params">(left, label, right)</span> </span>&#123;</span><br><span class="line">  this.left = left;</span><br><span class="line">  this.label = label;</span><br><span class="line">  this.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数。</span></span><br><span class="line"><span class="comment">// 由于返回的是一个Iterator对象，所以要用generator函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span><span class="params">(t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.left);</span><br><span class="line">    <span class="keyword">yield</span> t.label;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">(array)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">array</span>.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="keyword">null</span>, <span class="keyword">array</span>[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(<span class="keyword">array</span>[<span class="number">0</span>]), <span class="keyword">array</span>[<span class="number">1</span>], make(<span class="keyword">array</span>[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node of inorder(tree)) &#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure><h3 id="作为对象属性的Generator函数"><a href="#作为对象属性的Generator函数" class="headerlink" title="作为对象属性的Generator函数"></a>作为对象属性的Generator函数</h3><p>如果一个对象的属性是Generator函数，可以简写成下面的形式。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let obj</span> = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。</p><p>它的完整形式如下，与上面的写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数是Generator函数"><a href="#构造函数是Generator函数" class="headerlink" title="构造函数是Generator函数"></a>构造函数是Generator函数</h3><p>这一节讨论一种特殊情况：构造函数是Generator函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数F是一个构造函数，又是一个Generator函数。这时，使用new命令就无法生成F的实例了，因为F返回的是一个Iterator对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'next'</span> <span class="keyword">in</span> (<span class="keyword">new</span> <span class="type">F</span>()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那么，这个时候怎么生成对象实例呢？</p><p>我们知道，如果构造函数调用时，没有使用new命令，那么内部的this对象，绑定当前构造函数所在的对象（比如window对象）。因此，可以生成一个空对象，使用bind方法绑定F内部的this。这样，构造函数调用以后，这个空对象就是F的实例对象了。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;<span class="comment">;</span></span><br><span class="line">var f = F.bind(obj)()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">f.next()<span class="comment">;</span></span><br><span class="line">f.next()<span class="comment">;</span></span><br><span class="line">f.next()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.log(obj)<span class="comment">; // &#123; x: 2, y: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。</p><h3 id="Generator函数推导"><a href="#Generator函数推导" class="headerlink" title="Generator函数推导"></a>Generator函数推导</h3><p>ES7在数组推导的基础上，提出了Generator函数推导（Generator comprehension）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> squared = ( <span class="keyword">for</span> (n <span class="keyword">of</span> generator()) n * n );</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// let squared = Array.from(generator()).map(n =&gt; n * n);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...squared); <span class="comment">// 0 1 4 9 16 25</span></span><br></pre></td></tr></table></figure><p>“推导”这种语法结构，不仅可以用于数组，ES7将其推广到了Generator函数。for…of循环会自动调用Iterator对象的next方法，将返回值的value属性作为数组的一个成员。</p><p>Generator函数推导是对数组结构的一种模拟，它的最大优点是惰性求值，即直到真正用到时才会求值，这样可以保证效率。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  bigArray[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = bigArray.map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first);</span><br></pre></td></tr></table></figure><p>上面例子遍历一个大数组，但是在真正遍历之前，这个数组已经生成了，占用了系统资源。如果改用Generator函数推导，就能避免这一点。下面代码只在用到时，才会生成一个大数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> squared = ( <span class="keyword">for</span> (n <span class="keyword">of</span> bigGenerator()) n * n );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(squared.next());</span><br></pre></td></tr></table></figure><h3 id="Generator与状态机"><a href="#Generator与状态机" class="headerlink" title="Generator与状态机"></a>Generator与状态机</h3><p>Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ticking = <span class="literal">true</span>;</span><br><span class="line">var<span class="built_in"> clock </span>= function() &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking)</span><br><span class="line">    console.log(<span class="string">'Tick!'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    console.log(<span class="string">'Tock!'</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> clock </span>= function*(_) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield _;</span><br><span class="line">    console.log(<span class="string">'Tick!'</span>);</span><br><span class="line">    yield _;</span><br><span class="line">    console.log(<span class="string">'Tock!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p><h3 id="Generator与协程"><a href="#Generator与协程" class="headerlink" title="Generator与协程"></a>Generator与协程</h3><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><ol><li><p><strong>协程与子例程的差异</strong></p><p> 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p> 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p></li><li><p><strong>协程与普通线程的差异</strong></p><p> 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p> 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p> Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p> 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p></li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。</p><p><strong>异步操作的同步化表达</strong></p><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* load<span class="constructor">UI()</span> &#123;</span><br><span class="line">  show<span class="constructor">LoadingScreen()</span>;</span><br><span class="line">  yield load<span class="constructor">UIDataAsynchronously()</span>;</span><br><span class="line">  hide<span class="constructor">LoadingScreen()</span>;</span><br><span class="line">&#125;</span><br><span class="line">var loader = load<span class="constructor">UI()</span>;</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next<span class="literal">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next<span class="literal">()</span></span><br></pre></td></tr></table></figure><p>上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个Iterator对象。下一次对该Iterator对象调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p>Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(<span class="built_in">url</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure><p>上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。</p><p>下面是另一个例子，通过Generator函数逐行读取文本文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">new</span> FileReader(<span class="string">"numbers.txt"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.eof) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.readLine(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打开文本文件，使用yield语句可以手动逐行读取文件。</p><p><strong>控制流管理</strong></p><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1(<span class="name">function</span> (<span class="name">value1</span>) &#123;</span><br><span class="line">  step2(<span class="name">value1</span>, function(<span class="name">value2</span>) &#123;</span><br><span class="line">    step3(<span class="name">value2</span>, function(<span class="name">value3</span>) &#123;</span><br><span class="line">      step4(<span class="name">value3</span>, function(<span class="name">value4</span>) &#123;</span><br><span class="line">        // Do something with value4</span><br><span class="line">      &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>采用Promise改写上面的代码。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Q</span><span class="selector-class">.fcall</span>(step1)</span><br><span class="line">  <span class="selector-class">.then</span>(step2)</span><br><span class="line">  <span class="selector-class">.then</span>(step3)</span><br><span class="line">  <span class="selector-class">.then</span>(step4)</span><br><span class="line">  <span class="selector-class">.then</span>(function (value4) &#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="selector-class">.done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* longRunningTask() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = <span class="function"><span class="keyword">yield</span> <span class="title">step1</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="function"><span class="keyword">yield</span> <span class="title">step2</span>(<span class="params">value1</span>)</span>;</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="function"><span class="keyword">yield</span> <span class="title">step3</span>(<span class="params">value2</span>)</span>;</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="function"><span class="keyword">yield</span> <span class="title">step4</span>(<span class="params">value3</span>)</span>;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，使用一个函数，按次序自动执行所有步骤。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scheduler(longRunningTask());</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> scheduler(<span class="keyword">task</span>) &#123;</span><br><span class="line">  setTimeout(<span class="keyword">function</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> taskObj = <span class="keyword">task</span><span class="variable">.next</span>(<span class="keyword">task</span><span class="variable">.value</span>);</span><br><span class="line">    <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">    <span class="keyword">if</span> (!taskObj<span class="variable">.done</span>) &#123;</span><br><span class="line">      <span class="keyword">task</span><span class="variable">.value</span> = taskObj<span class="variable">.value</span></span><br><span class="line">      scheduler(<span class="keyword">task</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  setTimeout(deferred.resolve, milliseconds);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> delay(<span class="number">100</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。</p><p>多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parallelDownloads</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [text1,text2] = <span class="keyword">yield</span> [</span><br><span class="line">    taskA(),</span><br><span class="line">    taskB()</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(text1, text2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。</p><p><strong>部署Iterable接口</strong></p><p>利用Generator函数，可以在任意对象上部署Iterable接口。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* iter<span class="constructor">Entries(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>keys(obj);</span><br><span class="line">  for (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">    yield <span class="literal">[<span class="identifier">key</span>, <span class="identifier">obj</span>[<span class="identifier">key</span>]</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; foo: <span class="number">3</span>, bar: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">for (<span class="keyword">let</span> <span class="literal">[<span class="identifier">key</span>, <span class="identifier">value</span>]</span> <span class="keyword">of</span> iter<span class="constructor">Entries(<span class="params">myObj</span>)</span>) &#123;</span><br><span class="line">  console.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure><p>上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了Iterable接口。</p><p>下面是一个对数组部署Iterable接口的例子，尽管数组原生具有这个接口。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeSimpleGenerator</span><span class="params">(array)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; <span class="keyword">array</span>.length)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">array</span>[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = makeSimpleGenerator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"></span><br><span class="line">gen.next().value <span class="comment">// 'yo'</span></span><br><span class="line">gen.next().value <span class="comment">// 'ya'</span></span><br><span class="line">gen.next().done  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>作为数据结构</strong></p><p>Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (task <span class="keyword">of</span> <span class="keyword">do</span><span class="constructor">Stuff()</span>) &#123;</span><br><span class="line">  <span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>),</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>),</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。</p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">g(x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面三种情况都不是尾调用</span><br><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">g(x)</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一种情况等同于下面的代码。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(<span class="meta">x</span>) &#123;</span><br><span class="line">  <span class="meta">if</span> (<span class="meta">x</span> &gt; 0) &#123;</span><br><span class="line">    <span class="meta">return</span> m(<span class="meta">x</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">return</span><span class="meta"> n(</span><span class="meta">x</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">(b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数inner用到了，外层函数addOne的内部变量one。</p><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">//120</span></span><br></pre></td></tr></table></figure><p>对上面的递归优化</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> tail<span class="constructor">Factorial(<span class="params">n</span>, <span class="params">total</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n<span class="operator"> === </span><span class="number">1</span>) return total;</span><br><span class="line">  return tail<span class="constructor">Factorial(<span class="params">n</span> - 1, <span class="params">n</span> <span class="operator">*</span> <span class="params">total</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> factorial(n) &#123;</span><br><span class="line">  return tail<span class="constructor">Factorial(<span class="params">n</span>, 1)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span><span class="params">(fn, n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p><p>第二种方法就简单多了，就是采用ES6的函数默认值。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n, total = 1)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p><h2 id="ES7可能支持函數綁定"><a href="#ES7可能支持函數綁定" class="headerlink" title="ES7可能支持函數綁定"></a>ES7可能支持函數綁定</h2><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p><p>函数绑定运算符是并排的两个双引号（::），双引号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。所以，ES6可以在编译时就完成模块编译，效率要比CommonJS模块高。</p><p>模块功能由三个命令构成：export，import和module。export命令用于用户自定义模块，规定对外接口；import命令用于输入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突；module用于整体输入其它模块的提供的功能。</p><p>简单实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.141593</span>;</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">"lib/math"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(math.pi);</span><br></pre></td></tr></table></figure><h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>ES6允许将独立的JS文件作为模块，也就是说，允许一个JavaScript脚本文件调用另一个脚本文件。该文件内部的所有变量、函数、类，外部无法获取，必须使用export关键字输出，一种输出方式是只需要在原有声明变量、函数、类语句前加export，另一种方式是在export后使用大括号指定需要输出的变量、函数、类，并且中间用逗号分隔。下面是一个JS文件，里面使用export命令输出变量。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>另外一种写法。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="comment">&#123;name, year&#125;</span>;</span><br></pre></td></tr></table></figure><p>上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeader</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码属于另一个文件main.js，import命令就用于加载profile.js文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，import语句中要使用as关键字，将输入的变量重命名。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="type">name</span> <span class="keyword">as</span> nickName &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure><p>ES6支持多重加载，即所加载的模块中又加载其他模块。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="type">Vehicle</span> &#125; from './<span class="type">Vehicle</span>';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  move () &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.name + ' is spinning wheels...')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; <span class="type">Car</span> &#125;</span><br></pre></td></tr></table></figure><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure><p>上面代码中，export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，应该采用标准写法。</p><h3 id="模块的整体输入"><a href="#模块的整体输入" class="headerlink" title="模块的整体输入"></a>模块的整体输入</h3><p>下面是一个circle.js文件，它输出两个方法area和circumference。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，main.js文件输入circle.js模块。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="type">circle</span> <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"></span><br><span class="line">console.log("圆面积：" + <span class="type">circle</span>.area(<span class="number">4</span>));</span><br><span class="line">console.log("圆周长：" + <span class="type">circle</span>.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><h3 id="module命令"><a href="#module命令" class="headerlink" title="module命令"></a>module命令</h3><p>module命令可以取代import语句，达到整体输入模块的作用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">module <span class="type">circle</span> <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"></span><br><span class="line">console.log("圆面积：" + <span class="type">circle</span>.area(<span class="number">4</span>));</span><br><span class="line">console.log("圆周长：" + <span class="type">circle</span>.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><p>module命令后面跟一个变量，表示输入的模块定义在该变量上。</p><h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><p>使用import的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="keyword">import</span>-<span class="keyword">default</span>.js</span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); <span class="regexp">//</span> <span class="string">'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码的import命令，可以用任意名称指向<code>export-default.js</code>输出的方法。需要注意的是，这时import命令后面，不使用大括号。</p><p>export default命令用在非匿名函数前，也是可以的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure><p>上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p>下面比较一下默认输出和正常输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"><span class="comment">// 对应的输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用大括号</span></span><br><span class="line"><span class="keyword">import</span> &#123; crc32 &#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"><span class="comment">// 对应的输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export deault</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p><p>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br></pre></td></tr></table></figure><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入jQuery模块为例。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure><p>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName, &#123; otherMethod &#125; <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br></pre></td></tr></table></figure><p>如果要输出默认的值，只需将值跟在<code>export default</code>之后即可。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>42;</span><br></pre></td></tr></table></figure><p><code>export default</code>也可以用来输出类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><h3 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h3><p>模块之间也可以继承。</p><p>假设有一个circleplus模块，继承了circle模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的“export *”，表示输出circle模块的所有属性和方法，export default命令定义模块的默认方法。</p><p>这时，也可以将circle的属性或方法，改名后再输出。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; area <span class="keyword">as</span> circleArea &#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure><p>上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。</p><p>加载上面模块的写法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">module</span> math from <span class="string">"circleplus"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">exp</span> from <span class="string">"circleplus"</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">exp</span>(math.e));</span><br></pre></td></tr></table></figure><p>上面代码中的<code>import exp</code>表示，将circleplus模块的默认方法加载为exp方法。</p><h3 id="ES6模块的转码"><a href="#ES6模块的转码" class="headerlink" title="ES6模块的转码"></a>ES6模块的转码</h3><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。</p><h4 id="ES6-module-transpiler"><a href="#ES6-module-transpiler" class="headerlink" title="ES6 module transpiler"></a>ES6 module transpiler</h4><p><a href="https://github.com/esnext/es6-module-transpiler" target="_blank" rel="noopener">ES6 module transpiler</a>是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。</p><p>首先，安装这个转玛器。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g es6-<span class="class"><span class="keyword">module</span>-<span class="title">transpiler</span></span></span><br></pre></td></tr></table></figure><p>然后，使用<code>compile-modules convert</code>命令，将ES6模块文件转码。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">compile</span>-modules <span class="built_in">convert</span> file1.js file2.js</span><br></pre></td></tr></table></figure><p>o参数可以指定转码后的文件名。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ compile-modules convert -o <span class="keyword">out</span><span class="number">.</span><span class="keyword">js</span> file1<span class="number">.</span><span class="keyword">js</span></span><br></pre></td></tr></table></figure><h4 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h4><p>另一种解决方法是使用<a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener">SystemJS</a>。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。</p><p>使用时，先在网页内载入system.js文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"system.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，使用<code>System.import</code>方法加载模块文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  System<span class="meta">.<span class="meta-keyword">import</span>('./app');</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的<code>./app</code>，指的是当前目录下的app.js文件。它可以是ES6模块文件，<code>System.import</code>会自动将其转码。</p><p>需要注意的是，<code>System.import</code>使用异步加载，返回一个Promise对象，可以针对这个对象编程。下面是一个模块文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/es6-file.js:</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">q</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.es6 = <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在网页内加载这个模块文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">System.import(<span class="string">'app/es6-file'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="keyword">new</span> m.q().es6); <span class="comment">// hello</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h3><p>ECMA-262 第 3 版引入了 try-catch 语句,作为 JavaScript 中处理异常的一种标准方式。基本的语法如下所示,显而易见,这与 Java 中的 try-catch 语句是完全相同的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">error</span>)&#123;</span><br><span class="line"><span class="comment">// 在错误发生时怎么处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说,我们应该把所有可能会抛出错误的代码都放在 try 语句块中,而把那些用于错误处理的代码放在 catch 块中。如果 try 块中的任何代码发生了错误,就会立即退出代码执行过程,然后接着执行 catch 块。此时, catch 块会接收到一个包含错误信息的对象。</p><p>内置使用内置的Error对象具有两个标准属性name和message</p><ul><li><strong>name</strong>：错误名称</li><li><strong>message</strong>：错误提示信息</li><li><strong>stack</strong>：错误的堆栈（非标准属性，但是大多数平台支持）</li></ul><p>使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的函数,该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码,所以大可将对该函数的调用放在 try-catch 语句当中,万一有什么错误发生,也好恰当地处理它们。</p><p>在明明白白地知道自己的代码会发生错误时,再使用 try-catch 语句就不太合适了。例如,如果传递给函数的参数是字符串而非数值,就会造成函数出错,那么就应该先检查参数的类型,然后再决定如何去做。在这种情况下,不应用使用 try-catch 语句。</p><h3 id="finally-子句"><a href="#finally-子句" class="headerlink" title="finally 子句"></a>finally 子句</h3><p>finally都是可选的，但 finally 子句一经使用,其代码无论如何都会执行。换句话说, try 语句块中的代码全部正常执行, finally 子句会执行;如果因为出错而执行了 catch 语句块, finally 子句照样还会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，并不影响return语句要返回的值。</p><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>ECMA-262 定义了下列 7 种错误类型: Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError</p><h4 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h4><p>如果没有把 eval() 当成函数调用,就会抛出EvalError错误。一些浏览器不会正确抛出这个错误。</p><h4 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h4><p>RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">Array(-1)</span>;</span><br><span class="line">(<span class="number">1234</span>).<span class="keyword">to</span><span class="constructor">Exponential(21)</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Array(Number.MAX_VALUE)</span>;</span><br></pre></td></tr></table></figure><h4 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h4><p>ReferenceError是引用一个不存在的变量时发生的错误。另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undefinedVar<span class="comment">;</span></span><br><span class="line">console.log() = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attribute">this</span> = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><p>SyntaxError是解析代码时发生的语法错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>a;</span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p>TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。访问不存在的方法时也会抛出该错误。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">123</span></span><br><span class="line"><span class="type">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br></pre></td></tr></table></figure><h4 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h4><p>URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decodeURI</span><span class="params">(<span class="string">'%2'</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>与 try-catch 语句相配的还有一个 throw 操作符,用于随时抛出自定义错误。抛出错误时,必须要给 throw 操作符指定一个值,这个值是什么类型,没有要求。下列代码都是有效的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="string">name:</span> <span class="string">"JavaScript"</span>&#125;;</span><br></pre></td></tr></table></figure><p>在遇到 throw 操作符时,代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时,代码才会继续执行。</p><p>通过使用某种内置错误类型,可以更真实地模拟浏览器错误。每种错误类型的构造函数接收一个参数,即实际的错误消息。下面是一个例子。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"error"</span>);</span><br></pre></td></tr></table></figure><p>这行代码抛出了一个通用错误,带有一条自定义错误消息。浏览器会像处理自己生成的错误一样,来处理这行代码抛出的错误。</p><p>在创建自定义错误消息时最常用的错误类型是 Error 、 RangeError 、 ReferenceError 和 TypeError 。</p><p>另外,利用原型链还可以通过继承 Error 来创建自定义错误类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span><span class="params">(<span class="keyword">message</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">   this.message = message || "默认信息";</span></span></span><br><span class="line"><span class="function"><span class="comment">   this.name = "UserError";</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">UserError</span>.<span class="title">prototype</span> = <span class="title">new</span> <span class="title">Error</span><span class="params">()</span>;</span></span><br><span class="line">UserError.prototype<span class="function">.<span class="keyword">constructor</span> = <span class="title">UserError</span>;</span></span><br></pre></td></tr></table></figure><p>浏览器对待继承自 Error 的自定义错误类型,就像对待其他错误类型一样。如果要捕获自己抛出的错误并且把它与浏览器错误区别对待的话,创建自定义错误是很有用的。</p><p>要针对函数为什么会执行失败给出更多信息,抛出自定义错误是一种很方便的方式。应该在出现某种特定的已知错误条件,导致函数无法正常执行时抛出错误。换句话说,浏览器会在某种特定的条件下执行函数时抛出错误。</p><p>说到抛出错误与捕获错误,我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的目的在于避免浏览器以默认方式处理它们;而抛出错误的目的在于提供错误发生具体原因的消息。</p><h3 id="错误-error-事件"><a href="#错误-error-事件" class="headerlink" title="错误( error )事件"></a>错误( error )事件</h3><p>任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。在任何 Web 浏览器中, onerror 事件处理程序都不会创建 event 对象,但它可以接收三个参数:错误消息、错误所在的 URL 和行号。多数情况下,只有错误消息有用,因为 URL 只是给出了文档的位置,而行号所指的代码行既可能出自嵌入的 JavaScript 代码,也可能出自外部的文件。</p><p>只要发生错误,无论是不是浏览器生成的,都会触发 error 事件,并执行这个事件处理程序。然后,浏览器默认的机制发挥作用,像往常一样显示出错误消息。像下面这样在事件处理程序中返回false ,可以阻止浏览器报告错误的默认行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line</span>)</span>&#123;</span><br><span class="line">    alert(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过返回 false ,这个函数实际上就充当了整个文档中的 try-catch 语句,可以捕获所有无代码处理的运行时错误。这个事件处理程序是避免浏览器报告错误的最后一道防线,理想情况下,只要可能就不应该使用它。只要能够适当地使用 try-catch 语句,就不会有错误交给浏览器,也就不会触发error 事件。</p><p>图像也支持 error 事件。只要图像的 src 特性中的 URL 不能返回可以被识别的图像格式,就会触发 error 事件。</p><h3 id="常见的错误类型"><a href="#常见的错误类型" class="headerlink" title="常见的错误类型"></a>常见的错误类型</h3><p>错误处理的核心,是首先要知道代码里会发生什么错误。由于 JavaScript 是松散类型的,而且也不会验证函数的参数,因此错误只会在代码运行期间出现。一般来说,需要关注三种错误:</p><ul><li>类型转换错误</li><li>数据类型错误</li><li>通信错误</li></ul><p>类型转换错误发生在使用某个操作符,或者使用其他可能会自动转换值的数据类型的语言结构时。在使用相等(==)和不相等(!=)操作符,或者在 if 、 for 及 while 等流控制语句中使用非布尔值时, 最常发生类型转换错误。强烈建议使用全等操作符（===,!==）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (str3)&#123; <span class="comment">//绝对不要这样!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">if</span> (typeof str3 == <span class="string">"string"</span>)&#123;<span class="comment">//合理的比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 是松散类型的,也就是说,在使用变量和函数参数之前,不会对它们进行比较以确保它们的数据类型正确。为了保证不会发生数据类型错误,只能依靠开发人员编写适当的数据类型检测代码。在将预料之外的值传递给函数的情况下,最容易发生数据类型错误。大体上来说,基本类型的值应该使用 typeof 来检测,而对象的值则应该使用 instanceof 来检测。</p><p>JavaScript 与服务器之间的任何一次通信,都有可能会产生错误。</p><p>第一种通信错误与格式不正确的 URL 或发送的数据有关。最常见的问题是在将数据发送给服务器之前,没有使用 encodeURIComponent() 对数据进行编码。</p><p>对于查询字符串,应该记住必须要使用 encodeURIComponent() 方法。为了确保这一点,有时候可以定义一个处理查询字符串的函数,例如:</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addQueryStringArg</span>(<span class="params">url, name, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">url</span>.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">url</span> += <span class="string">"?"</span>;</span><br><span class="line">    &#125; <span class="title">else</span> &#123;</span><br><span class="line">        <span class="built_in">url</span> += <span class="string">"&amp;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">url</span> += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">url</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分致命错误和非致命错误"><a href="#区分致命错误和非致命错误" class="headerlink" title="区分致命错误和非致命错误"></a>区分致命错误和非致命错误</h3><ul><li>非致命错误<br>  *不影响用户的主要任务;<ul><li>只影响页面的一部分;</li><li>可以恢复;</li><li>重复相同操作可以消除错误。</li></ul></li><li>致命错误<ul><li>应用程序根本无法继续运行;</li><li>错误明显影响到了用户的主要操作;</li><li>会导致其他连带错误。</li></ul></li></ul><h3 id="把错误记录到服务器"><a href="#把错误记录到服务器" class="headerlink" title="把错误记录到服务器"></a>把错误记录到服务器</h3><p>可以把错误回写到服务器，标明来自前端。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> log<span class="constructor">Error(<span class="params">sev</span>, <span class="params">msg</span>)</span>&#123;</span><br><span class="line">    var img = <span class="keyword">new</span> <span class="constructor">Image()</span>;</span><br><span class="line">    img.src = <span class="string">"log.php?sev="</span> + encode<span class="constructor">URIComponent(<span class="params">sev</span>)</span> + <span class="string">"&amp;msg="</span> +</span><br><span class="line">    encode<span class="constructor">URIComponent(<span class="params">msg</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 logError() 函数接收两个参数:表示严重程度的数值或字符串(视所用系统而异)及错误消息。其中,使用了 Image 对象来发送请求,这样做非常灵活,主要表现如下几方面。</p><ul><li>所有浏览器都支持 Image 对象,包括那些不支持 XMLHttpRequest 对象的浏览器。</li><li>可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误,而这种情况下使用XMLHttpRequest 是不行的。</li><li>在记录错误的过程中出问题的概率比较低。大多数 Ajax 通信都是由 JavaScript 库提供的包装函数来处理的,如果库代码本身有问题,而你还在依赖该库记录错误,可想而知,错误消息是不可能得到记录的。</li></ul><h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象（和Java类似）。为此，引用类型的值是按引用访问的</p><p>很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。</p><p>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p><p>我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误</p><p>ECMAScript 中所有函数的参数都是按值传递的</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p><p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部</p><p>如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。</p><p>如果变量的值是一个对象或null，则typeof操作符会返回”object”</p><p>ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应用 typeof 操作符时返回”function”。由于Safari 5及之前版本和Chrome 7及之前版本浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回”function”。在IE和Firefox中，对正则表达式应用typeof会返回”object”。</p><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">'blue'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用域链中包含 swapColors-&gt;changeColor-&gt;window三个对象</p><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>当执行流进入下列任何一个语句时，作用域链就会得到加长：</p><ul><li>try-catch语句的catch块；</li><li>with语句。</li></ul><p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> qs = <span class="string">'?debug=true'</span>;</span><br><span class="line">  <span class="keyword">with</span>(location) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">url</span> = href + qs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">url</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>with 语句接收的是location 对象，因此其变量对象中就包含了location 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端</p><h3 id="JavaScript没有块级作用域"><a href="#JavaScript没有块级作用域" class="headerlink" title="JavaScript没有块级作用域"></a>JavaScript没有块级作用域</h3><ul><li><p>声明变量<br>  在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。</p><p>  严格模式下，初始化未经声明的变量会导致错误。建议还是要用var声明变量，当然可以边声明边初始化。</p></li><li><p>查询标识符<br>  搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。</p><p>  如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符</p>  <figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">'blue'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">color</span> = <span class="string">'red'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">color</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(getColor());</span><br></pre></td></tr></table></figure><p>  位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color变量。</p></li></ul><p>ECMASctipt6中let实际上为JavaScript增加了块级作用域。另外，ES6也规定，函数本身的作用域，在其所在的块级作用域之内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在ES5中运行，会得到“I am inside!”，但是在ES6中运行，会得到“I am outside!”。这是因为ES5存在函数提升，不管会不会进入if代码块，函数声明都会提升到当前作用域的顶部，得到执行；而ES6支持块级作用域，不管会不会进入if代码块，其内部声明的函数皆不会影响到作用域的外部。</p><p>需要注意的是，如果在严格模式下，函数只能在顶层作用域和函数内声明，其他情况（比如if代码块、循环代码块）的声明都会报错。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。</p><p>IE中的COM对象的垃圾收集机制采用的就是引用计数策略，只要在IE中涉及COM对象，就会存在循环引用的问题</p><p>循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。即使A、B不再被使用，但是由于其引用计数不为0，并不会被释放。</p><p>IE9把BOM和DOM对象都转换成了真正的JavaScript对象。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用</p>]]></content>
    
    <summary type="html">
    
      JavaScript 基本语法，ECMAScript 6，语法，变量，数据类型，操作符，语句，函数，箭头函数，Generator函数，尾调用优化，模块，错误处理，基本类型和引用类型，执行环境和作用域，垃圾回收
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java Web 笔记</title>
    <link href="http://howiefh.github.io/2015/08/10/java-web/"/>
    <id>http://howiefh.github.io/2015/08/10/java-web/</id>
    <published>2015-08-10T02:21:47.000Z</published>
    <updated>2020-05-02T14:28:14.482Z</updated>
    
    <content type="html"><![CDATA[<p>这篇记录一下浏览器的请求过程，NIO，字符编码等。</p><a id="more"></a><h2 id="一次请求过程"><a href="#一次请求过程" class="headerlink" title="一次请求过程"></a>一次请求过程</h2><ol><li>浏览器查找域名的 IP 地址<br> 这一步包括 DNS 具体的查找过程，会依次从浏览器缓存、系统缓存、hosts中查找，如果这个过程中有一个地方有结果，查询就结束了，否则向本地域名服务器（LDNS）发送DNS请求（UDP）；如果LDNS没有命中，LDNS直接向Root Server域名服务器请求解析，根域名服务器会返回给LDNS一个所查询的主域名服务器（gTLD Server，.com,.cn,.org等）地址；本地域名服务器再向gTLD服务器发送请求，gTLD服务器会返回此域名对应的Name Server域名服务器（就是你注册的域名服务器）的地址，Name Server会查询存储的域名、IP映射表，然后返回IP和TTL值（这个值用来指定DNS缓存时间）；最后LDNS Server缓存结果并将结果返回给用户。Name Server 也可能会有多级。<br> Linux和Windows下<code>nslookup</code>，Linux下<code>dig</code>可以跟踪DNS解析过程。<br> 如果域名对应的IP地址变了，但是本地还有缓存，会造成访问不了的问题，可以清除缓存的域名，Windows下可以<code>ipconfig /flushdns</code>，Linux下<code>/etc/init.d/nscd restart</code><br> JVM也会缓存DNS解析结果，是通过InetAddress类完成的，这个类最好是使用单例模式，否则没有缓存每次都解析会很耗时。<br> 域名解析方式<ul><li>A 记录，多个域名可以解析岛一个IP地址，不能将一个域名解析到多个IP。如taobao.com指定到110.75.115.70</li><li>MX 记录，Mail Exchange，可将摸个域名下的邮件服务器指向自己的Mail Server。</li><li>CNAME 记录，Canonical Name别名。如指定xxx.github.io的别名xxx.com</li><li>NS 记录，为某域名指定DNS域名服务器。</li><li>TXT 记录，为某个主机或域名设置说明，如xxx.com的TXT记录为XXX的博客</li></ul></li><li>浏览器根据解析得到的IP地址向 web 服务器发送一个 HTTP 请求<br> 通过DNS获取到IP后，目标IP和本机IP分别与子网掩码相与的结果相同，那么它们在一个子网，那么通过ARP协议可以查到目标主机的MAC地址，否则的话，需要通过网关转发，也就是目标MAC是网关的MAC。<br> 请求需要进行编码，生成一个HTTP数据包，依次打上TCP、IP、以太网协议的头部。其中TCP头部主要信息是本机端口和目标端口号等信息，用于标识同一个主机的不同进程，对于HTTP协议，服务器端的默认端口号是80，本机浏览器的话生成一个1024到65535之间的端口号。IP头部主要包含本地IP和目标IP等信息。以太网协议头部主要是双方的MAC地址，目标MAC可以由第一条所诉方法得到。以太网数据包的数据部分，最大长度为1500字节，所以如果IP包太大的话还要拆包，比如IP包5000字节，要分为4包，每一包都包含一个IP头部。<br> 服务器接收请求就要层层解包，对于HTTP包要进行解码，解码时如果编码不对的话就有可能乱码了。</li><li>服务器可能有很多，由哪台来处理请求，还需要负载均衡设备来平均分配所有用户的请求。<br> 负载均衡，即对工作任务进行平衡，分摊到多个操作单元上执行，如图片服务器，应用服务器。可分为链路负载均衡（通过DNS解析成不同IP，用户根据这个IP访问不同的服务器，由于中间没有代理，其特点是快，但是如果某台服务器挂了，可能造成用户无法访问的问题），集群负载均衡，操作系统负载均衡（通过硬中断和软中断实现）<br> 集群负载均衡又分为硬件负载均衡和软件负载均衡，前者非常贵，不嫩能够进行动态扩容，后者成本低，但需要多次代理，增加了延时。</li><li>请求的数据可能存储在分布式缓存或者静态文件再或者数据库中，数据库中。如果请求的数据是静态文件，如果在CDN上，那么CDN服务器又会处理这个用户的请求。如果在数据库中需要向数据库发起查询请求。<br> CDN, Content Delivery Network，一个比喻：CDN = 镜像+缓存+整体负载均衡。用户访问离他最近节点的服务器的内容。通过DNS迭代解析，会返回公司的DNS解析服务器，它又会指定DNS负载均衡器，由其决定用户访问最近的CDN节点。<br> 如果CDN节点没有资源，会去源站请求，然后缓存并返回给用户。</li><li>服务器返回一个 HTTP 响应，如果返回状态码304，浏览器可以直接使用之前缓存的资源。对于内容响应，浏览器需要进行响应解码，渲染显示。<br> 缓存机制<ul><li>Expires，指定一个时间，告诉浏览器，在此之前可以直接使用缓存而不需要请求，当然F5还是会去请求</li><li>Cache-control，更细致的控制缓存，比Expires优先级高。<ul><li>Public指示响应可被任何缓存区缓存。</li><li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li><li>no-cache指示请求或响应消息不能缓存</li><li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li><li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li><li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li><li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li></ul></li><li>Last-Modified/If-Modified-Since，Last-Modified标示这个响应资源的最后修改时间。当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对，判断是否可以继续使用缓存资源。</li><li>Etag/If-None-Match，Etag/If-None-Match也要配合Cache-Control使用。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器根据If-None-Match 决定是否使用缓存。<br>Last-Modified标注的最后修改只能精确到秒级，如果一秒内资源改变了，却还是使用之前的缓存，这时就需要Etag来控制缓存了。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。<br>Ctrl+F5快捷键刷新页面，将会在头部加上<code>Pragma:no-cache</code>和<code>Cache-Control:no-cache</code>，从而获取最新的资源。</li></ul></li></ol><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><p>原来的 I/O 库(在 <code>java.io.*</code>中) 与 NIO 最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。NIO快得多</p><p><code>java.io.*</code> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。</p><p>通道 和 缓冲区 是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。</p><p>NIO中的三个概念Buffer，Channel 和 Selector，下面是一个示例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> void <span class="keyword">selector() </span>throws IOException &#123;</span><br><span class="line">    <span class="keyword">ByteBuffer </span><span class="keyword">buffer </span>= <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword"> </span>   // <span class="number">1</span>. 调用 <span class="keyword">Selector </span>的静态工厂创建一个选择器</span><br><span class="line">    <span class="keyword">Selector </span><span class="keyword">selector </span>= <span class="keyword">Selector.open();</span></span><br><span class="line"><span class="keyword"> </span>   // <span class="number">2</span>. 创建一个服务端的 Channel</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open()<span class="comment">;</span></span><br><span class="line">    // <span class="number">3</span>. 把这个通信信道设置为非阻塞模式</span><br><span class="line">    ssc.configureBlocking(false)<span class="comment">;</span></span><br><span class="line">    // <span class="number">4</span>. 绑定到一个 Socket 对象</span><br><span class="line">    ssc.socket().<span class="keyword">bind(new </span>InetSocketAddress(<span class="number">8080</span>))<span class="comment">;</span></span><br><span class="line">    // <span class="number">5</span>. 把这个通信信道注册到选择器上</span><br><span class="line">    ssc.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_ACCEPT);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">while</span> (true) &#123;</span><br><span class="line">        // <span class="number">6</span>. 调用 <span class="keyword">Selector </span>的 <span class="keyword">selectedKeys </span>方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 <span class="keyword">SelectionKey</span></span><br><span class="line"><span class="keyword"> </span>       Set <span class="keyword">selectedKeys </span>= <span class="keyword">selector.selectedKeys();</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">Iterator </span><span class="keyword">it </span>= <span class="keyword">selectedKeys.iterator();</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">while</span> (<span class="keyword">it.hasNext()) </span>&#123;</span><br><span class="line">            <span class="keyword">SelectionKey </span>key = (<span class="keyword">SelectionKey) </span><span class="keyword">it.next();</span></span><br><span class="line"><span class="keyword"> </span>           <span class="meta">if</span> ((key.readyOps() &amp; <span class="keyword">SelectionKey.OP_ACCEPT) </span>== <span class="keyword">SelectionKey.OP_ACCEPT) </span>&#123;</span><br><span class="line">                // <span class="number">7</span>. 通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据</span><br><span class="line">                ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel()<span class="comment">;</span></span><br><span class="line">                SocketChannel sc = ssChannel.accept()<span class="comment">;//接受到服务端的请求</span></span><br><span class="line">                sc.configureBlocking(false)<span class="comment">;</span></span><br><span class="line">                sc.register(<span class="keyword">selector, </span><span class="keyword">SelectionKey.OP_READ);</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">it.remove();</span></span><br><span class="line"><span class="keyword"> </span>           &#125; <span class="meta">else</span> <span class="meta">if</span> ((key.readyOps() &amp; <span class="keyword">SelectionKey.OP_READ) </span>== <span class="keyword">SelectionKey.OP_READ) </span>&#123;</span><br><span class="line">                SocketChannel sc = (SocketChannel) key.channel()<span class="comment">;</span></span><br><span class="line">                <span class="meta">while</span> (true) &#123;</span><br><span class="line">                    <span class="keyword">buffer.clear();</span></span><br><span class="line"><span class="keyword"> </span>                   // <span class="number">8</span>. 读取的数据是 <span class="keyword">Buffer，这个 </span><span class="keyword">Buffer </span>是我们可以控制的缓冲器</span><br><span class="line">                    int n = sc.read(<span class="keyword">buffer);//读取数据到buffer中，也就是向buffer写数据</span></span><br><span class="line"><span class="keyword"> </span>                   <span class="meta">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>                   &#125;</span><br><span class="line">                    <span class="keyword">buffer.flip();</span></span><br><span class="line"><span class="keyword"> </span>               &#125;</span><br><span class="line">                <span class="keyword">it.remove();</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>Buffer内部实现是一个数组，但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。每个基本类型都有对应的Buffer类。</p><p>为了理解Buffer的工作原理，需要熟悉它的几个属性：</p><ul><li>capacity</li><li>position</li><li>limit</li><li>mark</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Write Mode</span><br><span class="line">+-------------------------+</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">+-------------------------+</span><br><span class="line">           ^             ^</span><br><span class="line">           |<span class="string">             </span>|</span><br><span class="line">        position       limit,capacity</span><br><span class="line">Read Mode</span><br><span class="line">+-------------------------+</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">+-------------------------+</span><br><span class="line"> ^         ^             ^</span><br><span class="line"> |<span class="string">         </span>|<span class="string">             </span>|</span><br><span class="line"> position  limit        capacity</span><br></pre></td></tr></table></figure><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p><ul><li><p>capacity</p><p>  作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p></li><li><p>position</p><p>  当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p><p>  当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p></li><li><p>limit</p><p>  在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p><p>  当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p></li><li><p>mark</p><p>  用于记录当前 position 的前一个位置或者默认是 0</p></li></ul><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer。<code>int bytesRead = inChannel.read(buf); //read into buffer.</code></li><li>通过Buffer的put()方法写到Buffer里。<code>buf.put(127);</code></li></ul><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。<code>int bytesWritten = inChannel.write(buf);</code></li><li>使用get()方法从Buffer中读取数据。<code>byte aByte = buf.get();</code></li></ul><p>Buffer中的几个方法</p><ul><li><p>allocate方法</p><p>  每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。<code>ByteBuffer buf = ByteBuffer.allocate(48);</code></p></li><li><p>flip()方法</p><p>  flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p></li><li><p>rewind()方法</p><p>  Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p></li><li><p>clear()与compact()方法</p><p>  一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p><p>  如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p><p>  如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p><p>  如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p><p>  compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p></li><li><p>mark()与reset()方法</p><p>  通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</p></li></ul><p>参考: <a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">http://ifeve.com/java-nio-all/</a></p><h2 id="几种访问文件的方式"><a href="#几种访问文件的方式" class="headerlink" title="几种访问文件的方式"></a>几种访问文件的方式</h2><ol><li><p>标准访问文件方式 标准访问文件方式就是当应用程序调用read()接口时，操作系统检查内核的高速缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，从磁盘中读取，然后缓存在操作系统的缓存中。</p><p> 写入的方式是，用户的应用程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显式地调用了sync同步命令。</p></li><li><p>直接I/O方式 所谓直接I/O方式就是应用程序直接访问磁盘数据，而不经过操作系统内核数据缓冲区，这样做的目的就是减少一次从内核缓冲区到用户程序缓存的数据复制。这种访问文件的方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。如数据库管理系统中，系统明确地知道应该缓存哪些数据，应该失效哪些数捃，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，这种直接加载会非常缓慢。通常直接I/O与异步I/O结合使用，会得到比较好的性能。</p></li><li><p>同步访问文件方式 同步访问文件方式比较容易理解，就是数据的读取和写入都是同步操作的，它与标准访问文件方式不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功标志。这种访问文件方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。</p></li><li><p>异步访问文件方式 异步访问文件方式就是当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可以明显地提高应用程序的效率，但是不会改变访问文件的效率。</p></li><li><p>内存映射方式 内存映射方式是指操作系统将内存中的某一块区域与磁盘中的文件关联起来，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这两个空间的数据是共享的。</p></li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ul><li>当父类继承Serializable接口，所有子类都可以被序列化。</li><li>子类实现了Serializable接口，父类没有，父类中的属性不能序列化（不报错，数据会丢失），但是子类中属性仍能正确序列化。</li><li>如果序列化的属性是对象，这个对象也必须实现Serializable接口，否则会报错。</li><li>在反序列化时，如果对象的属性有修改或删减，修改的部分属性会丢失，但不会报错。</li><li>在反序列化时，如果seriaIVersionUID被修改，那么反序列化时会失败。</li></ul><p>序列化后很难被其它语言反序列化，所以通常用json，xml这样的结构数据。</p><h2 id="I-O调优"><a href="#I-O调优" class="headerlink" title="I/O调优"></a>I/O调优</h2><h3 id="磁盘-I-O-优化"><a href="#磁盘-I-O-优化" class="headerlink" title="磁盘 I/O 优化"></a>磁盘 I/O 优化</h3><ul><li><p>性能检测</p><p>  我们可以压力测试应用程序看系统的 I/O wait 指标是否正常，例如测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过 25% 的话，I/O 很可能成为应用程序的性能瓶颈。Linux 操作系统下可以通过 iostat 命令查看。</p><p>  通常我们在判断 I/O 性能时还会看另外一个参数就是 IOPS，每个磁盘的 IOPS 通常是在一个范围内，这和存储在磁盘的数据块的大小和访问方式也有关。但是主要是由磁盘的转速决定的，磁盘的转速越高磁盘的 IOPS 也越高。</p><p>  现在为了提高磁盘 I/O 的性能，通常采用一种叫 RAID 的技术，就是将不同的磁盘组合起来来提高 I/O 性能，目前有多种 RAID 技术，每种 RAID 技术对 I/O 性能提升会有不同，可以用一个 RAID 因子来代表，磁盘的读写吞吐量可以通过 iostat 命令来获取，于是我们可以计算出一个理论的 IOPS 值，计算公式如下所以：</p><p>  (磁盘数 * 每块磁盘的 IOPS)/(磁盘读的吞吐量 +RAID 因子 * 磁盘写的吞吐量)=IOPS</p></li><li><p>提升 I/O 性能</p><ul><li>增加缓存，减少磁盘访问次数</li><li>优化磁盘的管理系统，设计最优的磁盘访问策略，以及磁盘的寻址策略，这里是在底层操作系统层面考虑的。</li><li>设计合理的磁盘存储数据块，以及访问这些数据块的策略，这里是在应用层面考虑的。如我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问，还有可以采用异步和非阻塞的方式加快磁盘的访问效率。</li><li>应用合理的 RAID 策略提升磁盘 IO，每种 RAID 的区别我们可以用下表所示：</li></ul></li></ul><table><thead><tr><th>磁盘阵列</th><th>说明</th></tr></thead><tbody><tr><td>RAID 0</td><td>数据被平均写到多个磁盘阵列中，写数据和读数据都是并行的，所以磁盘的 IOPS 可以提高一倍。</td></tr><tr><td>RAID 1</td><td>RAID 1 的主要作用是能够提高数据的安全性，它将一份数据分别复制到多个磁盘阵列中。并不能提升 IOPS 但是相同的数据有多个备份。通常用于对数据安全性较高的场合中。</td></tr><tr><td>RAID 5</td><td>这中设计方式是前两种的折中方式，它将数据平均写到所有磁盘阵列总数减一的磁盘中，往另外一个磁盘中写入这份数据的奇偶校验信息。如果其中一个磁盘损坏，可以通过其它磁盘的数据和这个数据的奇偶校验信息来恢复这份数据。</td></tr><tr><td>RAID 0+1</td><td>如名字一样，就是根据数据的备份情况进行分组，一份数据同时写到多个备份磁盘分组中，同时多个分组也会并行读写。</td></tr></tbody></table><h3 id="网络-I-O-优化"><a href="#网络-I-O-优化" class="headerlink" title="网络 I/O 优化"></a>网络 I/O 优化</h3><p>网络 I/O 优化通常有一些基本处理原则：</p><ul><li>一个是减少网络交互的次数，如静态文件合并，多次数据库查询合并为一次。</li><li>减少网络传输数据量的大小，如 gzip 压缩。还有就是通过设计简单的协议，尽量通过读取协议头来获取有用的价值信息。</li><li>尽量减少编码，尽量直接以字节形式发送。也就是尽量提前将字符转化为字节，或者减少字符到字节的转化过程。</li><li>根据应用场景设计合适的交互方式，所谓的交互场景主要包括同步与异步阻塞与非阻塞方式，下面将详细介绍。</li></ul><table><thead><tr><th>组合方式</th><th>性能分析</th></tr></thead><tbody><tr><td>同步阻塞</td><td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。</td></tr><tr><td>同步非阻塞</td><td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。</td></tr><tr><td>异步阻塞</td><td>这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td></tr><tr><td>异步非阻塞</td><td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。</td></tr></tbody></table><h2 id="Java-io包中的设计模式"><a href="#Java-io包中的设计模式" class="headerlink" title="Java io包中的设计模式"></a>Java io包中的设计模式</h2><ul><li>适配器模式。InputStreamReader。目标接口是Reader。源角色是InputStream</li><li>装饰器模式。FilterInputStream及其子类。</li></ul><p>两者都是包装模式，区别是目的不同，前者意在转换接口，后者重在强化功能。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li>ASSIC，单字节编码，共有128个字符，一字节可以容纳256个，所以其最高位为0，除去第[0,32]以及第127为控制字符，有效字符为94个。</li><li>ISO-8859-1，单字节编码。又称Latin-1，是对ASSIC的扩展，在一些软件或协议中是默认编码，通常如果有<code>?</code>问号这样的乱码，很可能就是由于这个编码。</li><li>GB2312，对于落在ASSIC范围内的编码还是使用单字节，其它双字节编码。使用二位区位编号，行为区，列为位，总计94x94个编号，区位均从1起始，一个字符用区码加位码编号，区码、位码各加32就是国标码，国标码区位各加128就是机内码，区位码区位各加0XA0就是机内码了。机内码是实际使用的编码。</li><li>GBK，单字节，双字节变长编码，对于ASSIC码是单字节。是对GB2312的扩展，K即扩展。UTF-16和GB开头的编码转换需要通过查表，而Unicode的几种编码之间有相应的转换规则。</li><li>GB18030，可能单字节、双字节、四字节编码，兼容GB2312，部分兼容GBK</li><li>UTF-8，1到4个字节。</li><li>UTF-16，两个字节或四个字节。两个字节时基本可以认为和UCS-2等同。</li><li>UTF-32，四个字节定长编码。可以认为和UCS-4等同。</li></ul><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><blockquote><p>Unicode的核心就是为每个字符提供唯一一个数字编号。Unicode provides a unique number for every character.</p></blockquote><p>后三个都是Unicode字符集中的编码。字符集和编码几乎都是一对一的，但是Unicode是个例外，Unicode只是给出了个字符集，每个字符有对应的码点（code point），比如美元<code>$</code>符号对应码点是<code>U+0024</code>，至于怎么对这个码点编码这就是UTF-X（Unicode (or UCS) Transformation Format）的事情了，这个X代表了码元（code unit）是多少位的，比如UTF-8的码元是8bits也就是一个字节，一种转换格式可以有整数个码元，比如UTF-16码元是16位，两个字节，其可以包含一个或两个码元，也就是两个或四个字节。</p><p>码点范围是U+0000<del>U+10FFFF（表示为4到6个16进制数，不足4位补零，超过4位，是多少位就还是多少位），最多用到21比特位，可以表示(1+2^4)x2^16个字符，可分为17个部分，每个部分称为平面，平面从0起始，第一个平面即是BMP（Basic Multilingual Plane 基本多语言平面，也叫Plane 0，它的码点范围是U+0000</del>U+FFFF），UTF-16用两个字节表示BMP平面的字符。后续的16个平面称为SP（Supplementary Planes）。显然，这些码点已经是超过U+FFFF的了，所以已经超过了16位空间的理论上限，对于这些平面内的字符，UTF-16采用了四字节编码。BMP平面从D8~DF都是空白的。其中D800–DBFF属于高代理区（High Surrogate Area），DC00–DFFF属于低代理区（Low Surrogate Area），各自的大小均为4×256=1024。2^10x2^10=2^4x2^16正好可以表示后面的16个平面，UTF-16就是使用代理对表示BMP平面外的字符的。</p><p>还有一个代码页的概念，配置vim编码时碰到过一个cp936的，这个就是一个代码页（code page），可以说代码页是编码的一个别名，如cp936和GBK其实就是一个东西。cp65001和UTF-8也是一个东西。Windows命令窗口可以用<code>chcp 65001</code>改变其编码。</p><p><strong>码点到UTF-8的转换</strong></p><p>以<code>你</code>字为例，其码点是<code>U+4F60</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100</span> <span class="number">1111</span>   <span class="number">0110</span> <span class="number">0000</span>   码点的二进制形式</span><br><span class="line"><span class="number">0100</span> <span class="number">111101</span> <span class="number">100000</span>      按<span class="number">4</span>+<span class="number">6</span>+<span class="number">6</span>分组</span><br><span class="line"><span class="number">1110</span>XXXX <span class="number">10</span>XXXXXX <span class="number">10</span>XXXXXX  UTF<span class="number">-8</span>三字节模板</span><br><span class="line"><span class="number">11100100</span> <span class="number">10111101</span> <span class="number">10100000</span>  替换有效编码位</span><br><span class="line">E4 BD A0</span><br></pre></td></tr></table></figure><p>UTF-8 有以下编码规则：</p><ul><li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASSIC 字符（00 - 7F）。可见，所有 ASSIC 编码已经是 UTF-8 了。</li><li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li><li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li></ul><p><strong>码点到UTF-16的转换</strong></p><ol><li>BMP中直接对应，无须转换；</li><li>增补平面SP中，则需要做相应的计算。<br> 拿到一个码点，先减去10000(16)，再除以400(16)（=1024(10)）就是所在行了，余数就是所在列了，再加上行与列所在的起始值，就得到了代理对了。<code>(16)</code>表示是16位。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lead = (码点 - <span class="number">10000</span>(<span class="number">16</span>)) ÷ <span class="number">400</span>(<span class="number">16</span>) + D800</span><br><span class="line">Trail = (码点 - <span class="number">10000</span>(<span class="number">16</span>)) % <span class="number">400</span>(<span class="number">16</span>) + DC00</span><br></pre></td></tr></table></figure><p>下面以前面的U+1D11E具体示例了代理对的（16进制）计算：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lead = (<span class="number">1</span>D11E - <span class="number">10000</span>) ÷ <span class="number">400</span> + DB00 = D11E ÷ <span class="number">400</span> + D800 = <span class="number">34</span> + D800 = D834</span><br><span class="line">Trail = (<span class="number">1</span>D11E - <span class="number">10000</span>) % <span class="number">400</span> + DC00 = D11E % <span class="number">400</span> + DC00 = <span class="number">11</span>E + DC00 = DD1E</span><br></pre></td></tr></table></figure><p><strong>码点到UTF-32无需转换，补零就行了</strong></p><p>记事本中可以保存Unicode编码其实就是UTF-16，默认是小端编码。另外记事本保存UTF-8默认是带BOM的。</p><p>提到小端编码了，顺便说说大小端编码的问题，也就是字节序的问题，涉及到的是多字节数据存储时的字节顺序问题（对于单字节数据来说，一般不需要考虑各比特位的存储顺序问题。UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，就要考虑字节序了）。大端序是指数据的高字节保存在内存的低地址中，小端序是指数据的高字节保存在内存的高地址中。按照自左向右的顺序，以左为先，把先出现的当做低地址。对于UTF-16的一个码元来说比如<code>0x597D</code>这两个字节，大端表示的话就是<code>0x597D</code>，小端表示的话是<code>0x7D59</code>。可以看出大端表示法跟我们的书写习惯是一致的，而小端的话对我们来说有点不自然，但对于电脑存储可能就比较自然了，因为它的高低字节和内存的高低地址正好就是对应的。</p><p>说完大小端再说说BOM，其全称是Byte Order Marker，从全称，我们就知道它是干嘛用的了，标识字节序的。它对应Unicode中的<code>U+FEFF</code>码点，对于UTF-16来说，如果开头是<code>FEFF</code>那就是大端序了，如果是<code>FFFE</code>那就是小端序。</p><p>关于编码更详细的内容可以看这个系列博客<a href="http://my.oschina.net/goldenshaw/blog?catalog=536953" target="_blank" rel="noopener">http://my.oschina.net/goldenshaw/blog?catalog=536953</a></p><h3 id="Java中String-的相关方法"><a href="#Java中String-的相关方法" class="headerlink" title="Java中String 的相关方法"></a>Java中String 的相关方法</h3><p>getBytes有四个重载方法，有一个是过时的，总的说来就是两种，指定了编码的和没有指定编码的，没有指定编码，它会使用平台的缺省编码，这个平台是指JVM，如果JVM启动时没有指定编码，那么这个缺省编码也就是操作系统的缺省编码了。这个方法的作用是把字符串按指定的编码方式编码为字节数组，其实质应该就是将内存中存储的UTF-16的编码数组转换为其它编码方式的字节数组。</p><p>length方法，这个方法是常用的一个方法，它返回字符串的长度，这个长度不是字符的个数，而是码元的个数，在Java里也就是UTF-16的码元个数了。像charAt, substring这些方法，其参数实际也是基于码元的概念而不是字符。不过呢，大多的字符在BMP平面就能表示了，所以平时接触到的可能这个码元个数和字符个数都是对应的。</p><p>下面看些具体的例子</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">final String interesting = <span class="string">"hi你好"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(interesting.length<span class="literal">()</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">final byte<span class="literal">[]</span> utf8Bytes = interesting.get<span class="constructor">Bytes(<span class="string">"UTF-8"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出8，每个英文字母占一个字节，每个汉字3个字节</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(utf8Bytes.length);</span><br><span class="line"><span class="comment">//68 69 E4 BD A0 E5 A5 BD</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">utf8Bytes</span>)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(utf8Bytes.length);</span><br><span class="line">final byte<span class="literal">[]</span> utf16Bytes = interesting.get<span class="constructor">Bytes(<span class="string">"UTF-16"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出10，每个字符2个字节，外加BOM两个字节</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(utf16Bytes.length);</span><br><span class="line"><span class="comment">//输出中开头的FE FF就是传说中的BOM(Byte Order Marker用来表明大端还是小端的)了，其实就是U+FEFF码点</span></span><br><span class="line"><span class="comment">//EF BB BF 是这一码点在UTF-8下的编码，UTF-8只有大端，没有大小端之分，所以不建议保存时带BOM，对于不支持BOM的软件会带来未知问题</span></span><br><span class="line"><span class="comment">//FE FF 00 68 00 69 4F 60 59 7D</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">utf16Bytes</span>)</span>);</span><br><span class="line">final byte<span class="literal">[]</span> utf16beBytes = interesting.get<span class="constructor">Bytes(<span class="string">"UTF-16BE"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出8，每个字符2个字节，UTF-16大端编码，可以看到后面输出的结果除了没有BOM标记之外和UTF-16是一样的。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(utf16beBytes.length);</span><br><span class="line"><span class="comment">//00 68 00 69 4F 60 59 7D</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">utf16beBytes</span>)</span>);</span><br><span class="line">final byte<span class="literal">[]</span> utf32Bytes = interesting.get<span class="constructor">Bytes(<span class="string">"UTF-32"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出16，每个字符4个字节，UTF-32其实也是可以有大小端之分的</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(utf32Bytes.length);</span><br><span class="line"><span class="comment">//00 00 00 68 00 00 00 69 00 00 4F 60 00 00 59 7D</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">utf32Bytes</span>)</span>);</span><br><span class="line">final byte<span class="literal">[]</span> isoBytes = interesting.get<span class="constructor">Bytes(<span class="string">"ISO-8859-1"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出4，两个汉字超出它的表示范围，它不认识，然后就被编程`?`了</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(isoBytes.length);</span><br><span class="line"><span class="comment">//68 69 3F 3F</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">isoBytes</span>)</span>);</span><br><span class="line">final byte<span class="literal">[]</span> gb2312Bytes = interesting.get<span class="constructor">Bytes(<span class="string">"GB2312"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出6</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(gb2312Bytes.length);</span><br><span class="line"><span class="comment">//68 69 C4 E3 BA C3</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">gb2312Bytes</span>)</span>);</span><br><span class="line">final byte<span class="literal">[]</span> gbkBytes = interesting.get<span class="constructor">Bytes(<span class="string">"GBK"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出6， 是对GB2312的扩展，所以这个编码一样</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(gbkBytes.length);</span><br><span class="line"><span class="comment">// 68 69 C4 E3 BA C3</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">gbkBytes</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s是增补平面的一个字符，UTF-16需要四个字节存，这里如果给char类型赋值，会报错，char总是两个字节的，很显然它存不下</span></span><br><span class="line"><span class="comment">// char c = '?';</span></span><br><span class="line">String s = <span class="string">"?"</span>;</span><br><span class="line"><span class="comment">//Returns the length of this string. The length is equal to the number of Unicode code units in the string.</span></span><br><span class="line"><span class="comment">//上面是length方法的注释，可以看到这个字符串长度，实际是码元的个数，而Java是用UTF-16存储字符串的，所以这里就是UTF-16的码元个数了，即2</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s.length<span class="literal">()</span>); <span class="comment">//2  输出的是码元数目，也就是UTF-16码元的数目</span></span><br><span class="line"><span class="comment">//下面的两个方法其实也是针对码元的，如果是按字符算的话，s只有一个字符，下面两个方法可就都越界了，事实上它们并没有</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s.<span class="built_in">char</span><span class="constructor">At(1)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s.substring(<span class="number">1</span>));</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s.equals(<span class="string">"\uD869\uDEA5"</span>));<span class="comment">//s的转义表示，就是UTF-16的代理对</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s.code<span class="constructor">PointAt(0)</span><span class="operator"> == </span><span class="number">0x2A6A5</span>);<span class="comment">//s码点是U+2A6A5</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">s</span>.<span class="params">getBytes</span>(<span class="string">"utf-16be"</span>)</span>)); <span class="comment">//D8 69 DE A5</span></span><br><span class="line"><span class="comment">//下面是一个组合字符，神一样的存在</span></span><br><span class="line">s = <span class="string">"???????????????????????????????????????"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(s.length<span class="literal">()</span>); <span class="comment">//39,意味着有39个码元！但是显示的确实是一个字符</span></span><br><span class="line"><span class="comment">//0E 2A 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">s</span>.<span class="params">getBytes</span>(<span class="string">"utf-16be"</span>)</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个汉字变成了三个字符，因为UTF-8对汉字编码是三字节，而GBK是两个字节，其实就是六个字节的两种组合</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"UTF-8"</span>)</span>,<span class="string">"GBK"</span>));</span><br><span class="line"><span class="comment">//两个汉字变成了六个字符，因为UTF-8对汉字编码是三字节，而ISO-8859-1是单字节编码，两个三字节被当做六个单字节来解了</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"UTF-8"</span>)</span>,<span class="string">"ISO-8859-1"</span>));</span><br><span class="line"><span class="comment">//两个汉字变成了两个'?'，因为ISO-8859-1是单字节编码，不认识的都按3F也就是'?'编码，解码时GBK也就当是问号了</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"ISO-8859-1"</span>)</span>,<span class="string">"GBK"</span>));</span><br><span class="line"><span class="comment">//两个汉字变成了四个字符，因为GBK对汉字编码是两字节，而ISO-8859-1是单字节编码，两个双字节被当做四个单字节来解了</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>));</span><br><span class="line"><span class="comment">// 68 69 C4 E3 BA C3 -&gt; 68 69 3F 3F 3F 3F</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">to</span><span class="constructor">Hex(<span class="params">new</span> String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>).get<span class="constructor">Bytes(<span class="string">"GBK"</span>)</span>));</span><br><span class="line"><span class="comment">//两个汉字变成了四个'?'，涉及两次编解码，这里有个疑问，第一次按GBK编码再按ISO-8859-1解码，字节数没变每个字节里存储的内容没变还是68 69 C4 E3 BA C3</span></span><br><span class="line"><span class="comment">//为什么再拿GBK编码后面就变成3F了，GBK不是按照C4E3 BAC3这么分组编码的？我觉得应该跟字符串的存储有关系，getBytes这个方法其实还是从UTF-16到其它编码的一个转换过程</span></span><br><span class="line"><span class="comment">//C4 E3 BA C3 存储可能是00C4 00E3 00BA 00C3然后00C4是什么GBK没有对应的编码，然后就又3F了</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">new</span> String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>).get<span class="constructor">Bytes(<span class="string">"GBK"</span>)</span>,<span class="string">"GBK"</span>));</span><br><span class="line"><span class="comment">//下面这个结果就是正确的了，第二次编码时，数组的内容还是68 69 C4 E3 BA C3 再按GBK解码自然能够把C4E3 BAC3转为对应的汉字</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">String(<span class="params">new</span> String(<span class="params">interesting</span>.<span class="params">getBytes</span>(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>).get<span class="constructor">Bytes(<span class="string">"ISO-8859-1"</span>)</span>,<span class="string">"GBK"</span>));</span><br></pre></td></tr></table></figure><h3 id="Java-Web-涉及到的编码"><a href="#Java-Web-涉及到的编码" class="headerlink" title="Java Web 涉及到的编码"></a>Java Web 涉及到的编码</h3><h4 id="URL中的编码"><a href="#URL中的编码" class="headerlink" title="URL中的编码"></a>URL中的编码</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> +-----------------URL-------------------------+</span><br><span class="line">/                      +---------URI------------\</span><br><span class="line">                      /                          \</span><br><span class="line">http://localhost:8080/examples/servlets/servlet/你好?param=你好<span class="comment">#h1</span></span><br><span class="line"> ^       ^       ^     ^            ^            ^         ^</span><br><span class="line"> |<span class="string">       </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">            </span>|<span class="string">            </span>|<span class="string">         </span>|</span><br><span class="line">scheme domain  port context path  servlet path path info  query string</span><br></pre></td></tr></table></figure><p>Port 对应在 Tomcat 的 <code>&lt;Connector port=&quot;8080&quot;/&gt;</code> 中配置，而 Context Path 在 <code>&lt;Context path=&quot;/examples&quot;/&gt;</code> 中配置，Servlet Path 在 Web 应用的 web.xml 中的<code>&lt;url-pattern&gt;</code> 中配置，PathInfo 是我们请求的具体的 Servlet，QueryString 是要传递的参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlets/servlet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>tomcat服务器对URL解码使用的编码是由 <code>&lt;Connector URIEncoding=&quot;UTF-8&quot;/&gt;</code>指定的，而对于QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要设置 connector 的 <code>&lt;Connector URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;</code> 中的 useBodyEncodingForURI 设置为 true。</p><h4 id="Header中的编码"><a href="#Header中的编码" class="headerlink" title="Header中的编码"></a>Header中的编码</h4><p>对 Header 中的项进行解码是在调用 request.getHeader 是进行的，如果请求的 Header 项没有解码则调用 MessageBytes 的 toString 方法，这个方法将从 byte 到 char 的转化使用的默认编码也是 ISO-8859-1，而我们也不能设置 Header 的其它解码格式，所以如果你设置 Header 中有非 ASSIC 字符解码肯定会有乱码。</p><p>我们在添加 Header 时也是同样的道理，不要在 Header 中传递非 ASSIC 字符，如果一定要传递的话，我们可以先将这些字符用 org.apache.catalina.util.URLEncoder 编码然后再添加到 Header 中。</p><p>几个例子：</p><p>Cookie: 如果包含了中文，而且没有编码，你可能会看到异常：java.lang.IllegalArgumentException: Control character in cookie value or attribute.</p><p>Location: 这个字段一般可能不是我们直接设置，但是当重定向的时候比如在Controller里，你写了<code>return &quot;redirect:/index?cnParam=中文&quot;;</code>，这时实际会设置Location头部，如果对中文没有进行编码处理，就会有乱码的问题出现了。如果是参数中包含中文，除了对链接调用<code>URLEncoder.encode</code>进行编码，还可以<code>attributes.addAttribute(&quot;cnParam&quot;, &quot;中文&quot;);return &quot;redirect:/index&quot;;</code>，这样Spring框架会进行Url编码，具体代码可以参考<code>org.springframework.web.servlet.view.RedirectView#appendQueryProperties</code>。（Tomcat7即使不对Url编码也没有问题，但是Tomcat6.0.29就不行，所以如果有中文最好还是编码一下吧）</p><p>Content-Disposition: 一般是上传下载文件时候会遇到编码的问题，可以参考<a href="https://blog.robotshell.org/2012/deal-with-http-header-encoding-for-file-download/" target="_blank" rel="noopener">正确处理下载文件时HTTP头的编码问题（Content-Disposition）</a></p><h4 id="POST表单中的编码"><a href="#POST表单中的编码" class="headerlink" title="POST表单中的编码"></a>POST表单中的编码</h4><p>POST 表单提交的参数的解码是在第一次调用 request.getParameter 发生的，POST 表单参数传递方式与 QueryString 不同，它是通过 HTTP 的 BODY 传递到服务端的。当我们在页面上点击 submit 按钮时浏览器首先将根据 ContentType 的 Charset 编码格式对表单填的参数进行编码然后提交到服务器端，在服务器端同样也是用 ContentType 中字符集进行解码。所以通过 POST 表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过 request.setCharacterEncoding(charset) 来设置，这个调用一定要在第一次调用 request.getParameter前调用。</p><p>另外针对 multipart/form-data 类型的参数，也就是上传的文件编码同样也是使用 ContentType 定义的字符集编码，值得注意的地方是上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及到字符编码，而真正编码是在将文件内容添加到 parameters 中，如果用这个编码不能编码时将会用默认编码 ISO-8859-1 来编码。</p><h4 id="HTTP-BODY-的编解码"><a href="#HTTP-BODY-的编解码" class="headerlink" title="HTTP BODY 的编解码"></a>HTTP BODY 的编解码</h4><p>当用户请求的资源已经成功获取后，这些内容将通过 Response 返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码。这个过程的编解码字符集可以通过 response.setCharacterEncoding 来设置，它将会覆盖 request.getCharacterEncoding 的值，并且通过 Header 的 Content-Type 返回客户端，浏览器接受到返回的 socket 流时将通过 Content-Type 的 charset 来解码，如果返回的 HTTP Header 中 Content-Type 没有设置 charset，那么浏览器将根据 Html 的 <code>&lt;meta HTTP-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot; /&gt;</code> 中的 charset 来解码。如果也没有定义的话，那么浏览器将使用默认的编码来解码。</p><h4 id="JS中的编码"><a href="#JS中的编码" class="headerlink" title="JS中的编码"></a>JS中的编码</h4><p>外部引入js文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/js/all.js"</span> <span class="attr">charset</span>=<span class="string">"gbk"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对URL编码</p><ul><li>escape已废弃</li><li>encodeURI</li><li>encodeURIComponent 和encodeURI方法的区别是编码更加彻底，比如像<code>:</code>,<code>#</code>,<code>?</code>这种字符也会被编码。Java中的URLEncoder和URLDecoder与encodeURIComponent和decodeURIComponent是基本对应的。</li></ul><p>如果没有指定字符集，那么将使用当前页面的编码。</p><h4 id="其它需要编码的地方"><a href="#其它需要编码的地方" class="headerlink" title="其它需要编码的地方"></a>其它需要编码的地方</h4><p>xml 文件可以通过设置头来制定编码格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br></pre></td></tr></table></figure><p>Velocity 模版设置编码格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services.VelocityService.input.encoding</span>=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>JSP 设置编码格式：</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby">@page contentType=<span class="string">"text/html; charset=UTF-8"</span></span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure><p>访问数据库都是通过客户端 JDBC 驱动来完成，用 JDBC 来存取数据要和数据的内置编码保持一致，可以通过设置 JDBC URL 来制定如 MySQL：url=”jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK”。</p><h2 id="常见加载器类错误分析"><a href="#常见加载器类错误分析" class="headerlink" title="常见加载器类错误分析"></a>常见加载器类错误分析</h2><ul><li><p>ClassNotFoundException<br>  这个异常通常发生在<strong>显式加载类</strong>的时候，例如，用如下方式调用加载一个类时就报这个错了：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFoundException</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"NotFoundException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  显式加载一个类通常有如下方式：</p><ul><li><p>通过类Class中的forName()方法。</p></li><li><p>通过类 ClassLoader 中的 loadClass()方法。</p></li><li><p>通过类 ClassLoader 中的 findSystemClass()方法。</p><p>出现这类错误也很好理解，就是当JVM要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码，也就是这个文件并不存在。解决的办法就是检査在当前的classpath目录下有没有指定的文件存在。如果不知道当前的classpath路径,就可以通过如下命令来获取：<code>this.getClass().getClassLoader().getResource(&quot;&quot;).toString()</code></p></li></ul></li><li><p>NoClassDefFoundError<br>  NoClassDefFoundError是另外一个经常遇到的异常，这个异常在第一次使用命令行执行Java类时很可能会碰到，如： <code>java -cp example.jar Example</code></p><p>  报错是因为你在命令行中没有加类的包名，正确的写法是这样的： <code>java -cp example.jar net.xulingbo.Example</code></p><p>  而之前同时报了NoClassDefFoundError和 ClassNotFoundException异常，原因是 Java虚拟机隐式加载了exanple.jar后显式加载Example时没有找到这个类，所以是ClassNotFoundException 引发了 NoClassDefFoundError 异常。</p><p>  在JVM的规范中描述了出现NoClassDefFoundError可能的情况就是使用new关键字、属性引用某个类、继承某个接口或类，以及方法的某个参数中引用了某个类，这时会触发JVM<strong>隐式加载</strong>这些类时发现这些类不存在的异常。</p><p>  解决这个错误的办法就是确保每个类引用的类都在当前的classpath路径下面。</p></li><li><p>UnsatisfiedLinkError<br>  这个异常倒不是很常见，但是出错的话，通常是在JVM启动的时候,如果一不小心将在JVM中的某个lib删除了,可能就会报这个错误了，代码如下：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoLibException</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> native <span class="keyword">void</span> <span class="title">nativeMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"NoLib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NoLibException().nativeMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个错误通常是在解析native标识的方法时JVM找不到对应的本机库文件时出现</p></li><li><p>ClassCastException<br>  这个错误也很常见，通常在程序出现强制类型转换时出现这个错误，如下面这段代码所示：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastExceptlon</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">put</span> (<span class="string">"a"</span>，<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Integer islnt =(Integer)m.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br><span class="line">        System.out.<span class="built_in">print</span>(islnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当强制将本来不是Integer类型的字符串转成Integer类型时会报错</p><p>  JVM在做类型转换时会按照如下规侧进行检査：</p><ul><li><p>对于普通对象，对象必须是目标类的实例或目标类的子类的实例。如果目标类是接口，那么会把它当作实现了该接口的一个子类。</p></li><li><p>对于数组类型，目标类必须是数组类型或java.lang.Object 、java.lang.Cloneable或java.io.Serializable。</p><p>如果不满足上面的规则，JVM就会报这个错误。要避免这个错误有两种方式：</p></li><li><p>在容器类型中显式地指明这个容器所包含的对象类型，如在上面的Map中可以写为 <code>Map&lt;String，Integer&gt; m = new HashMap&lt;String，Integer&gt;()</code>。这祥上面的代码在编译阶段就会检査通过。</p></li><li><p>先通过instanceof检查是不是目标类型,然后再进强制类型转换。</p></li></ul></li><li><p>ExceptionInInitializerError<br>  这个错误在JVM规范中是这样定义的：</p><ul><li><p>如果Java虚拟机试图创建类ExceptionlnInitializerError的新实例,但是因为出现Out-Of-Memory-Error而无法创建新实倒.，那么就抛出OutOfMemoryError对象作为替代。</p></li><li><p>如果初始化器抛出一些Exception，而且Exception类不是Error或者它的某个子类，那么就会创建ExceptionlnlnitializeiError类的一个新实例，并用Exception作为参数，用这个实例代替Exception。</p><p>将上面的代码例子稍微改了一下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastExceptlon</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            m.<span class="built_in">put</span> (<span class="string">"a"</span>，<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Integer islnt =(Integer)m.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br><span class="line">        System.out.<span class="built_in">print</span>(islnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化这个类时，给静态属性m赋值时出现了异常导致抛出错误ExceptionInInitializerError.</p></li></ul></li></ul><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>先简单说下类加载器。</p><ol><li>JVM通过类加载器(ClassLoader)加载类。JVM中提供的三种类加载器：BootStrap类加载器，加载<code>JRE/lib</code>；ExtClassLoader，加载 JRE/lib/ext；AppClassLoader 加载classpath。</li><li>JVM加载采用了双亲委派机制，就是当加载一个类时，当前的ClassLoader先请求父ClassLoader，依次类推，直到父ClassLoader无法加载时，才通过当前的ClassLoader加载，这就保证了像String这样的类型肯定是由BootStrap类加载器加载的。</li><li>在JVM中，一个实例是通过本身的完整类名+加载它的ClassLoader实例识别的，也就是说即使同一个ClassLoader类的不同的实例加载同一个类在JVM也是不同的。</li><li>同一个ClassLoader是不允许多次加载一个类的，否则会报java.lang.LinkageError。JVM在加载类之前会检査请求的类是否已经被加载过来，也就是要调用flndLoadedClass()方法查看是否能够返回类实例。如果类已经加载过来，再调用loadClass()将会导致类冲突。</li></ol><p>热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。JVM并不支持热部署，那么要实现热部署，就必须自定义ClassLoader，当类被修改过后，可以创建不同的ClassLoader的实例对象，然后通过这个不同的实例对象来加载同名的类。</p><p>不需要担心这样会使PermGen区无限增大，因为ClassLoader 也是个对象，当不再被引用时也会被回收，之后在Full GC时，由其加载的类，如果没用了，也会被收回。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassReloader reloader = <span class="keyword">new</span> <span class="constructor">ClassReloader(<span class="params">classpath</span>)</span>;</span><br><span class="line">Class r = reloader.find<span class="constructor">Class(<span class="string">"HelloWorld.class"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line">ClassReloader reloader2 = <span class="keyword">new</span> <span class="constructor">ClassReloader(<span class="params">classpath</span>)</span>;</span><br><span class="line">Class r2 = reloader2.find<span class="constructor">Class(<span class="string">"HelloWorld.class"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r2.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br></pre></td></tr></table></figure><p>Class.forName()和ClassLoader.loadClass()区别</p><ul><li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li></ul><p>在Tomcat中JSP就是热部署的。其实现原理也是通过创建新的类加载器实例，加载修改后的类。</p><p>对于WEB-INF/classes下的class文件，可以通过配置使其自动加载。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context <span class="attribute">docBase</span>=<span class="string">"xxx"</span> <span class="attribute">path</span>=<span class="string">"/xxx"</span> <span class="attribute">reloadable</span>=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。默认值是false。这个配置能干嘛，其实就是你文件变了，它重启下容器，也就重新加载类了，这个跟之前提到的热部署可能还有些出入。</p><p>如果搜“tomcat 热部署“，可能会搜到autoDeploy和crossContext两个属性，前者为Host属性，指示Tomcat运行时，如有新的WEB程序加入appBase指定的目录下，是否为自动布署，默认值为true。后者为Context属性，指示是否允许跨域访问，为true时，在程序内调用ServletContext.getContext()方法将返回一个虚拟主机上其它web程序的请求调度器。默认值为false，调 径用getContext()返回为null。所以这两个配置跟热部署也没多大关系了。</p><p>有一个工具可以实现这里说的热部署：<a href="http://zeroturnaround.com/software/jrebel" target="_blank" rel="noopener">JRebel</a>。这个工具需要付费使用。</p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>每个Java线程就是一个执行引擎实例，那么一个JVM实例中就会同时存在多个执行引擎工作。</p><p>执行引擎可以是基于栈的，如Hotspot，也可以是基于寄存器的，如Dalvik。前者是为了更好地支持跨平台，很难针对不同平台设计通用基于寄存器的指令，而后者主要运用于手机等智能设备，基本基于特定的芯片的寄存器设计。</p><h2 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h2><p>为什么会使用Session和Cookie？因为HTTP是无状态的。而我们服务器端又需要知道用户状态，比如说这次请求和另一次请求是不是一个用户之类的，Session和Cookie就是用来记录状态的机制。</p><p>Cookie在客户端存储，一般会受到浏览器的限制，比如大多数浏览器要求每个域名只能保存50个Cookie、Cookie大小不能超过4KB。并且还需要防止Cookie被盗，Cookie伪造等问题。如果Cookie很大，还会占用带宽，可以考虑压缩Cookie，比如使用gzip或deflate进行压缩，压缩后再使用BASE64编码。</p><p>Session保存在服务器上。当访问增多，会比较占用服务器的资源，并且还需要考虑如何在服务器之间共享Session。</p><p>Session和Cookie也并不是必须的，如RESTful应用在服务端不会保存状态的，它的状态由客户端去维护，像浏览器这样的客户端也可以将状态保存在本地存储中（localstorage、sessionstorage）。这样可以不用考虑像Session共享这样的问题了。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie一般是由服务器端生成，通过在响应头添加<code>Set-Cookie</code>使浏览器保存Cookie（临时或持久化保存），下次请求同一网站时浏览器会在请求头携带Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie主要就是键值对，有一种比较特殊的Cookie，就是SeesionID，Tomcat中其name是JSESSIONID，根据SeesionID服务器可以找到对应的Session，进而获取保存的状态。</p><p>当前 Cookie 有两个版本：Version 0 和 Version 1。通过它们有两种设置响应头的标识，分别是 “Set-Cookie”和“Set-Cookie2”，后者不常用。</p><p>Version 0 属性项介绍</p><table><thead><tr><th>属性项</th><th>属性项介绍</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>键值对，<strong>可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样，否则会抛出IllegalArgumentException。Value不能是非ASSIC字符，非ASSIC字符可以使用URLEncoder进行编码</strong></td></tr><tr><td>Expires</td><td>过期时间，在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday, 09-Nov-99 23:12:40 GMT。用Max-Age更多些</td></tr><tr><td>Domain</td><td>生成该 Cookie 的域名，<strong>Cookie不能跨域访问，如 images.google.com 不能访问 <a href="http://www.google.com的Cookie。但是对于二级域名，如果设置Domain=&quot;.google.com&quot;的话，images.google.com" target="_blank" rel="noopener">www.google.com的Cookie。但是对于二级域名，如果设置Domain=&quot;.google.com&quot;的话，images.google.com</a> 也能访问 <a href="http://www.google.com的Cookie" target="_blank" rel="noopener">www.google.com的Cookie</a></strong></td></tr><tr><td>Path</td><td>该 Cookie 是在当前的哪个路径下生成的，<strong>Cookie只能在相同path下访问。如 path=/wp-admin/ 这样/wp-content/下就无法访问该Cookie。注意，path应该以<code>/</code>结束</strong></td></tr><tr><td>Secure</td><td>如果设置了这个属性，那么只会在HTTPS和SSL等安全协议时才会回传该 Cookie</td></tr></tbody></table><p>Version 1 属性项介绍</p><table><thead><tr><th>属性项</th><th>属性项介绍</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>与 Version 0 相同</td></tr><tr><td>Version</td><td>通过 Set-Cookie2 设置的响应头创建必须符合 RFC2965 规范，如果通过 Set-Cookie 响应头设置，默认值为 0，如果要设置为 1，则该 Cookie 要遵循 RFC 2109 规范</td></tr><tr><td>Comment</td><td>注释项，用户说明该 Cookie 有何用途</td></tr><tr><td>CommentURL</td><td>服务器为此  Cookie 提供的 URI 注释</td></tr><tr><td>Discard</td><td>是否在会话结束后丢弃该 Cookie 项，默认为 fasle</td></tr><tr><td>Domain</td><td>类似于 Version 0</td></tr><tr><td>Max-Age</td><td>最大失效时间，<strong>为正数，会被持久化，即存储到文件中，指定多少秒后失效；为负数，不被持久化，关闭浏览器后失效，0表示立即失效，可以起到删除Cookie的作用，这里需要保证 name, path和domain 是相同的</strong></td></tr><tr><td>Path</td><td>类似于 Version 0</td></tr><tr><td>Port</td><td>该 Cookie 在什么端口下可以回传服务端，如果有多个端口，以逗号隔开，如 Port=”80,81,8080”</td></tr><tr><td>Secure</td><td>类似于 Version 0</td></tr></tbody></table><p>JavaEE中对应的类是javax.servlet.http.Cookie包含name，value，secure，path，domain，comment，version属性。通过request.getCookies()获取客户端提交的所有Cookie，通过response.addCookie(Cookie cookie)向客户端设置Cookie。</p><p>如果我们通过浏览器查看当前网站的Cookie，可能会看到两种Cookie，一种是当前网站本身设置的 Cookie，另一种是来自在网页上嵌入广告或图片等其他域来源的 第三方 Cookie (网站可通过使用这些 Cookie 跟踪你的使用信息)。可以确定的是对于Cookie来说肯定是不允许垮域访问的。无论是通过JS还是Server端程序来说都是如此，但是通过一些技术可以，比如天猫如何能跨域获取淘宝的Cookie，一种办法就是淘宝提供接口可以获取到其下的Cookie</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session是另一种记录客户状态的机制，保存在服务器上。</p><p>Session存储在服务器哪里？为了获得更高的存取速度，服务器一般把Session放在内存里。也可以将其存储在数据库、文件系统、缓存中。当Servlet容器关闭时StandardManager类会把Session对象写入<code>SESSIONS.ser</code>文件中，要想持久化保存Servlet容器中的Session对象，必须通过调用Servlet容器的start和stop方法。</p><p>何时生成Session？调用request.getSession()方法时，如果不存在Session就会创建一个新的，用户第一次访问服务器时，访问JSP或Servlet等程序才会创建Session，只访问HTML、图片等静态资源并不会创建Session。服务器会更新Session最后访问时间。</p><p>何时失效？服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间 。如果超过了超时时间没访问过服务器，Session就自动失效了。Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(long interval)修改。Session的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法可以使Session失效。</p><p>如何来识别特定用户？依靠Cookie，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <code>;JSESSIONID=xxxxx</code> 这样的参数，服务端据此来识别用户。</p><p>通过订阅服务器（如Zookeeper集群管理服务器）统一各个服务器的Session配置项，通过分布式缓存（如MemCache）存储Session，解决Session共享问题。</p><h3 id="表单重复提交问题"><a href="#表单重复提交问题" class="headerlink" title="表单重复提交问题"></a>表单重复提交问题</h3><p>每次生成表单时，都生成一个隐藏表单项，其值为一个唯一的token，并且这个token存储在Session中，表单提交到服务器后，比对表单中的token和服务器Session中的token是否一致，如果一致则没有重复提交，进行后续处理，然后重新生成Session中的token。如果不一致，说明表单已经成功提交过一次了，这是重复提交。</p><h3 id="多终端Session统一"><a href="#多终端Session统一" class="headerlink" title="多终端Session统一"></a>多终端Session统一</h3><p>一种情况是在移动设备上访问无限服务端系统和PC服务端系统，这两者之间Session的共享，这个可以通过分布式Session框架解决。另一种情况是在移动端已经登陆的前提下，PC端通过扫码登录，这种情况下二维码携带一个特定标识，标识事这个客户端通过手机端登录了。当手机扫码成功后，会在服务器端设置这个二维码对应的标识为已经登录成功，PC端通过心跳请求验证是否登陆成功。</p><h2 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h2><p>出于安全考虑，浏览器会限制脚本中发起的跨站请求。比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略（same-origin policy）。</p><p>简单记录下两种跨域请求</p><ul><li><p>简单请求<br>  这种跨站请求与以往浏览器发出的跨站请求并无异同。并且，如果服务器不给出适当的响应头，则不会有任何数据返回给请求方。因此，那些不允许跨站请求的网站无需为这一新的 HTTP 访问控制特性担心。这种请求具备以下两个条件：</p><ul><li>只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</li><li>不会使用自定义请求头（类似于 X-Modified 这种）。</li></ul></li><li><p>预请求（preflight request）<br>  不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。这种场景下，总比正常请求多一次请求。当请求具备以下条件，就会被当成预请求处理：</p><ul><li>请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</li><li>使用自定义请求头（比如添加诸如 X-PINGOTHER）</li></ul></li></ul><p>跨域请求请求头可能带有Origin、Access-Control-Request-Method、Access-Control-Request-Headers，分别用来标识发起请求的URI，请求方法，请求头</p><p>响应头部可能带有Access-Control-Allow-Origin，Access-Control-Max-Age，Access-Control-Allow-Methods，Access-Control-Allow-Headers分别表示允许发起访问的URI，预请求的结果的有效期，允许的访问方法，允许的请求头</p><p>Tomcat 中配置CORS过滤器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">filter</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">filter</span>-<span class="type">name</span>&gt;CorsFilter&lt;/<span class="keyword">filter</span>-<span class="type">name</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">filter</span>-<span class="keyword">class</span>&gt;org.apache.catalina.filters.CorsFilter&lt;/<span class="keyword">filter</span>-<span class="keyword">class</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">filter</span>&gt;</span><br><span class="line">&lt;<span class="keyword">filter</span>-<span class="keyword">mapping</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">filter</span>-<span class="type">name</span>&gt;CorsFilter&lt;/<span class="keyword">filter</span>-<span class="type">name</span>&gt;</span><br><span class="line">  &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure><p>跨域资源共享更详细的内容可以参考：<br><a href="http://www.w3.org/TR/cors/" target="_blank" rel="noopener">http://www.w3.org/TR/cors/</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制(CORS)</a></p><p><a href="http://enable-cors.org/index.html" target="_blank" rel="noopener">不同的服务器配置CORS</a></p><p>从<a href="http://www.xulingbo.net/" target="_blank" rel="noopener">君山的博客</a>中整理了一些<a href="http://pan.baidu.com/s/1kTF39XX" target="_blank" rel="noopener">资料</a>。</p>]]></content>
    
    <summary type="html">
    
      Java Web; 浏览器请求过程; NIO; 字符编码; 乱码;
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://howiefh.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>逻辑删除</title>
    <link href="http://howiefh.github.io/2015/07/25/logical-delete/"/>
    <id>http://howiefh.github.io/2015/07/25/logical-delete/</id>
    <published>2015-07-25T04:08:47.000Z</published>
    <updated>2020-05-02T14:28:14.481Z</updated>
    
    <content type="html"><![CDATA[<ul><li>物理删除，又称硬删除、真删除，即删除操作是将数据记录直接从数据库删除。</li><li>逻辑删除，又称软删除、假删除，通过添加删除标记或者将要删除的数据记录移动到另一张表的方式实现。好处就是对于误操作，数据被删除了，可以很方便地将数据恢复。</li></ul><a id="more"></a><p>流水记录可以考虑物理删除，关键业务数据逻辑删除。如果根本不考虑将来需要恢复的问题，直接删就好了。</p><p>逻辑删除大致又有两种可行方案：做标记；转移数据。</p><p>对于添加标记字段，通过更新语句直接更新一个字段就可以了。但是如果表中有unique字段，就无法再添加相同内容了，解决方案是将删除标记也列入唯一索引中，如<code>&lt;删除标记,唯一字段&gt;</code>。如果数据量大的话，删除操作又比较频繁，这种方法在查询时都要再加一个标记判断，相对效率会比较低。使用视图可以解决每个查询语句添加额外判断的问题，通过创建设定过滤条件索引对查询效率低的问题可能会有所帮助（不是所有数据库都支持过滤索引，而且使用过滤索引也会带来更新索引的代价）。</p><p>对于将要删除的数据移动到另一张表，可以通过<code>CREATE TABLE table_name_archive SELECT * FROM table_name WHERE 1 = 2;ALTER TABLE table_name_archive ADD PRIMARY KEY (id);ALTER TABLE table_name_archive ADD delete_date datetime NOT NULL COMMENT &#39;删除时间&#39;;</code>创建一张表结构相同的表，然后通过触发器实现数据的转移，相对来说可能这种做法效率会略差，一次删除实际上执行了两次操作，同时使用触发器可能也会加重数据库的负担。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELIMITER</span> $$</span><br><span class="line"></span><br><span class="line"><span class="pgsql"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> table_name_trigger $$</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> table_name_trigger</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="built_in">table_name</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_archive</span><br><span class="line">    <span class="keyword">SELECT</span> *, now()</span><br><span class="line">    <span class="keyword">FROM</span> <span class="built_in">OLD</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://weblogs.asp.net/fbouma/soft-deletes-are-bad-m-kay" target="_blank" rel="noopener">http://weblogs.asp.net/fbouma/soft-deletes-are-bad-m-kay</a></p>]]></content>
    
    <summary type="html">
    
      逻辑删除; 软删除; logical delete; soft delete; tombstone;
    
    </summary>
    
    
      <category term="Database" scheme="http://howiefh.github.io/categories/Database/"/>
    
    
      <category term="Database" scheme="http://howiefh.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Vim 自动补全插件 YouCompleteMe 安装与配置</title>
    <link href="http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/"/>
    <id>http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/</id>
    <published>2015-05-22T12:31:12.000Z</published>
    <updated>2020-05-02T14:28:14.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于代码自动补全，之前一直使用的是Shougo/neocomplcache和Shougo/neosnippet。早就听说过YouCompleteMe的大名，一直想尝试一下YCM，但是还是拖到了现在。YCM和其它Vim插件的安装有些不同，可能需要折腾一下。之所以安装稍微会麻烦些，是因为YCM 后端调用 libclang(以获取AST,当然还有其他语言的语义分析库)、前端由 C++ 开发(以提升补全效率)、外层由 python 封装(以成为 vim 插件),它可能是安装最复杂的 vim 插件了。YCM是Client-sever架构的，Vim这部分的YCM只是很小的一个客户端，与具有大量逻辑和功能的ycmd HTTP+JSON交互。server在你开启或关闭Vim是自动开启或关闭。</p><p>其它自动补全的插件基本上是基于文本的，也就是说它们基本上是使用正则去猜。区别于其它Vim的自动补全插件，YCM基于语义引擎（比如C家族的libclang）提供了语义补全，是通过分析源文件，经过语法分析之后进行补全。对于C家族的语言这种基于语义的自动补全依赖于clang/llvm，其他语言 ,会调用vim设置的omnifunc来匹配，可以查看<a href="https://github.com/Valloric/YouCompleteMe#semantic-completion-for-other-languages" target="_blank" rel="noopener">github</a></p><ul><li>Java/Ruby <a href="http://eclim.org/" target="_blank" rel="noopener">eclim</a></li><li>Python <a href="https://github.com/davidhalter/jedi" target="_blank" rel="noopener">Jedi</a></li><li>Go <a href="https://github.com/nsf/gocode" target="_blank" rel="noopener">Gocode</a></li><li>C# <a href="https://github.com/nosami/OmniSharpServer" target="_blank" rel="noopener">OmniSharp</a></li><li>JavaScript <a href="https://github.com/marijnh/tern_for_vim" target="_blank" rel="noopener">Tern for Vim</a></li></ul><p>YCM不是基于前缀补全的，而是子序列，所以输入 abc 可以补全 xaybgc，它对于大小写的补全也非常智能。对于C家族的语言和Python支持跳转到定义处。此外还可以对文件路径进行补全，和ultisnips也很好结合。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="完全安装"><a href="#完全安装" class="headerlink" title="完全安装"></a>完全安装</h3><p><strong>如果用Vundle更新YCM，yum_support_lib库API改变了，YCM会提醒你重新编译它。</strong></p><ol><li><p>确保Vim版本至少是7.3.584，并且支持python2脚本。</p><p> 在Vim中输入<code>:version</code>可以查看版本。如果版本已经高于7.4了，那么OK。版本是7.3。那么继续往下看，看到<code>包含版本:1-Z</code>，如果Z小于584就需要重装了。Ubuntu的话可以通过<a href="http://linuxg.net/how-to-install-vim-7-4-on-ubuntu-13-10-13-04-12-04-linux-mint-16-15-13-and-debian-sid/" target="_blank" rel="noopener">PPA</a>安装高版本的。否则就要从源码编译安装了。<br> 查看是否支持python2：进入vim,命令:echo has(‘python’)，输出为1,则表示支持。如果为0,则需要重新编译安装vim，在编译时添加python支持。</p></li><li><p>通过Vundle安装YCM，在你的vimrc中添加<code>Plugin &#39;Valloric/YouCompleteMe&#39;</code>，然后执行<code>:PluginInstall</code></p></li><li><p>如果不需要对C家族的语言进行语义补全支持，则跳过这一步。</p><p> 下载最新版的libclang。Clang是一个开源编译器，能够编译C/C++/Objective-C/Objective-C++。Clang提供的libclang库是用于驱动YCM对这些语言的语义补全支持。YCM需要版本至少为3.6的libclang，但是理论上3.2+版本也行。也可以使用系统libclang，如果确定是3.3版本或者更高。推荐下载&lt;llvm.org&gt;官网的<a href="http://llvm.org/releases/download.html" target="_blank" rel="noopener">二进制文件</a>。确保选对适合自己系统的包。</p></li><li><p>编译YCM需要的ycm_support_libs库。YCM的C++引擎通过这些库来获取更快的补全速度。<br> 需要cmake，如果未安装，安装之：<code>sudo apt-get install build-essential cmake</code>（也可以下载安装<a href="http://www.cmake.org/cmake/resources/software.html" target="_blank" rel="noopener">http://www.cmake.org/cmake/resources/software.html</a>）。确保python头文件已安装：<code>sudo apt-get install python-dev</code>。假设你已经通过Vundle装好YCM了，那么它应该位于<code>~/.vim/bundle/YouCompleteMe</code>。我们新建一个目录用来放置编译文件，并切换到此目录下<code>cd ~;mkdir ycm_build;cd ycm_build;</code><br> 下一步生成makefile，这一步很重要，有点复杂。</p><ul><li>如果不需要C族语言的语义支持，在ycm_build目录下执行：<code>cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li><li>如果需要C族语言的语义支持，还得分几种情况：<ul><li>假如你从llvm的官网下载了LLVM+Clang，然后解压到：<del>/ycm_temp/llvm_root_dir （该目录下有 bin, lib, include 等文件夹），然后执行：`cmake -G “Unix Makefiles” -DPATH_TO_LLVM_ROOT=</del>/ycm_temp/llvm_root_dir . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp`</li><li>如果想用系统的libclang：<code>cmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li><li>如果想用自定义的libclang：<code>cmake -G &quot;Unix Makefiles&quot; -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code>。/path/to/libclang.so这部分填入你自己的路径。<br>makefiles生成后执行：<code>make ycm_support_libs</code></li></ul></li></ul></li></ol><p>我是从llvm网站下载的二进制文件，安装的，安装过程中也没遇到什么问题。</p><h3 id="Ubuntu-Linux-X64-超快安装"><a href="#Ubuntu-Linux-X64-超快安装" class="headerlink" title="Ubuntu Linux X64 超快安装"></a>Ubuntu Linux X64 超快安装</h3><p>最好还是完整安装，这种快速安装未必适合所有人。安装之前，同样也要确定满足以上所述的vim版本、python支持等条件。和上面一样使用Vundle安装YCM，安装CMake和python头文件。</p><p>编译YCM，如果需要对C-family的语义支持：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="string">./install.sh</span> <span class="params">--clang-completer</span></span><br></pre></td></tr></table></figure><p>如果不需要对C-family的语义支持：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="string">./install.sh</span></span><br></pre></td></tr></table></figure><p>如果需要支持C#，添加 <code>--omnisharp-complete</code>。如果需要支持Go添加<code>--gocode-completer</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>YCM使用TAB键接受补全，一直按TAB则会循环所有的匹配补全项。shift+TAB则会反向循环。注意：如果使用控制台Vim（非GVim或MacVim等），控制台不会将shift+Tab传递给Vim，因此会无反应，需要重新映射按键。此外，如果同时使用ultisnaps，可能会有冲突，需要进行一些设置。可以使用Ctrl+Space来触发补全，不过会和输入法冲突，也需要设置。</p><p>YCM会寻找当前打开的文件的同级目录下或上级目录中的<code>ycm_extra_conf.py</code>这个文件，找到后会加载为Python模块，且只加载一次。YCM调用该模块中的FlagsForFile方法。该模块必须提供带有编译当前文件的必要信息的这个方法。需要修改<code>.ycm_extra_conf.py</code>文件中的flags部分，使用-isystem添加系统的头文件进行解析，使用-I添加第三方的头文件进行解析，在flags部分后添加如下内容：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'-isystem',</span><br><span class="line">'/usr/include',</span><br></pre></td></tr></table></figure><p>使用命令<code>:YcmDiags</code>可以打开location-list查看警告和错误信息。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> completeopt=longest,<span class="keyword">menu</span><span class="comment">"让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)</span></span><br><span class="line"><span class="keyword">autocmd</span> InsertLeave * <span class="keyword">if</span> <span class="built_in">pumvisible</span>() == <span class="number">0</span>|<span class="keyword">pclose</span>|<span class="keyword">endif</span><span class="comment">"离开插入模式后自动关闭预览窗口</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span>       <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;C-y&gt;"</span> : <span class="string">"\&lt;CR&gt;"</span><span class="comment">"回车即选中当前项</span></span><br><span class="line"><span class="comment">"上下左右键的行为 会显示其他信息</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;Down&gt;</span>     <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;C-n&gt;"</span> : <span class="string">"\&lt;Down&gt;"</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;Up&gt;</span>       <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;C-p&gt;"</span> : <span class="string">"\&lt;Up&gt;"</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;PageDown&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageDown&gt;"</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;PageUp&gt;</span>   <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageUp&gt;"</span></span><br><span class="line"><span class="comment">" 跳转到定义处</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>jd :YcmCompleter GoToDefinitionElseDeclaration<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F6&gt;</span> :YcmForceCompileAndDiagnostics<span class="symbol">&lt;CR&gt;</span><span class="comment">"force recomile with syntastic</span></span><br><span class="line"><span class="string">" nnoremap &lt;leader&gt;lo :lopen&lt;CR&gt;"</span><span class="keyword">open</span> locationlist</span><br><span class="line"><span class="string">" nnoremap &lt;leader&gt;lc :lclose&lt;CR&gt;"</span><span class="keyword">close</span> locationlist</span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;leader&gt;</span> <span class="symbol">&lt;C-x&gt;</span><span class="symbol">&lt;C-o&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span> = <span class="string">'~/.vim/data/ycm/.ycm_extra_conf.py'</span></span><br><span class="line"><span class="comment">" 不显示开启vim时检查ycm_extra_conf文件的信息  </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_confirm_extra_conf</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">" 开启基于tag的补全，可以在这之后添加需要的标签路径  </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_tags_files</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">"注释和字符串中的文字也会被收入补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">" 输入第2个字符开始补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_min_num_of_chars_for_completion</span>=<span class="number">2</span></span><br><span class="line"><span class="comment">" 禁止缓存匹配项,每次都重新生成匹配项</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_cache_omnifunc</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">" 开启语义补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">"在注释输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">"在字符串输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_strings</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">" 设置在下面几种格式的文件上屏蔽ycm</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_filetype_blacklist</span> = &#123;</span><br><span class="line">      \ <span class="string">'tagbar'</span> : <span class="number">1</span>,</span><br><span class="line">      \ <span class="string">'nerdtree'</span> : <span class="number">1</span>,</span><br><span class="line">      \&#125;</span><br><span class="line"><span class="comment">"youcompleteme  默认tab  s-tab 和 ultisnips 冲突</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_select_completion</span> = [<span class="string">'&lt;Down&gt;'</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_previous_completion</span> = [<span class="string">'&lt;Up&gt;'</span>]</span><br><span class="line"><span class="comment">" 修改对C函数的补全快捷键，默认是CTRL + space，修改为ALT + ;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_invoke_completion</span> = <span class="string">'&lt;M-;&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" SirVer/ultisnips 代码片断</span></span><br><span class="line"><span class="comment">" Trigger configuration. Do not use &lt;tab&gt; if you use https://github.com/Valloric/YouCompleteMe.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsExpandTrigger</span>=<span class="string">"&lt;tab&gt;"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsJumpForwardTrigger</span>=<span class="string">"&lt;tab&gt;"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsJumpBackwardTrigger</span>=<span class="string">"&lt;s-tab&gt;"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsListSnippets</span>=<span class="string">"&lt;c-e&gt;"</span></span><br><span class="line"><span class="comment">"定义存放代码片段的文件夹，使用自定义和默认的，将会的到全局，有冲突的会提示</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsSnippetDirectories</span>=[<span class="string">"bundle/vim-snippets/UltiSnips"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">" 参考https://github.com/Valloric/YouCompleteMe/issues/36#issuecomment-62941322</span></span><br><span class="line"><span class="comment">" 解决ultisnips和ycm tab冲突，如果不使用下面的办法解决可以参考</span></span><br><span class="line"><span class="comment">" https://github.com/Valloric/YouCompleteMe/issues/36#issuecomment-63205056的配置</span></span><br><span class="line"><span class="comment">" begin</span></span><br><span class="line"><span class="comment">" let g:ycm_key_list_select_completion=['&lt;C-n&gt;', '&lt;Down&gt;']</span></span><br><span class="line"><span class="comment">" let g:ycm_key_list_previous_completion=['&lt;C-p&gt;', '&lt;Up&gt;']</span></span><br><span class="line"><span class="string">" let g:UltiSnipsExpandTrigger="</span><span class="symbol">&lt;Tab&gt;</span><span class="comment">"</span></span><br><span class="line"><span class="string">" let g:UltiSnipsJumpForwardTrigger="</span><span class="symbol">&lt;Tab&gt;</span><span class="comment">"                                           </span></span><br><span class="line"><span class="string">" let g:UltiSnipsJumpBackwardTrigger="</span><span class="symbol">&lt;S-Tab&gt;</span><span class="comment">"</span></span><br><span class="line"><span class="comment">" end</span></span><br><span class="line"><span class="comment">" UltiSnips completion function that tries to expand a snippet. If there's no</span></span><br><span class="line"><span class="comment">" snippet for expanding, it checks for completion window and if it's</span></span><br><span class="line"><span class="comment">" shown, selects first element. If there's no completion window it tries to</span></span><br><span class="line"><span class="comment">" jump to next placeholder. If there's no placeholder it just returns TAB key </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">g</span>:<span class="title">UltiSnips_Complete</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">call</span> UltiSnips#ExpandSnippet()</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">g:ulti_expand_res</span> == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pumvisible</span>()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\&lt;C-n&gt;"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">call</span> UltiSnips#JumpForwards()</span><br><span class="line">            <span class="keyword">if</span> <span class="variable">g:ulti_jump_forwards_res</span> == <span class="number">0</span></span><br><span class="line">               <span class="keyword">return</span> <span class="string">"\&lt;TAB&gt;"</span></span><br><span class="line">            <span class="keyword">endif</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">au</span> BufEnter * exec <span class="string">"inoremap &lt;silent&gt; "</span> . <span class="variable">g:UltiSnipsExpandTrigger</span> . <span class="string">" &lt;C-R&gt;=g:UltiSnips_Complete()&lt;cr&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Expand snippet or return</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ulti_expand_res</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">Ulti_ExpandOrEnter</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">call</span> UltiSnips#ExpandSnippet()</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">g:ulti_expand_res</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\&lt;return&gt;"</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Set &lt;space&gt; as primary trigger</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;return&gt;</span> <span class="symbol">&lt;C-R&gt;</span>=Ulti_ExpandOrEnter()<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure><h2 id="YCM-amp-Eclim"><a href="#YCM-amp-Eclim" class="headerlink" title="YCM &amp; Eclim"></a>YCM &amp; Eclim</h2><p>YCM配合Eclim可以实现对Java代码的自动提示，首先需要下载<a href="http://eclim.org/install.html" target="_blank" rel="noopener">Eclim</a>，下载好后执行<code>java -jar eclim_2.4.1.jar</code>，卸载的话，后面再加个参数<code>uninstaller</code>就行。按提示一步步安装就好了，安装好后首先要启动eclimd，它存放在eclipse的根目录下。</p><p>对不同的自动补全插件eclim都提供了<a href="http://eclim.org/vim/code_completion.html" target="_blank" rel="noopener">配置方法</a>，对于YCM我们只需要在vimrc中添加一行<code>let g:EclimCompletionMethod = &#39;omnifunc&#39;</code>就可以了。</p><p>打开vim执行<code>:ProjectCreate /path/to/project -n java</code>创建一个新的工程。这个工程的结构和eclipse类似。<code>:ProjectList</code>命令可以查看工程列表。</p><p>这个插件很有意思，可以在eclipse中嵌入vim，又可以在vim中享受eclipse一样的自动补全。对于Java来说，提供了一些以<code>Java</code>，<code>Project</code>，<code>New</code>，<code>Mvn</code>为前缀的命名。可以输入<code>:Java</code>按Tab键尝试一下。不过，我觉得还是使用eclipse配合viPlugin插件更方便些。</p><p>参考：</p><ol><li><a href="http://www.cnblogs.com/zhongcq/p/3630047.html" target="_blank" rel="noopener">Vim自动补全插件—-YouCompleteMe安装与配置</a></li><li><a href="http://blog.csdn.net/leaf5022/article/details/21290509" target="_blank" rel="noopener">Vim智能补全插件YouCompleteMe安装</a></li></ol>]]></content>
    
    <summary type="html">
    
      Vim 自动补全；Vim YouCompleteMe 安装；Vim YouCompleteMe 配置；
    
    </summary>
    
    
      <category term="Vim" scheme="http://howiefh.github.io/categories/Vim/"/>
    
    
      <category term="Vim" scheme="http://howiefh.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Shiro &amp; CAS 实现单点登录</title>
    <link href="http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/"/>
    <id>http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/</id>
    <published>2015-05-18T16:11:12.000Z</published>
    <updated>2020-05-04T11:15:02.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>单点登录主要用于多系统集成，即在多个系统中，用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无须多次登录。</p><p>本文使用开源框架<a href="https://github.com/Jasig/cas/releases" target="_blank" rel="noopener">Jasig CAS</a>来完成单点登录。下载地址：<a href="https://www.apereo.org/cas/download" target="_blank" rel="noopener">https://www.apereo.org/cas/download</a>。在写本文时，使用的cas server版本为4.0.1</p><a id="more"></a><h2 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h2><p>本文服务器使用Tomcat7，下载了<a href="http://downloads.jasig.org/cas/cas-server-4.0.0-release.zip" target="_blank" rel="noopener">cas-server-4.0.0-release.zip</a>，将其解压，找到modules目录下面的cas-server-webapp-4.0.0.war直接复制到webapps文件夹下即可。启动Tomcat，访问<a href="http://localhost:8080/cas-server-webapp-4.0.0，使用casuser/Mellon登录，即可登录成功。" target="_blank" rel="noopener">http://localhost:8080/cas-server-webapp-4.0.0，使用casuser/Mellon登录，即可登录成功。</a></p><p>Tomcat默认没有开启HTTPS协议，所以这里直接用了HTTP协议访问。为了能使客户端在HTTP协议下单点登录成功，需要修改一下配置：</p><ul><li><p>WEB-INF\spring-configuration\ticketGrantingTicketCookieGenerator.xml和WEB-INF\spring-configuration\warnCookieGenerator.xml：将<code>p:cookieSecure=&quot;true&quot;</code>改为<code>p:cookieSecure=&quot;false&quot;</code></p></li><li><p>WEB-INF\deployerConfigContext.xml：<code>&lt;bean class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref=&quot;httpClient&quot; /&gt;</code>添加<code>p:requireSecure=&quot;false&quot;</code></p></li></ul><p>至此，一个简单的单点登录服务器就基本部署好了。</p><h2 id="部署客户端"><a href="#部署客户端" class="headerlink" title="部署客户端"></a>部署客户端</h2><p>客户端需要添加对<a href="http://shiro.apache.org/cas.html" target="_blank" rel="noopener">shiro-cas</a>和cas-client-core这两个包的依赖。这里主要讲跟CAS相关的配置。</p><p>之后配置web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义Realm：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyCasRealm</span> <span class="keyword">extends</span> <span class="title">CasRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> userService;</span><br><span class="line"></span><br><span class="line">    public void setUserService(<span class="type">UserService</span> userService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">AuthorizationInfo</span> doGetAuthorizationInfo(<span class="type">PrincipalCollection</span> principals) &#123;</span><br><span class="line">        <span class="type">String</span> username = (<span class="type">String</span>)principals.getPrimaryPrincipal();</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> authorizationInfo = <span class="keyword">new</span> <span class="type">SimpleAuthorizationInfo</span>();</span><br><span class="line">        authorizationInfo.setRoles(userService.findRoles(username));</span><br><span class="line">        authorizationInfo.setStringPermissions(userService.findPermissions(username));</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"casRealm"</span> <span class="attr">class</span>=<span class="string">"package.for.your.MyCasRealm"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">ref</span>=<span class="string">"userService"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationCachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationCacheName"</span> <span class="attr">value</span>=<span class="string">"authenticationCache"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizationCachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizationCacheName"</span> <span class="attr">value</span>=<span class="string">"authorizationCache"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--该地址为cas server地址 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"casServerUrlPrefix"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;shiro.casServer.url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 该地址为是当前应用 CAS 服务 URL，即用于接收并处理登录成功后的 Ticket 的，</span></span></span><br><span class="line"><span class="xml">    必须和loginUrl中的service参数保持一致，否则服务器会判断service不匹配--&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"casService"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;shiro.client.cas&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>配置CAS过滤器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"casFilter"</span> <span class="built_in">class</span>=<span class="string">"org.apache.shiro.cas.CasFilter"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"failureUrl"</span> value=<span class="string">"/casFailure.jsp"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"shiroFilter"</span> <span class="built_in">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"loginUrl"</span> value=<span class="string">"$&#123;shiro.login.url&#125;"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"successUrl"</span> value=<span class="string">"$&#123;shiro.login.success.url&#125;"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"filters"</span>&gt;</span><br><span class="line">        &lt;util:map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"cas"</span> value-<span class="keyword">ref</span>=<span class="string">"casFilter"</span>/&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"logout"</span> value-<span class="keyword">ref</span>=<span class="string">"logoutFilter"</span> /&gt;</span><br><span class="line">        &lt;/util:map&gt;</span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /casFailure.jsp = anon</span><br><span class="line">            /cas = cas</span><br><span class="line">            /logout = logout</span><br><span class="line">            /** = user</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>上面登录url我的配置的是<code>http://localhost:8080/cas-server/login?service=http://localhost:8080/cas-client/cas</code>，service参数是之后服务将会跳转的地址。</p><p><code>/cas=cas</code>：即/cas 地址是服务器端回调地址，使用 CasFilter 获取 Ticket 进行登录。</p><p>之后通过eclipse部署，访问<a href="http://localhost:8080/cas-client" target="_blank" rel="noopener">http://localhost:8080/cas-client</a> 即可测试。为了看到单点登录的效果，可以直接复制一份webapps中的client为client2，只需要修改上述配置中的地址即可。如果用户已经登录，那么访问<a href="http://localhost:8080/cas-client2发现不会再跳转到登录页面了，用户已经是登录状态了。" target="_blank" rel="noopener">http://localhost:8080/cas-client2发现不会再跳转到登录页面了，用户已经是登录状态了。</a></p><p>还需要注意一个问题，就是cas server默认是开启单点登出的但是这里却没有这样的效果，APP1登出了，但是APP2仍能访问，如果查看浏览器的cookie的话，会发现有两个sessionid，一个是JSESSIONID，容器原生的，另一个是shiro中配置的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话Cookie模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionIdCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">SingleSignOutFilter发现是logoutRequest请求后，原来SingleSignOutHandler中创建的原生的session已经被销毁了，因为从a登出的，a的shiro session也会销毁，</span><br><span class="line">    但是b的shiro的session还没有被销毁，于是再访问b还是能访问，单点登出就有问题了--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"JSESSIONID"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpOnly"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"-1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们把sid改为JSESSIONID会怎么样，答案是如果改为JSESSIONID会导致重定向循环，原因是当登录时，shiro发现浏览器发出的请求中的JSESSIONID没有或已经过期，于是生成一个JSESSIONID给浏览器，同时链接被重定向到服务器进行认证，认证成功后返回到客户端服务器的cas service url，并且带有一个ticket参数。因为有SingleSignOutFilter，当发现这是一个tocken请求时，SingleSignOutHandler会调用request.getSession()获取的是原生Session，如果没有原生session的话，又会创建并将JSESSIONID保存到浏览器cookie中，当客户端服务器向cas服务器验证ticket之后，客户端服务器重定向到之前的页面，这时shiro发现JSESSIONID是SingleSignOutHandler中生成的，在自己维护的session中查不到，又会重新生成新的session，然后login，然后又会重定向到cas服务器认证，然后再重定向到客户端服务器的cas service url，不同的是SingleSignOutHandler中这次调用session.getSession(true)不会新创建一个了，之后就如此循环。如果使用sid又会导致当单点登出时候，如果有a、b两个客户端服务器，从a登出，会跳转到cas服务器登出，cas服务器会对所有通过它认证的service调用销毁session的方法，但是b的shiro的session还没有被销毁，于是再访问b还是能访问，单点登出就有问题了</p><p>之所以这样是因为我设置shiro的session管理器为DefaultWebSessionManager，这个管理器直接抛弃了容器的session管理器，自己来维护session，所以就会出现上述描述的问题了。如果我们不做设置，那么shiro将使用默认的session管理器ServletContainerSessionManager：Web 环境，其直接使用 Servlet 容器的会话。这样单点登出就可以正常使用了。</p><p>此外如果我们非要使用DefaultWebSessionManager的话，我们就要重写一个SingleSignOutFilter、SingleSignOutHandler和SessionMappingStorage了。</p><p>如果没有使用Spring框架，则可以参考如下配置web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:web</span>=<span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>YPshop Authority Manage<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>authority.root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ======================== 单点登录开始 ======================== --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 说明：这种客户端的配置方式是不需要Spring支持的 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参考资料：http://blog.csdn.net/yaoweijq/article/details/6003187 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.authentication.AuthenticationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerLoginUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://localhost:8443/cas-server/login<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://localhost:8443<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerUrlPrefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://localhost:8443/cas-server<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>https://localhost:8443<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.util.AssertionThreadLocalFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ======================== 单点登录结束 ======================== --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributable</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用HTTPS协议"><a href="#使用HTTPS协议" class="headerlink" title="使用HTTPS协议"></a>使用HTTPS协议</h3><p>首先我们需要生成数字证书</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keystore "D:\localhost.keystore" -alias localhost -keyalg RSA</span><br><span class="line">输入密钥库口令:</span><br><span class="line">再次输入新口令:</span><br><span class="line">您的名字与姓氏是什么?</span><br><span class="line">[<span class="symbol">Unknown</span>]: <span class="link">localhost</span></span><br><span class="line">您的组织单位名称是什么?</span><br><span class="line">[<span class="symbol">Unknown</span>]: <span class="link">xa</span></span><br><span class="line">您的组织名称是什么?</span><br><span class="line">[<span class="symbol">Unknown</span>]: <span class="link">xa</span></span><br><span class="line">您所在的城市或区域名称是什么?</span><br><span class="line">[<span class="symbol">Unknown</span>]: <span class="link">xi'an</span></span><br><span class="line">您所在的省/市/自治区名称是什么?</span><br><span class="line">[<span class="symbol">Unknown</span>]: <span class="link">xi'an</span></span><br><span class="line">该单位的双字母国家/地区代码是什么?</span><br><span class="line">[<span class="symbol">Unknown</span>]: <span class="link">cn</span></span><br><span class="line">CN=localhost, OU=xa, O=xa, L=xi'an, ST=xi'an, C=cn 是否正确</span><br><span class="line">?</span><br><span class="line">[<span class="symbol">否</span>]: <span class="link">y</span></span><br><span class="line">输入 <span class="xml"><span class="tag">&lt;<span class="name">localhost</span>&gt;</span></span> 的密钥口令</span><br><span class="line">(如果和密钥库口令相同, 按回车):</span><br></pre></td></tr></table></figure><p>需要注意的是 “您的名字与姓氏是什么?”这个地方不能随便填的，如果运行过程中提示“Caused by: java.security.cert.CertificateException: No name matching localhost found”那么就是因为这里设置错了，当然除了localhost也可以写其他的，如helloworld.com，但是需要能解析出来，可以直接在hosts中加<code>127.0.0.1 helloworld.com</code></p><p>然后，由于Tomcat默认没有开HTTPS，所以我们需要在server.xml文件中找到8443出现的地方。然后修改如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8443"</span> <span class="attribute">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attribute">SSLEnabled</span>=<span class="string">"true"</span></span><br><span class="line">    <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">scheme</span>=<span class="string">"https"</span> <span class="attribute">secure</span>=<span class="string">"true"</span></span><br><span class="line">    <span class="attribute">clientAuth</span>=<span class="string">"false"</span> <span class="attribute">sslProtocol</span>=<span class="string">"TLS"</span></span><br><span class="line">    <span class="attribute">keystoreFile</span>=<span class="string">"D:\localhost.keystore"</span> <span class="attribute">keystorePass</span>=<span class="string">"123456"</span>/&gt;</span><br></pre></td></tr></table></figure><p>keystorePass 就是生成 keystore 时设置的密码。</p><p>如果出现下面的问题，修改server.xml中的protocol为<code>org.apache.coyote.http11.Http11Protocol</code></p><p>Failed to initialize end point associated with ProtocolHandler [“http-apr-8443”]<br>java.lang.Exception: Connector attribute SSLCertificateFile must be defined when using SSL with APR</p><p>因为 CAS client 需要使用该证书进行验证，所以我们要使用 localhost.keystore 导出数字证书（公钥）到 D:\localhost.cer。再将将证书导入到 JDK 中。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -<span class="keyword">alias</span> localhost -file <span class="symbol">D:</span>\localhost.cer -keystore <span class="symbol">D:</span>\localhost.keystore</span><br><span class="line">cd <span class="symbol">D:</span>\jdk1.<span class="number">7.0_21</span>\jre\<span class="class"><span class="keyword">lib</span>\<span class="title">security</span></span></span><br><span class="line">keytool -import -<span class="keyword">alias</span> localhost -file <span class="symbol">D:</span>\localhost.cer -noprompt -trustcacerts -storetype jks -keystore cacerts -storepass <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>如果导入失败，可以先把 security 目录下的 cacerts 删掉</p><p>搞定证书之后，我们需要将之前client中配置的地址修改一下。然后还可以添加ssl过滤器。</p><p>如果遇到以下异常，一般是证书导入错误造成的，请尝试重新导入，如果还是不行，有可能是运行应用的 JDK 和安装数字证书的 JDK 不是同一个造成的：</p><p>Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</p><h3 id="单点登出重定向"><a href="#单点登出重定向" class="headerlink" title="单点登出重定向"></a>单点登出重定向</h3><p>客户端中配置logout过滤器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"logoutFilter"</span> <span class="built_in">class</span>=<span class="string">"org.apache.shiro.web.filter.authc.LogoutFilter"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"redirectUrl"</span> value=<span class="string">"$&#123;shiro.logout.url&#125;"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>WEB-INF/cas-servlet.xml中将 <code>cas.logout.followServiceRedirects</code>修改为true即可在登出后重定向到service参数提供的地址</p><h3 id="单点登出"><a href="#单点登出" class="headerlink" title="单点登出"></a>单点登出</h3><p>单点登出重定向是很好解决了，但是在客户端与shiro集成过程中，如客户端部署部分所述，如果shiro没有使用 ServletContainerSessionManager 管理session，单点登出就会有问题了。最简单奏效的办法就是改用 ServletContainerSessionManager 了，但是我们偏要用 DefaultWebSessionManager 呢，那就应该要参考org.jasig.cas.client.session这个包中的几个类，重新实现单点登出了。我的思路是，添加一个shiro过滤器，继承自AdviceFilter在preHandle方法中实现逻辑：如果请求中包含了ticket参数，记录ticket和sessionID的映射；如果请求中包含logoutRequest参数，标记session为无效；如果session不为空，且被标记为无效，则登出。如果请求中包含了logoutRequest参数，那么这个请求是从cas服务器发出的，所以这里不能直接用subject.logout()，因为subject跟线程绑定，客户端对cas服务器端的请求会创建一个新的subject。</p><p>那么CAS单点登出是怎么实现的呢，下面是我对CAS单点登出的简单理解：</p><p>在TicketGrantingTicketImpl有一个HashMap&lt;String, Service&gt; services字段，以id和通过认证的客户端service为键值对。当我们要登出时LogoutManagerImpl通过for (final String ticketId : services.keySet())向每个service发送一个POST请求，请求中包含一个logoutRequest参数，参数的值由SamlCompliantLogoutMessageCreator创建。客户端的 SingleSignOutFilter会判断请求中是否包含了logoutRequest参数，如果包含，那么销毁session。SingleSignOutHttpSessionListener实现了javax.servlet.http.HttpSessionListener接口，用于监听session销毁事件。</p><p>我在配置的过程中发现单点登出有问题，首先在服务端打开 debug log，cas 服务器默认是打开单点登出功能的，所以正常的话日志中会记录<code>&lt;Sending logout request for: [https://localhost:8443/cas-client1/cas]&gt;</code>之类的内容，有日志记录发送了请求，一般服务器应该不会有什么问题了。那么有可能会是客户端的问题，我重新配置了一个客户端，这个客户端没有使用spring也没有使用shiro，只用了在部署客户端中提到的无spring的web.xml文件，发现从其他客户端登出，这个客户端也是登出的，所以这个配置是没有什么问题。后来在浏览器打开控制台才发现有两个SESSIONID一个是sid是在shiro中配置的，另一个是JSESSIONID，应该是容器原生的。再然后就下了3.2.2版本的cas-client-core，通过maven构建，导入eclipse中，开始调试。我们的cas-client要依赖这个cas-client-core工程，怎么设置可以参考<a href="http://howiefh.github.io/2014/02/08/eclipse-tips/">eclipse小技巧</a>。然后调试，一定要保证在cas-client的propertie 设置中的Deployment Assembly中已经没有之前的版本的cas-client-core的jar包了。调试的过程中才发现，SingleSignOutFilter销毁的是容器原生的session，但是shiro的session还在，所以如果是从其他客户端登出的，那这个客户端还是能够登录。</p><h3 id="通过数据库中的用户密码认证"><a href="#通过数据库中的用户密码认证" class="headerlink" title="通过数据库中的用户密码认证"></a>通过数据库中的用户密码认证</h3><p>服务器端需要添加cas-server-support-jdbc和mysql-connector-java依赖。</p><p>cas-server-support-jdbc提供了org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler、org.jasig.cas.adaptors.jdbc.SearchModeSearchDatabaseAuthenticationHandler 和org.jasig.cas.adaptors.jdbc.QueryAndEncodeDatabaseAuthenticationHandler。他们都继承自AbstractJdbcUsernamePasswordAuthenticationHandler 能够通过配置sql语句验证用户凭证，后者更复杂些，能够配置盐，散列函数迭代次数。</p><p>下面说一下配置QueryDatabaseAuthenticationHandler，配置/src/main/webapp/WEB-INF/deployerConfigContext.xml，先注释掉原先的primaryAuthenticationHandler然后添加下面配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 自定义数据库鉴权 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"primaryAuthenticationHandler"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sql"</span>  <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;auth.sql&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordEncoder"</span> <span class="attr">ref</span>=<span class="string">"MD5PasswordEncoder"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 数据源 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;dataSource.driver&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;dataSource.url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;dataSource.username&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;dataSource.password&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="comment">&lt;!-- MD5加密 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MD5PasswordEncoder"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.handler.DefaultPasswordEncoder"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"MD5"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>加密算法可以自定义。</p><h3 id="添加验证码"><a href="#添加验证码" class="headerlink" title="添加验证码"></a>添加验证码</h3><p>验证码的实现使用了kaptcha，所以需要添加其依赖。</p><p>web.xml添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.google.code.kaptcha.servlet.KaptchaServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定宽度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>kaptcha.image.width<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定高度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>kaptcha.image.height<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>50<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果需要全部是数字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>kaptcha.textproducer.char.string<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0123456789<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 去掉干扰线 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>kaptcha.noise.impl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.google.code.kaptcha.impl.NoNoise <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/captcha.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在login-webflow.xml中找到viewLoginForm，在binder节点下面添加<code>&lt;binding property=&quot;captcha&quot; /&gt;</code>，对应我们页面提交的验证码参数</p><p>然后我们还要实现一个UsernamePasswordCaptchaCredential 类，继承UsernamePasswordCredential 在其中添加了captcha字段和相应setter和getter方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordCaptchaCredential</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordCredential</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">-2988130322912201986</span>L;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size</span>(min=<span class="number">1</span>,message = <span class="string">"required.captcha"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> captcha;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set、get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着回到 login-webflow.xml ，找到credential的声明处，将org.jasig.cas.authentication.UsernamePasswordCredential修改为刚刚实现的类全路径名。viewLoginForm 也需要修改</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition <span class="keyword">on</span>=<span class="string">"submit"</span> bind=<span class="string">"true"</span> validate=<span class="string">"true"</span> <span class="keyword">to</span>=<span class="string">"validatorCaptcha"</span>&gt;</span><br><span class="line">    &lt;evaluate expression=<span class="string">"authenticationViaFormAction.doBind(flowRequestContext, flowScope.credential)"</span> /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>再添加如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加一个 validatorCaptcha 校验验证码的操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action-state</span> <span class="attr">id</span>=<span class="string">"validatorCaptcha"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">evaluate</span> <span class="attr">expression</span>=<span class="string">"authenticationViaFormAction.validatorCaptcha(flowRequestContext, flowScope.credential, messageContext)"</span>&gt;</span><span class="tag">&lt;/<span class="name">evaluate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">"error"</span> <span class="attr">to</span>=<span class="string">"generateLoginTicket"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">on</span>=<span class="string">"success"</span> <span class="attr">to</span>=<span class="string">"realSubmit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action-state</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在配置中添加了一个 validatorCaptcha 的操作，同时可以看到 expression 是 authenticationViaFormAction.validatorCaptcha(…)，所以我们需要在  authenticationViaFormAction 中添加一个校验验证码的方法 validatorCaptcha()。authenticationViaFormAction 这个bean是配置在 cas-servlet.xml 中的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"authenticationViaFormAction"</span> <span class="attribute">class</span>=<span class="string">"org.jasig.cas.web.flow.AuthenticationViaFormAction"</span></span><br><span class="line">    p:<span class="attribute">centralAuthenticationService-ref</span>=<span class="string">"centralAuthenticationService"</span></span><br><span class="line">    p:<span class="attribute">warnCookieGenerator-ref</span>=<span class="string">"warnCookieGenerator"</span></span><br><span class="line">    p:<span class="attribute">ticketRegistry-ref</span>=<span class="string">"ticketRegistry"</span>/&gt;</span><br></pre></td></tr></table></figure><p>我们可以看看 org.jasig.cas.web.flow.AuthenticationViaFormAction 的源代码，里面有一个 submit 方法，这个就是我们提交表单时的方法了。继承AuthenticationViaFormAction实现一个新类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationViaFormAction</span> <span class="keyword">extends</span> <span class="title">AuthenticationViaFormAction</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">final</span> <span class="type">String</span> validatorCaptcha(<span class="keyword">final</span> <span class="type">RequestContext</span> context, <span class="keyword">final</span> <span class="type">Credential</span> credential,</span><br><span class="line">            <span class="keyword">final</span> <span class="type">MessageContext</span> messageContext)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">HttpServletRequest</span> request = <span class="type">WebUtils</span>.getHttpServletRequest(context);</span><br><span class="line">            <span class="type">HttpSession</span> session = request.getSession();</span><br><span class="line">            <span class="type">String</span> captcha = (<span class="type">String</span>)session.getAttribute(com.google.code.kaptcha.<span class="type">Constants</span>.<span class="type">KAPTCHA_SESSION_KEY</span>);</span><br><span class="line">            session.removeAttribute(com.google.code.kaptcha.<span class="type">Constants</span>.<span class="type">KAPTCHA_SESSION_KEY</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">UsernamePasswordCaptchaCredential</span> upc = (<span class="type">UsernamePasswordCaptchaCredential</span>)credential;</span><br><span class="line">            <span class="type">String</span> submitAuthcodeCaptcha =upc.getCaptcha();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="type">StringUtils</span>.hasText(submitAuthcodeCaptcha) || !<span class="type">StringUtils</span>.hasText(submitAuthcodeCaptcha))&#123;</span><br><span class="line">                messageContext.addMessage(<span class="keyword">new</span> <span class="type">MessageBuilder</span>().code(<span class="string">"required.captcha"</span>).build());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(submitAuthcodeCaptcha.equals(captcha))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            messageContext.addMessage(<span class="keyword">new</span> <span class="type">MessageBuilder</span>().code(<span class="string">"error.authentication.captcha.bad"</span>).build());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边有抛出两个异常，这两个异常信息 required.captcha、error.authentication.captcha.bad 需要在 messages_zh_CN.properties 文件下添加</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">required.captcha</span>=必须输入验证码。</span><br><span class="line"><span class="attr">error.authentication.captcha.bad</span>=您输入的验证码有误。</span><br></pre></td></tr></table></figure><p>然后把 authenticationViaFormAction 这个Bean路径修改为我们新添加的类的全路径名。</p><p>当然最后，我们的页面也需要修改，找到casLoginView.jsp添加</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">spring:message</span> <span class="attr">code</span>=<span class="string">"screen.welcome.label.captcha.accesskey"</span> <span class="attr">var</span>=<span class="string">"captchaAccessKey"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">spring:message</span> <span class="attr">code</span>=<span class="string">"screen.welcome.label.captcha"</span> <span class="attr">var</span>=<span class="string">"captchaHolder"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">form:input</span> <span class="attr">cssClass</span>=<span class="string">"required"</span> <span class="attr">cssErrorClass</span>=<span class="string">"error"</span> <span class="attr">id</span>=<span class="string">"captcha"</span> <span class="attr">size</span>=<span class="string">"10"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>  <span class="attr">path</span>=<span class="string">"captcha"</span> <span class="attr">placeholder</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;captchaHolder &#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">accesskey</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;captchaAccessKey&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> <span class="attr">htmlEscape</span>=<span class="string">"true"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;captchaHolder &#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">src</span>=<span class="string">"captcha.jpg"</span> <span class="attr">onclick</span>=<span class="string">"this.src='captcha.jpg?'+Math.random();"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>以上添加验证码参考<a href="http://www.cnblogs.com/vhua/p/cas_3.html" target="_blank" rel="noopener">http://www.cnblogs.com/vhua/p/cas_3.html</a></p><h3 id="添加记住密码"><a href="#添加记住密码" class="headerlink" title="添加记住密码"></a>添加记住密码</h3><p>可以参考<a href="http://jasig.github.io/cas/development/installation/Configuring-LongTerm-Authentication.html" target="_blank" rel="noopener">http://jasig.github.io/cas/development/installation/Configuring-LongTerm-Authentication.html</a></p><p>在cas.properties中添加如下配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Long term authentication session length in seconds</span></span><br><span class="line"><span class="attr">rememberMeDuration</span>=<span class="number">1209600</span></span><br></pre></td></tr></table></figure><p>spring-configuration文件夹下找到 ticketExpirationPolicies.xml 和 ticketGrantingTicketCookieGenerator.xml 需要在这两个配置文件中定义长期有效的session</p><p>在 ticketExpirationPolicies.xml文件中更新如下配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"standardSessionTGTExpirationPolicy"</span></span><br><span class="line">      <span class="attribute">class</span>=<span class="string">"org.jasig.cas.ticket.support.TicketGrantingTicketExpirationPolicy"</span></span><br><span class="line">      p:<span class="attribute">maxTimeToLiveInSeconds</span>=<span class="string">"<span class="variable">$&#123;tgt.maxTimeToLiveInSeconds:28800&#125;</span>"</span></span><br><span class="line">      p:<span class="attribute">timeToKillInSeconds</span>=<span class="string">"<span class="variable">$&#123;tgt.timeToKillInSeconds:7200&#125;</span>"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">   | The following<span class="built_in"> policy </span>applies <span class="keyword">to</span> long term CAS SSO sessions.</span><br><span class="line">   |<span class="built_in"> Default </span>duration is two weeks (1209600s).</span><br><span class="line">   --&gt;</span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"longTermSessionTGTExpirationPolicy"</span></span><br><span class="line">      <span class="attribute">class</span>=<span class="string">"org.jasig.cas.ticket.support.TimeoutExpirationPolicy"</span></span><br><span class="line">      c:<span class="attribute">timeToKillInMilliSeconds</span>=<span class="string">"#&#123; <span class="variable">$&#123;rememberMeDuration:1209600&#125;</span> * 1000 &#125;"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"grantingTicketExpirationPolicy"</span></span><br><span class="line">      <span class="attribute">class</span>=<span class="string">"org.jasig.cas.ticket.support.RememberMeDelegatingExpirationPolicy"</span></span><br><span class="line">      p:<span class="attribute">sessionExpirationPolicy-ref</span>=<span class="string">"standardSessionTGTExpirationPolicy"</span></span><br><span class="line">      p:<span class="attribute">rememberMeExpirationPolicy-ref</span>=<span class="string">"longTermSessionTGTExpirationPolicy"</span> /&gt;</span><br></pre></td></tr></table></figure><p>更新ticketGrantingTicketCookieGenerator.xml</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"ticketGrantingTicketCookieGenerator"</span> <span class="attribute">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span><br><span class="line">      p:<span class="attribute">cookieSecure</span>=<span class="string">"true"</span></span><br><span class="line">      p:<span class="attribute">cookieMaxAge</span>=<span class="string">"-1"</span></span><br><span class="line">      p:<span class="attribute">rememberMeMaxAge</span>=<span class="string">"<span class="variable">$&#123;rememberMeDuration:1209600&#125;</span>"</span></span><br><span class="line">      p:<span class="attribute">cookieName</span>=<span class="string">"CASTGC"</span></span><br><span class="line">      p:<span class="attribute">cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span><br></pre></td></tr></table></figure><p>在 deployerConfigContext.xml 中找到 PolicyBasedAuthenticationManager 使其包含RememberMeAuthenticationMetaDataPopulator组件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"authenticationMetaDataPopulators"</span>&gt;</span><br><span class="line">&lt;<span class="built_in">list</span>&gt;</span><br><span class="line">&lt;bean</span><br><span class="line"><span class="built_in">class</span>=<span class="string">"org.jasig.cas.authentication.SuccessfulHandlerMetaDataPopulator"</span> /&gt;</span><br><span class="line">&lt;bean</span><br><span class="line"><span class="built_in">class</span>=<span class="string">"org.jasig.cas.authentication.principal.RememberMeAuthenticationMetaDataPopulator"</span> /&gt;</span><br><span class="line">&lt;/<span class="built_in">list</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure><p>和添加验证码类似的，我们还需要修改login-webflow.xml</p><p>找到credential 的声明修改如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">var</span> name=<span class="string">"credential"</span> <span class="keyword">class</span>=<span class="string">"org.jasig.cas.authentication.RememberMeUsernamePasswordCredential"</span> /&gt;</span><br></pre></td></tr></table></figure><p>由于之前已经实现了验证码，所以这里不需要修改了，只需让 UsernamePasswordCaptchaCredential继承RememberMeUsernamePasswordCredential即可</p><p>找到viewLoginForm 在binder节点下添加<code>&lt;binding property=&quot;rememberMe&quot; /&gt;</code></p><p>更新 casLoginView.jsp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;section <span class="attribute">class</span>=<span class="string">"row check"</span>&gt;</span><br><span class="line">    &lt;input <span class="attribute">id</span>=<span class="string">"rememberMe"</span> <span class="attribute">name</span>=<span class="string">"rememberMe"</span> <span class="attribute">value</span>=<span class="string">"false"</span> <span class="attribute">tabindex</span>=<span class="string">"4"</span> <span class="attribute">accesskey</span>=<span class="string">"&lt;spring:message code="</span>screen.welcome.label.rememberMe.accesskey" /&gt;<span class="string">" type="</span>checkbox<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">    &lt;label for="</span>rememberMe<span class="string">"&gt;&lt;spring:message code="</span>screen.welcome.label.rememberMe<span class="string">" /&gt;&lt;/label&gt;</span></span><br><span class="line"><span class="string">&lt;/section&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义primaryAuthenticationHandler"><a href="#自定义primaryAuthenticationHandler" class="headerlink" title="自定义primaryAuthenticationHandler"></a>自定义primaryAuthenticationHandler</h3><p>虽然已经有QueryDatabaseAuthenticationHandler和QueryAndEncodeDatabaseAuthenticationHandler两个类，能够通过配置sql语句验证用户凭证，后者还能配置盐，散列函数迭代次数。但是我们可能还需要判断用户是否被锁定或被禁用了，我们可以参考QueryAndEncodeDatabaseAuthenticationHandler自定义一个AuthenticationHandler，继承AbstractJdbcUsernamePasswordAuthenticationHandler。添加两个字段名lockedFieldName和disabledFieldName通过这两个字段判断用户是否被锁定或被禁用，关键代码如下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ValidUserQueryDBAuthenticationHandler extends AbstractJdbcUsernamePasswordAuthenticationHandler&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DEFAULT_LOCKED_FIELD = <span class="string">"locked"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DEFAULT_DISABLED_FIELD = <span class="string">"disabled"</span>;</span><br><span class="line">    ......</span><br><span class="line">    @NotNull</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">String</span> disabledFieldName = DEFAULT_DISABLED_FIELD;</span><br><span class="line">    @NotNull</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">String</span> lockedFieldName = DEFAULT_LOCKED_FIELD;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> ValidUserQueryDBAuthenticationHandler(<span class="keyword">final</span> DataSource datasource, <span class="keyword">final</span> <span class="keyword">String</span> sql, <span class="keyword">final</span> <span class="keyword">String</span> algorithmName) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        setDataSource(datasource);</span><br><span class="line">        <span class="keyword">this</span>.sql = sql;</span><br><span class="line">        <span class="keyword">this</span>.algorithmName = algorithmName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HandlerResult authenticateUsernamePasswordInternal(<span class="keyword">final</span> UsernamePasswordCredential transformedCredential)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException, PreventedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> username = getPrincipalNameTransformer().transform(transformedCredential.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; values = getJdbcTemplate().queryForMap(<span class="keyword">this</span>.sql, username);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(values.<span class="built_in">get</span>(<span class="keyword">this</span>.disabledFieldName))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountDisabledException(username + <span class="string">"  has been disabled."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(values.<span class="built_in">get</span>(<span class="keyword">this</span>.lockedFieldName))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountLockedException(username + <span class="string">"  has been locked."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">String</span> digestedPassword = digestEncodedPassword(transformedCredential.getPassword(), values);</span><br><span class="line">            <span class="keyword">if</span> (!values.<span class="built_in">get</span>(<span class="keyword">this</span>.passwordFieldName).equals(digestedPassword)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FailedLoginException(<span class="string">"Password does not match value on record."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> createHandlerResult(transformedCredential,</span><br><span class="line">                    <span class="keyword">new</span> SimplePrincipal(username), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IncorrectResultSizeDataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getActualSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountNotFoundException(username + <span class="string">" not found with SQL query"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FailedLoginException(<span class="string">"Multiple records found for "</span> + username);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> DataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PreventedException(<span class="string">"SQL exception while executing query for "</span> + username, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">String</span> digestEncodedPassword(<span class="keyword">final</span> <span class="keyword">String</span> encodedPassword, <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; values) &#123;</span><br><span class="line">        <span class="keyword">final</span> ConfigurableHashService hashService = <span class="keyword">new</span> DefaultHashService();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(<span class="keyword">this</span>.staticSalt)) &#123;</span><br><span class="line">            hashService.setPrivateSalt(ByteSource.Util.bytes(<span class="keyword">this</span>.staticSalt));</span><br><span class="line">        &#125;</span><br><span class="line">        hashService.setHashAlgorithmName(<span class="keyword">this</span>.algorithmName);</span><br><span class="line"></span><br><span class="line">        Long numOfIterations = <span class="keyword">this</span>.numberOfIterations;</span><br><span class="line">        <span class="keyword">if</span> (values.containsKey(<span class="keyword">this</span>.numberOfIterationsFieldName)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">String</span> longAsStr = values.<span class="built_in">get</span>(<span class="keyword">this</span>.numberOfIterationsFieldName).toString();</span><br><span class="line">            numOfIterations = Long.valueOf(longAsStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashService.setHashIterations(numOfIterations.intValue());</span><br><span class="line">        <span class="keyword">if</span> (!values.containsKey(<span class="keyword">this</span>.saltFieldName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Specified field name for salt does not exist in the results"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> dynaSalt = values.<span class="built_in">get</span>(<span class="keyword">this</span>.saltFieldName)==<span class="keyword">null</span>?<span class="string">""</span>:values.<span class="built_in">get</span>(<span class="keyword">this</span>.saltFieldName).toString();</span><br><span class="line">        <span class="keyword">final</span> HashRequest request = <span class="keyword">new</span> HashRequest.Builder()</span><br><span class="line">                                    .setSalt(dynaSalt)</span><br><span class="line">                                    .setSource(encodedPassword)</span><br><span class="line">                                    .build();</span><br><span class="line">        <span class="keyword">return</span> hashService.computeHash(request).toHex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setDisabledFieldName(<span class="keyword">final</span> <span class="keyword">String</span> disabledFieldName) &#123; <span class="keyword">this</span>.disabledFieldName = disabledFieldName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setLockedFieldName(<span class="keyword">final</span> <span class="keyword">String</span> lockedFieldName) &#123; <span class="keyword">this</span>.lockedFieldName = lockedFieldName; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更新配置deployerConfigContext.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"primaryAuthenticationHandler"</span> <span class="attr">class</span>=<span class="string">"io.github.howiefh.cas.authentication.ValidUserQueryDBAuthenticationHandler"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;auth.sql&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"MD5"</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h3><ol><li>在cas.properties 修改 cas.viewResolver.basename  值为 custom_view ，那样系统就会自动会查找 custom_view.properties 这个配置文件</li><li>直接复制原来的 default_views.properties 就行了，重命名为custom_view.properties</li><li>把 custom_view.properties 中的WEB-INF\view\jsp\default全部替换把这地址替换成 WEB-INF\view\jsp\custom</li><li>接下来把 cas\WEB-INF\view\jsp\default 下面的所有文件复制，然后重命名为我们需要的名称，cas\WEB-INF\view\jsp\custom</li></ol><p>主要修改casLoginView.jsp和cas.css即可</p><p>布局时遇到一个问题，就是将页脚固定在页面底部。可以参看<a href="http://www.w3cplus.com/css/css-sticky-foot-at-bottom-of-the-page" target="_blank" rel="noopener">如何将页脚固定在页面底部</a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="http://www.cnblogs.com/vhua/p/cas_4.html" target="_blank" rel="noopener">【SSO单点系列】（4）：CAS4.0 SERVER登录后用户信息的返回</a><br><a href="http://www.cnblogs.com/huangbin/p/3282643.html" target="_blank" rel="noopener">在多点环境下使用cas实现单点登陆及登出</a><br><a href="http://blog.csdn.net/tch918/article/details/22316175" target="_blank" rel="noopener">关于单点登录中的用户信息存储问题的探讨</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从结构来看，CAS主要分为Server和Client。Server主要负责对用户的认证工作；Client负责处理客户端受保护资源的访问请求，登录时，重定向到Server进行认证。</p><p>基础模式的SSO访问流程步骤：</p><ol><li>访问服务：客户端发送请求访问应用系统提供的服务资源。</li><li>定向认证：客户端重定向用户请求到中心认证服务器。</li><li>用户认证：用户进行身份认证</li><li>发放票据：服务器会产生一个随机的 Service Ticket 。</li><li>验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。</li><li>传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。</li></ol><p>CAS最基本的协议过程：</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/cas-clip.jpg" alt="CAS 最基本的协议过程"></p><p>如上图： CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web 请求，同时， CAS Client 会分析 HTTP 请求中是否包含请求 Service Ticket( ST 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的；于是 CAS Client 会重定向用户请求到 CAS Server （ Step 2 ），并传递 Service （要访问的目的资源地址）。 Step 3 是用户认证过程，如果用户提供了正确的 Credentials ， CAS Server 随机产生一个相当长度、唯一、不可伪造的 Service Ticket ，并缓存以待将来验证，并且重定向用户到 Service 所在地址（附带刚才产生的 Service Ticket ） , 并为客户端浏览器设置一个 Ticket Granted Cookie （ TGC ） ； CAS Client 在拿到 Service 和新产生的 Ticket 过后，在 Step 5 和 Step6 中与 CAS Server 进行身份核实，以确保 Service Ticket 的合法性。</p><p>在该协议中，所有与 CAS Server 的交互均采用 SSL 协议，以确保 ST 和 TGC 的安全性。协议工作过程中会有两次重定向的过程。但是 CAS Client 与 CAS Server 之间进行 Ticket 验证的过程对于用户是透明的（使用 HttpsURLConnection ）。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>TGT、ST、PGT、PGTIOU、PT，其中TGT、ST是CAS1.0协议中就有的票据，PGT、PGTIOU、PT是CAS2.0协议中有的票据。</p><p>CAS为用户签发登录票据，CAS认证成功后，将TGT对象放入自己的缓存，CAS生成cookie即TGC，自后登录时如果有TGC的话，则说明用户之前登录过，如果没有，则用户需要重新登录。</p><ul><li>TGC （Ticket-granting cookie）：存放用户身份认证凭证的cookie，在浏览器和CAS Server用来明确用户身份的凭证。</li><li>ST（Service Ticket）：CAS服务器通过浏览器分发给客户端服务器的票据。一个特定服务只能有一个唯一的ST。</li><li>PGT（Proxy Granting Ticket）：由 CAS Server 颁发给拥有 ST 凭证的服务， PGT 绑定一个用户的特定服务，使其拥有向 CAS Server 申请，获得 PT 的能力。</li><li>PGTIOU（全称 Proxy Granting Ticket I Owe You）：作用是将通过凭证校验时的应答信息由 CAS Server 返回给 CAS Client ，同时，与该 PGTIOU 对应的 PGT 将通过回调链接传给 Web 应用。 Web 应用负责维护 PGTIOU 与 PGT 之间映射关系的内容表。PGTIOU是CAS的serviceValidate接口验证ST成功后，CAS会生成验证ST成功的xml消息，返回给Proxy Service，xml消息中含有PGTIOU，proxy service收到Xml消息后，会从中解析出PGTIOU的值，然后以其为key，在map中找出PGT的值，赋值给代表用户信息的Assertion对象的pgtId，同时在map中将其删除。</li><li>PT（Proxy Ticket）：是应用程序代理用户身份对目标程序进行访问的凭证；</li></ul><p>CAS 基本流程图（没有使用PROXY代理）</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/cas-noproxy.png" alt="CAS 基本流程图（没有使用PROXY代理）"></p><p>对于客户端来说会通过客户端session判断用户是否已认证，没有的话跳转到服务器认证，对于服务器，通过SSO session判断用户是否认证，没有的话跳到登录页面。</p><p>CAS 基本流程图（使用PROXY代理）</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/cas-proxy.png" alt="CAS 基本流程图（使用PROXY代理）"></p><p>这一节参考：</p><p><a href="http://www.cnblogs.com/vhua/p/cas_6.html" target="_blank" rel="noopener">【SSO单点系列】（6）：CAS4.0 单点流程序列图（中文版）以及相关术语解释（TGT、ST、PGT、PT、PGTIOU）</a><br><a href="http://www.coin163.com/java/cas/cas.html" target="_blank" rel="noopener">CAS实现SSO单点登录原理</a></p><p>代码:<a href="https://github.com/howiefh/framework/tree/shiro-cas-sso" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      Shiro; CAS; SSO; Shrio 单点登录；单点登出；单点登录 验证码；单点登录 记住密码；单点登陆 查询数据库; 单点登录 自定义
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/categories/Java/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://howiefh.github.io/tags/Shiro/"/>
    
      <category term="CAS" scheme="http://howiefh.github.io/tags/CAS/"/>
    
      <category term="SSO" scheme="http://howiefh.github.io/tags/SSO/"/>
    
  </entry>
  
  <entry>
    <title>Shiro笔记</title>
    <link href="http://howiefh.github.io/2015/05/12/shiro-note/"/>
    <id>http://howiefh.github.io/2015/05/12/shiro-note/</id>
    <published>2015-05-12T02:03:26.000Z</published>
    <updated>2020-05-04T11:16:57.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Shiro是一个强大易用的Java安全框架，可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/shiro-func.png" alt="Shiro基本功能"></p><ul><li>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</li><li>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li><li>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</li><li>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li>Web Support：Web支持，可以非常容易的集成到Web环境；</li><li>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li><li>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li>Testing：提供测试支持；</li><li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li></ul><a id="more"></a><p><strong>记住一点，Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</strong></p><p>Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图： </p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/shiro-core.png" alt="Shiro框架图"></p><p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。与Subject的所有交互都会委托给SecurityManager。 </p><p>SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。可以把它看成 DispatcherServlet 前端控制器 </p><p>Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。 </p><p>Shiro完整架构图： </p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/shiro-frame.png" alt="Shiro框架图"></p><ul><li><p>Subject (org.apache.shiro.subject.Subject)<br>  正在与软件交互的一个特定的实体“view”（用户、第三方服务、时钟守护任务等）。</p></li><li><p>SecurityManager (org.apache.shiro.mgt.SecurityManager)<br>  如同上面提到的，SecurityManager 是 Shiro 的核心，它基本上就是一把“保护伞”用来协调它管理的组件使之平稳地一起工作，它也管理着 Shiro 中每一个程序用户的视图，所以它知道每个用户如何执行安全操作。</p></li><li><p>Authenticator(org.apache.shiro.authc.Authenticator)<br>  Authenticator 是一个组件，负责执行和反馈用户的认证（登录），如果一个用户尝试登录，Authenticator 就开始执行。Authenticator 知道如何协调一个或多个保存有相关用户/帐号信息的 Realm，从这些 Realm中获取这些数据来验证用户的身份以确保用户确实是其表述的那个人。</p></li><li><p>Authentication Strategy(org.apache.shiro.authc.pam.AuthenticationStrategy)<br>  如果配置了多个 Realm，AuthenticationStrategy 将会协调 Realm 确定在一个身份验证成功或失败的条件（例如，如果在一个方面验证成功了但其他失败了，这次尝试是成功的吗？是不是需要所有方面的验证都成功？还是只需要第一个？）</p></li><li><p>Authorizer(org.apache.shiro.authz.Authorizer)<br>  Authorizer 是负责程序中用户访问控制的组件，它是最终判断一个用户是否允许做某件事的途径，像 Authenticator 一样，Authorizer 也知道如何通过协调多种后台数据源来访问角色和权限信息，Authorizer 利用这些信息来准确判断一个用户是否可以执行给定的动作。</p></li><li><p>SessionManager(org.apache.shiro.session.mgt.SessionManager)<br>  SessionManager 知道如何创建并管理用户 Session 生命周期而在所有环境中为用户提供一个强有力的 Session 体验。这在安全框架领域是独一无二–Shiro 具备管理在任何环境下管理用户 Session 的能力，即使没有 Web/Servlet 或者 EJB 容器。默认情况下，Shiro 将使用现有的session（如Servlet Container），但如果环境中没有，比如在一个独立的程序或非 web 环境中，它将使用它自己建立的 session 提供相同的作用，sessionDAO 用来使用任何数据源使 session 持久化。</p></li><li><p>SessionDAO(org.apache.shiro.session.mgt.eis.SessionDAO)<br>  SessionDAO 代表 SessionManager 执行 Session 持久（CRUD）动作，它允许任何存储的数据挂接到 session 管理基础上。</p></li><li><p>CacheManager(org.apache.shiro.cache.CacheManager)<br>  CacheManager 为 Shiro 的其他组件提供创建缓存实例和管理缓存生命周期的功能。因为 Shiro 的认证、授权、会话管理支持多种数据源，所以访问数据源时，使用缓存来提高访问效率是上乘的选择。当下主流开源或企业级缓存框架都可以继承到 Shiro 中，来获取更快更高效的用户体验。</p></li><li><p>Cryptography (<code>org.apache.shiro.crypto.*</code>)<br>  Cryptography 在安全框架中是一个自然的附加产物，Shiro 的 crypto 包包含了易用且易懂的加密方式，Hashes（即digests）和不同的编码实现。该包里所有的类都易于理解和使用，曾经用过 Java 自身的加密支持的人都知道那是一个具有挑战性的工作，而 Shiro 的加密 API 简化了 java 复杂的工作方式，将加密变得易用。</p></li><li><p>Realms (org.apache.shiro.realm.Realm)<br>  如同上面提到的，Realm 是 shiro 和你的应用程序安全数据之间的“桥”或“连接”，当实际要与安全相关的数据进行交互如用户执行身份认证（登录）和授权验证（访问控制）时，shiro 从程序配置的一个或多个Realm 中查找这些数据，你需要配置多少个 Realm 便可配置多少个 Realm（通常一个数据源一个），shiro 将会在认证和授权中协调它们。</p></li></ul><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。 </p><h3 id="Shiro认证过程"><a href="#Shiro认证过程" class="headerlink" title="Shiro认证过程"></a>Shiro认证过程</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span></span><br><span class="line">Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line"><span class="comment">//2、得到SecurityManager实例 并绑定给SecurityUtils</span></span><br><span class="line">SecurityManager securityManager = factory.getInstance();</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"><span class="comment">//3、获取当前执行用户:</span></span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">//做点跟 Session 相关的事</span></span><br><span class="line">Session session = currentUser.getSession();</span><br><span class="line">session.setAttribute(<span class="string">"someKey"</span>, <span class="string">"aValue"</span>);</span><br><span class="line"><span class="keyword">String</span> value = (<span class="keyword">String</span>) session.getAttribute(<span class="string">"someKey"</span>);</span><br><span class="line"><span class="keyword">if</span> (value.equals(<span class="string">"aValue"</span>)) &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"Retrieved the correct value! ["</span> + value + <span class="string">"]"</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    <span class="comment">//4、创建用户名/密码身份验证Token（即用户身份/凭证）</span></span><br><span class="line">    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(</span><br><span class="line">            <span class="string">"lonestarr"</span>, <span class="string">"vespa"</span>);</span><br><span class="line">    token.setRememberMe(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//5、登录、即身份验证</span></span><br><span class="line">        currentUser.login(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"There is no user with username of "</span> + token.getPrincipal());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"Password for account "</span> + token.getPrincipal() + <span class="string">" was incorrect!"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"The account for username "</span> + token.getPrincipal() + <span class="string">" is locked. "</span> + <span class="string">"Please contact your administrator to unlock it."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 捕获更多异常</span></span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">        <span class="comment">// 无定义?错误?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 打印主要识别信息 (本例是 username):</span></span><br><span class="line"><span class="built_in">log</span>.info(<span class="string">"User ["</span> + currentUser.getPrincipal() + <span class="string">"] logged in successfully."</span>);</span><br><span class="line"><span class="comment">// 测试角色:</span></span><br><span class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">"schwartz"</span>)) &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"May the Schwartz be with you!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"Hello, mere mortal."</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 测试一个权限 (非（ instance-level） 实例级别)</span></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"lightsaber:weild"</span>)) &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"You may use a lightsaber ring. Use it wisely."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"Sorry, lightsaber rings are for schwartz masters only."</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 一个(非常强大)的实例级别的权限:</span></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"winnebago:drive:eagle5"</span>)) &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. "</span></span><br><span class="line">            + <span class="string">"Here are the keys - have fun!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">"Sorry, you aren't allowed to drive the 'eagle5' winnebago!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、完成 - 退出t!</span></span><br><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure><p>shiro.ini文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Users and their (optional) assigned roles</span></span><br><span class="line"><span class="comment"># username = password, role1, role2, ..., roleN</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">root</span> = secret, admin</span><br><span class="line"><span class="attr">guest</span> = guest, guest</span><br><span class="line"><span class="attr">presidentskroob</span> = <span class="number">12345</span>, president</span><br><span class="line"><span class="attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz</span><br><span class="line"><span class="attr">lonestarr</span> = vespa, goodguy, schwartz</span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment"># roleName = perm1, perm2, ..., permN</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">admin</span> = *</span><br><span class="line"><span class="attr">schwartz</span> = lightsaber:*</span><br><span class="line"><span class="attr">goodguy</span> = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure><p>身份验证的主要流程就是：</p><ol><li>收集用户身份/凭证，即如用户名/密码；</li><li>调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException 异常，根<br>据异常提示用户错误信息；否则登录成功；</li><li>最后调用 Subject.logout 进行退出操作。</li></ol><p><strong>收集实体/凭据信息</strong> </p><p>UsernamePasswordToken支持最常见的用户名/密码的认证机制。同时，由于它实现了RememberMeAuthenticationToken接口，我们可以通过令牌设置“记住我”的功能。但是，“已记住”和“已认证”是有区别的：已记住的用户仅仅是非匿名用户，你可以通过subject.getPrincipals()获取用户信息。但是它并非是完全认证通过的用户，当你访问需要认证用户的功能时，你仍然需要重新提交认证信息。这一区别可以参考亚马逊网站，网站会默认记住登录的用户，再次访问网站时，对于非敏感的页面功能，页面上会显示记住的用户信息，但是当你访问网站账户信息时仍然需要再次进行登录认证。 subject.isAuthenticated()和subject.isRemembered()的值总是相反的。</p><p><strong>提交实体/凭据信息</strong> </p><p>收集了实体/凭据信息之后，我们可以通过SecurityUtils工具类，获取当前的用户，然后通过调用login方法提交认证。 </p><p><strong>认证处理</strong> </p><p>如果login方法执行完毕且没有抛出任何异常信息，那么便认为用户认证通过。之后在应用程序任意地方调用SecurityUtils.getSubject() 都可以获取到当前认证通过的用户实例，使用subject.isAuthenticated()判断用户是否已验证都将返回true. 相反，如果login方法执行过程中抛出异常，那么将认为认证失败。Shiro有着丰富的层次鲜明的异常类来描述认证失败的原因，如代码示例。 </p><p><strong>登出操作</strong> </p><p>登出操作可以通过调用subject.logout()来删除你的登录信息，当执行完登出操作后，Session信息将被清空，subject将被视作为匿名用户。 </p><p>以上，是Shiro认证在应用程序中的处理过程，下面将详细解说Shiro认证的内部处理机制。 </p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/shiro-authentication.png" alt="身份认证流程"></p><p>如上图，我们通过Shiro架构图的认证部分，来说明Shiro认证内部的处理顺序： </p><ol><li>应用程序构建了一个终端用户认证信息的AuthenticationToken 实例后，调用Subject.login方法。 </li><li>Subject的实例通常是DelegatingSubject类（或子类）的实例对象，在认证开始时，会委托应用程序设置的securityManager实例调用securityManager.login(token)方法。 </li><li>SecurityManager接受到token(令牌)信息后会委托内置的Authenticator的实例（通常都是ModularRealmAuthenticator类的实例）调用authenticator.authenticate(token). ModularRealmAuthenticator在认证过程中会对设置的一个或多个Realm实例进行适配，它实际上为Shiro提供了一个可拔插的认证机制。</li><li>如果在应用程序中配置了多个Realm，ModularRealmAuthenticator会根据配置的AuthenticationStrategy(认证策略)来进行多Realm的认证过程。在Realm被调用后，AuthenticationStrategy将对每一个Realm的结果作出响应。注：如果应用程序中仅配置了一个Realm，Realm将被直接调用而无需再配置认证策略。</li><li>判断每一个Realm是否支持提交的token，如果支持，Realm将调用getAuthenticationInfo(token); getAuthenticationInfo 方法就是实际认证处理，我们通过覆盖Realm的doGetAuthenticationInfo方法来编写我们自定义的认证处理。 </li></ol><p>Realm接口中需要实现的方法。</p><p>String getName(); //返回一个唯一的 Realm 名字<br>boolean supports(AuthenticationToken token); //判断此 Realm 是否支持此 Token<br>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; //根据 Token 获取认证信息</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/shiro-realm.png" alt="Realm"></p><p>一般继承AuthorizingRealm即可，需要实现getAuthenticationInfo(AuthenticationToken token)和doGetAuthenticationInfo(PrincipalCollection principals)两个方法</p><p>其中主要默认实现如下：<br>org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息；<br>org.apache.shiro.realm.text.PropertiesRealm：user.username=password,role1,role2 指定用户名/密码及其角色；role.role1=permission1,permission2 指定角色及权限信息；<br>org.apache.shiro.realm.jdbc.JdbcRealm：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">jdbcRealm</span>=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line"><span class="attr">dataSource</span>=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"><span class="attr">dataSource.driverClassName</span>=com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">dataSource.url</span>=jdbc:mysql://localhost:<span class="number">3306</span>/shiro</span><br><span class="line"><span class="attr">dataSource.username</span>=root</span><br><span class="line"><span class="comment">#dataSource.password=</span></span><br><span class="line"><span class="attr">jdbcRealm.dataSource</span>=<span class="variable">$dataSource</span></span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$jdbcRealm</span></span><br></pre></td></tr></table></figure><h3 id="使用多个Realm的处理机制："><a href="#使用多个Realm的处理机制：" class="headerlink" title="使用多个Realm的处理机制："></a>使用多个Realm的处理机制：</h3><p>有些网站既可以用用户名也可以用邮箱、手机登陆，通过多个Realm就可以实现。</p><h4 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h4><p>默认实现是ModularRealmAuthenticator,它既支持单一Realm也支持多个Realm。如果仅配置了一个Realm，ModularRealmAuthenticator 会直接调用该Realm处理认证信息，如果配置了多个Realm，它会根据认证策略来适配Realm，找到合适的Realm执行认证信息。 </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span>  </span><br><span class="line"><span class="comment">#指定 securityManager 的 authenticator 实现</span></span><br><span class="line"><span class="attr">authenticator</span>=org.apache.shiro.authc.pam.ModularRealmAuthenticator</span><br><span class="line"><span class="attr">securityManager.authenticator</span>=<span class="variable">$authenticator</span></span><br></pre></td></tr></table></figure><h4 id="AuthenticationStrategy（认证策略）"><a href="#AuthenticationStrategy（认证策略）" class="headerlink" title="AuthenticationStrategy（认证策略）"></a>AuthenticationStrategy（认证策略）</h4><p>当应用程序配置了多个Realm时，ModularRealmAuthenticator将根据认证策略来判断认证成功或是失败。<br>例如，如果只有一个Realm验证成功，而其他Realm验证失败，那么这次认证是否成功呢？如果大多数的Realm验证成功了，认证是否就认为成功呢？或者，一个Realm验证成功后，是否还需要判断其他Realm的结果？认证策略就是根据应用程序的需要对这些问题作出决断。 </p><p>认证策略是一个无状态的组件，在认证过程中会经过4次的调用： </p><ul><li>在所有Realm被调用之前</li><li>在调用Realm的getAuthenticationInfo 方法之前</li><li>在调用Realm的getAuthenticationInfo 方法之后</li><li>在所有Realm被调用之后</li></ul><p>认证策略的另外一项工作就是聚合所有Realm的结果信息封装至一个AuthenticationInfo实例中，并将此信息返回，以此作为Subject的身份信息。 </p><p>Shiro有3中认证策略的具体实现： </p><ul><li>AtLeastOneSuccessfulStrategy    只要有一个（或更多）的Realm验证成功，那么认证将被视为成功</li><li>FirstSuccessfulStrategy    第一个Realm验证成功，整体认证将被视为成功，且后续Realm将被忽略</li><li>AllSuccessfulStrategy    所有Realm成功，认证才视为成功</li></ul><p>ModularRealmAuthenticator 内置的认证策略默认实现是AtLeastOneSuccessfulStrategy 方式，因为这种方式也是被广泛使用的一种认证策略。当然，你也可以通过配置文件定义你需要的策略，如： </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main]  </span><br><span class="line">authcStrategy = org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.authc</span><span class="selector-class">.pam</span><span class="selector-class">.FirstSuccessfulStrategy</span>  </span><br><span class="line">securityManager<span class="selector-class">.authenticator</span><span class="selector-class">.authenticationStrategy</span> = <span class="variable">$authcStrategy</span></span><br></pre></td></tr></table></figure><h4 id="Realm的顺序"><a href="#Realm的顺序" class="headerlink" title="Realm的顺序"></a>Realm的顺序</h4><p>由刚才提到的认证策略，可以看到Realm在ModularRealmAuthenticator 里面的顺序对认证是有影响的。 </p><p>ModularRealmAuthenticator 会读取配置在SecurityManager里的Realm。当执行认证是，它会遍历Realm集合，对所有支持提交的token的Realm调用getAuthenticationInfo 。 </p><p>因此，如果Realm的顺序对你使用的认证策略结果有影响，那么你应该在配置文件中明确定义Realm的顺序</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权即访问控制，它将判断用户在应用程序中对资源是否拥有相应的访问权限。<br>如，判断一个用户有查看页面的权限，编辑数据的权限，拥有某一按钮的权限，以及是否拥有打印的权限等等。 </p><h3 id="授权的三要素"><a href="#授权的三要素" class="headerlink" title="授权的三要素"></a>授权的三要素</h3><p>授权有着三个核心元素：权限(permissions)、角色(roles)和用户(users)。 </p><p>权限 </p><p>权限是Apache Shiro安全机制最核心的元素。它在应用程序中明确声明了被允许的行为和表现。一个格式良好的权限声明可以清晰表达出用户对该资源拥有的权限。</p><p>大多数的资源会支持典型的CRUD操作（create,read,update,delete）,但是任何操作建立在特定的资源上才是有意义的。因此，权限声明的根本思想就是建立在资源以及操作上。 </p><p>而我们通过权限声明仅仅能了解这个权限可以在应用程序中做些什么，而不能确定谁拥有此权限。权限只描述行为。</p><p>于是，我们就需要在应用程序中对用户和权限建立关联。通常的做法就是将权限分配给某个角色，然后将这个角色关联一个或多个用户。 </p><p><strong>权限声明及粒度</strong> </p><p>Shiro权限声明通常是使用以冒号分隔的表达式。就像前文所讲，一个权限表达式可以清晰的指定资源类型，允许的操作，可访问的数据。同时，Shiro权限表达式支持简单的通配符，可以更加灵活的进行权限设置。 </p><p>字符串通配符权限<br>规则：“资源标识符：操作：对象实例 ID” 即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>:</code>表示资源/操作/实例的分割；<code>,</code>表示操作的分割；<code>*</code>表示任意资源/操作/实例。</p><p>下面以实例来说明权限表达式。<br>可查询用户数据 <code>User:view</code><br>可查询或编辑用户数据 <code>User:view,edit</code><br>可对用户数据进行所有操作 <code>User:* 或 user</code><br>可编辑id为123的用户数据 <code>User:edit:123</code></p><p>注意：通过“system:user:update,delete”验证“system:user:update, system:user:delete”是没问题的，但是反过来是规则不成立。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>Shiro支持两种角色模式： </p><ol><li>传统角色：一个角色代表着一系列的操作，当需要对某一操作进行授权验证时，只需判断是否是该角色即可。这种角色权限相对简单、模糊，不利于扩展。 </li><li>权限角色：一个角色拥有一个权限的集合。授权验证时，需要判断当前角色是否拥有该权限。这种角色权限可以对该角色进行详细的权限描述，适合更复杂的权限设计。 </li></ol><p><a href="www.waylau.com/new-rbac-resource-based-access-control/">新的RBAC：基于资源的权限管理(Resource-Based Access Control)</a></p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>一个用户本质上是程序中的“谁”，如同我们前面提到的，Subject 实际上是 shiro 的“用户”。</p><p>用户（Subjects）通过与角色或权限关联确定是否被允许执行程序内特定的动作，程序数据模型确切定义了 Subject 是否允许做什么事情。Shiro 依赖一个 Realm 实现将你的数据模型关联转换成 Shiro 可以理解的内容</p><h3 id="授权实现"><a href="#授权实现" class="headerlink" title="授权实现"></a>授权实现</h3><p>Shiro支持三种方式实现授权过程： </p><ul><li>编码实现：if(subject.hasRole(“admin”)){//有权限}</li><li>注解实现：@RequiresRoles(“admin”)public void hello() {//有权限}</li><li>JSP Taglig实现：<code>&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt;</code></li></ul><h4 id="基于编码的授权实现"><a href="#基于编码的授权实现" class="headerlink" title="基于编码的授权实现"></a>基于编码的授权实现</h4><p><strong>基于传统角色授权实现</strong></p><p>当需要验证用户是否拥有某个角色时，可以调用Subject 实例的<code>hasRole*</code>方法验证。 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;  </span><br><span class="line"><span class="keyword">if</span> (currentUser.has<span class="constructor">Role(<span class="string">"administrator"</span>)</span>) &#123;  </span><br><span class="line">    <span class="comment">//显示 admin 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关验证方法如下： </p><table><thead><tr><th>Subject方法</th><th>描述</th></tr></thead><tbody><tr><td><code>hasRole(String roleName)</code></td><td>当用户拥有指定角色时，返回true</td></tr><tr><td><code>hasRoles(List&lt;String&gt; roleNames)</code></td><td>按照列表顺序返回相应的一个boolean值数组</td></tr><tr><td><code>hasAllRoles(Collection&lt;String&gt; roleNames)</code></td><td>如果用户拥有所有指定角色时，返回true</td></tr></tbody></table><p>断言支持 </p><p>Shiro还支持以断言的方式进行授权验证。断言成功，不返回任何值，程序继续执行；断言失败时，将抛出异常信息。使用断言，可以使我们的代码更加简洁。 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;  </span><br><span class="line"><span class="comment">//保证当前用户是一个银行出纳员</span></span><br><span class="line"><span class="comment">//因此允许开立帐户：</span></span><br><span class="line">currentUser.check<span class="constructor">Role(<span class="string">"bankTeller"</span>)</span>;  </span><br><span class="line"><span class="keyword">open</span><span class="constructor">BankAccount()</span>;</span><br></pre></td></tr></table></figure><p>断言的相关方法： </p><table><thead><tr><th>Subject方法</th><th>描述</th></tr></thead><tbody><tr><td><code>checkRole(String roleName)</code></td><td>断言用户是否拥有指定角色</td></tr><tr><td><code>checkRoles(Collection&lt;String&gt; roleNames)</code></td><td>断言用户是否拥有所有指定角色</td></tr><tr><td><code>checkRoles(String... roleNames)</code></td><td>对上一方法的方法重载</td></tr></tbody></table><p><strong>基于权限角色授权实现</strong> </p><p>相比传统角色模式，基于权限的角色模式耦合性要更低些，它不会因角色的改变而对源代码进行修改，因此，基于权限的角色模式是更好的访问控制方式。 </p><p>它的代码实现有以下几种实现方式： </p><p><strong>基于权限对象的实现</strong> </p><p>创建org.apache.shiro.authz.Permission的实例，将该实例对象作为参数传递给Subject.isPermitted()进行验证。 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Permission printPermission = <span class="keyword">new</span> <span class="constructor">PrinterPermission(<span class="string">"laserjet4400n"</span>, <span class="string">"print"</span>)</span>;</span><br><span class="line">Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span><br><span class="line"><span class="keyword">if</span> (currentUser.is<span class="constructor">Permitted(<span class="params">printPermission</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">//显示 打印 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关方法如下： </p><table><thead><tr><th>Subject方法</th><th>描述</th></tr></thead><tbody><tr><td><code>isPermitted(Permission p)</code></td><td>Subject拥有制定权限时，返回treu</td></tr><tr><td><code>isPermitted(List&lt;Permission&gt; perms)</code></td><td>返回对应权限的boolean数组</td></tr><tr><td><code>isPermittedAll(Collection&lt;Permission&gt; perms)</code></td><td>Subject拥有所有制定权限时，返回true</td></tr></tbody></table><p><strong>基于字符串的实现</strong> </p><p>相比笨重的基于对象的实现方式，基于字符串的实现便显得更加简洁。 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span><br><span class="line"><span class="keyword">if</span> (currentUser.is<span class="constructor">Permitted(<span class="string">"printer:print:laserjet4400n"</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">//显示 打印 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用冒号分隔的权限表达式是org.apache.shiro.authz.permission.WildcardPermission 默认支持的实现方式。 </p><p>这里分别代表了 资源类型:操作:资源ID </p><p>类似基于对象的实现相关方法</p><table><thead><tr><th>Subject 方法</th><th>描述</th></tr></thead><tbody><tr><td>isPermitted(String perm)</td><td>如果Subject被允许执行字符串表达的动作或资源访问权限，返回真，否则返回假；</td></tr><tr><td>isPermitted(String… perms)</td><td>按照参数顺序返回isPermitted的结果数组，当许多字符串权限需要检查时非常有用（如定制一个复杂的视图时）；</td></tr><tr><td>isPermittedAll(String… perms)</td><td>当Subject具备所有字符串定义的权限时返回真，否则返回假。</td></tr></tbody></table><p><strong>基于权限对象的断言实现</strong> </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span><br><span class="line"><span class="comment">//担保允许当前用户</span></span><br><span class="line"><span class="comment">//开一个银行帐户：</span></span><br><span class="line">Permission p = <span class="keyword">new</span> <span class="constructor">AccountPermission(<span class="string">"open"</span>)</span>;</span><br><span class="line">currentUser.check<span class="constructor">Permission(<span class="params">p</span>)</span>;</span><br><span class="line"><span class="keyword">open</span><span class="constructor">BankAccount()</span>;</span><br></pre></td></tr></table></figure><p><strong>基于字符串的断言实现</strong> </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>;</span><br><span class="line"><span class="comment">//担保允许当前用户</span></span><br><span class="line"><span class="comment">//开一个银行帐户：</span></span><br><span class="line">currentUser.check<span class="constructor">Permission(<span class="string">"account:open"</span>)</span>;</span><br><span class="line"><span class="keyword">open</span><span class="constructor">BankAccount()</span>;</span><br></pre></td></tr></table></figure><p><strong>断言实现的相关方法</strong> </p><table><thead><tr><th>Subject方法</th><th>说明</th></tr></thead><tbody><tr><td><code>checkPermission(Permission p)</code></td><td>断言用户是否拥有制定权限</td></tr><tr><td><code>checkPermission(String perm)</code></td><td>断言用户是否拥有制定权限</td></tr><tr><td><code>checkPermissions(Collection&lt;Permission&gt; perms)</code></td><td>断言用户是否拥有所有指定权限</td></tr><tr><td><code>checkPermissions(String... perms)</code></td><td>断言用户是否拥有所有指定权限</td></tr></tbody></table><h4 id="基于注解的授权实现"><a href="#基于注解的授权实现" class="headerlink" title="基于注解的授权实现"></a>基于注解的授权实现</h4><p>Shiro注解支持AspectJ、Spring、Google-Guice等，可根据应用进行不同的配置。 </p><p>相关的注解：<br>@RequiresAuthentication<br>可以用户类/属性/方法，用于表明当前用户需是经过认证的用户。 </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresAuthentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account userAccount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 保证被认证的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于判断了SecurityUtils.getSubject().isAuthenticated()</p><p>@RequiresGuest<br>表明该用户需为”guest”用户 </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresGuest</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">signUp</span><span class="params">(User newUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 未知/匿名的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于判断了principals == null || principals.isEmpty()</p><p>@RequiresPermissions<br>当前用户需拥指定权限 </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"account:create"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">createAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 允许创建一个 account 的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于判断了subject.isPermitted(“account:create”)</p><p>@RequiresRoles<br>当前用户需拥有指定角色<br>相当于判断了subject.hasRole(“administrator”)</p><p>@RequiresUser<br>当前用户需为已认证用户或已记住用户 </p><h4 id="基于JSP-TAG的授权实现"><a href="#基于JSP-TAG的授权实现" class="headerlink" title="基于JSP TAG的授权实现"></a>基于JSP TAG的授权实现</h4><p>Shiro提供了一套JSP标签库来实现页面级的授权控制。标签库描述文件 (TLD)被打包在 META-INF/shiro.tld 文件中的 shiro-web.jar 文件中。 </p><p>在使用Shiro标签库前，首先需要在JSP引入shiro标签： </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span>@ taglib prefix=<span class="string">"shiro"</span> uri=<span class="string">"http://shiro.apache.org/tags"</span> <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure><p>下面一一介绍Shiro的标签： </p><p>guest标签:验证当前用户是否为“访客”，即未认证（包含未记住）的用户 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span>  </span><br><span class="line">    Hi there!  Please <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.jsp"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">a</span>&gt;</span> or <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"signup.jsp"</span>&gt;</span>Signup<span class="tag">&lt;/<span class="name">a</span>&gt;</span> today!  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>user标签:认证通过或已记住的用户 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span>  </span><br><span class="line">    Welcome back John!  Not John? Click <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.jsp"</span>&gt;</span>here<span class="tag">&lt;<span class="name">a</span>&gt;</span> to login.  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>authenticated标签:已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:authenticated</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"updateAccount.jsp"</span>&gt;</span>Update your contact information<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:authenticated</span>&gt;</span></span><br></pre></td></tr></table></figure><p>notAuthenticated标签:未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:notAuthenticated</span>&gt;</span>  </span><br><span class="line">    Please <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.jsp"</span>&gt;</span>login<span class="tag">&lt;/<span class="name">a</span>&gt;</span> in order to update your credit card information.  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:notAuthenticated</span>&gt;</span></span><br></pre></td></tr></table></figure><p>principal 标签:输出当前用户信息，通常为登录帐号信息 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, <span class="tag">&lt;<span class="name">shiro:principal</span>/&gt;</span>, how are you today?</span><br></pre></td></tr></table></figure><p>principal property</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;shiro:principal <span class="attribute">type</span>=<span class="string">"com.foo.User"</span> <span class="attribute">property</span>=<span class="string">"firstName"</span>/&gt;, how are you today?</span><br></pre></td></tr></table></figure><p>很大程度上等价于</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;%= <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Subject()</span>.get<span class="constructor">Principals()</span>.one<span class="constructor">ByType(<span class="params">com</span>.<span class="params">foo</span>.User.<span class="params">class</span>)</span>.get<span class="constructor">FirstName()</span>.<span class="keyword">to</span><span class="constructor">String()</span> %&gt;, how are you today?</span><br></pre></td></tr></table></figure><p>hasRole标签:验证当前用户是否属于该角色 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"administrator"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"admin.jsp"</span>&gt;</span>Administer the system<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lacksRole标签:与hasRole标签逻辑相反，当用户不属于该角色时验证通过 </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksRole name=<span class="string">"administrator"</span>&gt;  </span><br><span class="line">    Sorry, you are <span class="keyword">not</span> allowed <span class="built_in">to</span> administer <span class="keyword">the</span> <span class="keyword">system</span>.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure><p>hasAnyRole标签:验证当前用户是否属于以下任意一个角色。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasAnyRoles</span> <span class="attr">name</span>=<span class="string">"developer, project manager, administrator"</span>&gt;</span>  </span><br><span class="line">    You are either a developer, project manager, or administrator.  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hasPermission标签:验证当前用户是否拥有制定权限 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"user:create"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lacksPermission标签:与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"user:create"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/Shiro-AuthorizationSequence.png" alt="授权流程"></p><ol><li>程序或框架代码调用一个 Subject 的<code>hasRole*</code>、<code>checkRole*</code>、<code>isPermitted*</code>或者<code>checkPermission*</code>方法，传递所需的权限或角色。</li><li>Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 <code>hasRole*</code>、<code>checkRole*</code>、<code>isPermitted*</code>或<code>checkPermission*</code> 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)。 </li><li>接下来SecurityManager会委托内置的Authorizer的实例（默认是ModularRealmAuthorizer 类的实例，类似认证实例，它同样支持一个或多个Realm实例认证）调用相应的授权方法。 </li><li>每一个Realm将检查是否实现了相同的 Authorizer 接口。然后，将调用Reaml自己的相应的授权验证方法。 </li></ol><p>当使用多个Realm时，不同于认证策略处理方式，授权处理过程中： </p><ol><li>当Realm实现了Authorizer接口<ol><li>当调用Realm出现异常时，将立即抛出异常，结束授权验证。 </li><li>只要有一个Realm验证成功，那么将认为授权成功，立即返回，结束认证。 </li></ol></li><li>如果 Realm 没有实现 Authorizer 接口，将被忽略。</li></ol><p><strong>授权顺序</strong></p><p>ModularRealmAuthorizer 拥有 SecurityManager 配置的 Realm 实例的入口，当执行一个授权操作时，它将在整个集合中进行迭代（iteration），对于每一个实现 Authorizer 接口的 Realm，调用Realm 各自的 Authorizer 方法（如 hasRole、 checkRole、 isPermitted或 checkPermission）。</p><p><strong>配置全局的 PermissionResolver</strong></p><p>当执行一个基于字符串的权限检查时，大部分 Shiro 默认的 Realm 将会在执行权限隐含逻辑之前首先把这个字符串转换成一个常用的权限实例。</p><p>为了这个转换目的，Shiro 支持 PermissionResolver，大部分 Shiro Realm 使用 PermissionResolver 来支持它们对Authorizer 接口中基于字符串权限方法的实现：当这些方法在Realm上被调用时，将使用PermissionResolver 将字符串转换为权限实例，并执行检查。默认使用内部的 WildcardPermissionResolver</p><h2 id="Realms"><a href="#Realms" class="headerlink" title="Realms"></a>Realms</h2><p>在认证、授权内部实现机制中都有提到，最终处理都将交给Realm进行处理。因为在Shiro中，最终是通过Realm来获取应用程序中的用户、角色及权限信息的。通常情况下，在Realm中会直接从我们的数据源中获取Shiro需要的验证信息。可以说，Realm是专用于安全框架的DAO. </p><h3 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h3><p>正如前文所提到的，Shiro的认证过程最终会交由Realm执行，这时会调用Realm的getAuthenticationInfo(token)方法。在一个 Realm 执行一个验证尝试之前，它的supports)方法被调用。只有在返回值为 true 的时候它的getAuthenticationInfo(token) 方法才会执行。因此想要禁用认证过程主要supports始终返回false即可。 </p><p>该方法主要执行以下操作: </p><ol><li>检查提交的进行认证的令牌信息 </li><li>根据令牌信息从数据源(通常为数据库)中获取用户信息 </li><li>确定令牌支持的 credentials (凭证数据)和存储的数据相符。 </li><li>验证通过将返回一个封装了用户信息的AuthenticationInfo实例。 </li><li>验证失败则抛出AuthenticationException异常信息。 </li></ol><p>而在我们的应用程序中要做的就是自定义一个Realm类，继承AuthorizingRealm抽象类，重载doGetAuthenticationInfo()，重写获取用户信息的方法。 </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException &#123;  </span><br><span class="line">    <span class="keyword">String</span> username = (<span class="keyword">String</span>)token.getPrincipal();</span><br><span class="line">    User user = userService.findByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnknownAccountException</span>();<span class="comment">//没找到帐号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Boolean.TRUE.equals(user.getLocked())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">LockedAccountException</span>(); <span class="comment">//帐号锁定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现</span></span><br><span class="line">    SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> <span class="type">SimpleAuthenticationInfo</span>(</span><br><span class="line">            user.getUsername(), <span class="comment">//用户名</span></span><br><span class="line">            user.getPassword(), <span class="comment">//密码</span></span><br><span class="line">            ByteSource.Util.bytes(user.getCredentialsSalt()),<span class="comment">//salt=username+salt</span></span><br><span class="line">            getName()  <span class="comment">//realm name</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>凭证匹配</strong></p><p>在上述 realm 认证工作流中，一个 Realm 必须较验 Subject 提交的凭证（如密码）是否与存储在数据中的凭证相匹配，如果匹配，验证成功，系统保留已认证的终端用户身份。</p><p>AuthenticatingRealm 以及它的子类支持用 CredentialsMatcher 来执行一个凭证对比。</p><p>在找到用户数据之后，它和提交的 AuthenticationToken 一起传递给一个 CredentialsMatcher ，后者用来检查提交的数据和存储的数据是否相匹配。Shiro某些 CredentialsMatcher 实现可以使你开箱即用，比如 SimpleCredentialsMatcher(直接比较明文) 和 HashedCredentialsMatcher(可以指定hash策略) 实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Realm myRealm = <span class="keyword">new</span> com.company.shiro.realm.<span class="constructor">MyRealm()</span>;</span><br><span class="line">CredentialsMatcher customMatcher = <span class="keyword">new</span> com.company.shiro.realm.<span class="constructor">CustomCredentialsMatcher()</span>;</span><br><span class="line">myRealm.set<span class="constructor">CredentialsMatcher(<span class="params">customMatcher</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="授权实现-1"><a href="#授权实现-1" class="headerlink" title="授权实现"></a>授权实现</h3><p>而授权实现则与认证实现非常相似，在我们自定义的Realm中，重载doGetAuthorizationInfo()方法，重写获取用户权限的方法即可。 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected AuthorizationInfo <span class="keyword">do</span><span class="constructor">GetAuthorizationInfo(PrincipalCollection <span class="params">principals</span>)</span>&#123;  </span><br><span class="line">    String username = (String)principals.get<span class="constructor">PrimaryPrincipal()</span>;</span><br><span class="line"></span><br><span class="line">    SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> <span class="constructor">SimpleAuthorizationInfo()</span>;</span><br><span class="line">    authorizationInfo.set<span class="constructor">Roles(<span class="params">userService</span>.<span class="params">findRoles</span>(<span class="params">username</span>)</span>);</span><br><span class="line">    authorizationInfo.set<span class="constructor">StringPermissions(<span class="params">userService</span>.<span class="params">findPermissions</span>(<span class="params">username</span>)</span>);</span><br><span class="line">    return authorizationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。</p><p>###　会话</p><p>登录成功后使用 Subject.getSession()即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null</p><ul><li>session.getId(); //获取会话唯一标识</li><li>session.getHost(); //获取 Subject的主机地址,该地址是通过 HostAuthenticationToken.getHost()提供的</li><li>session.getTimeout(); //获取过期时间</li><li>session.setTimeout(毫秒); //设置会话过期时间</li><li>session.getStartTimestamp(); //获取会话启动时间</li><li>session.getLastAccessTime(); //获取最后访问时间</li><li>session.touch(); //更新最后访问时间</li><li>session.stop(); //销毁会话。</li><li>session.setAttribute(“key”, “123”); //设置session属性</li><li>session.getAttribute(“key”));  //获取session属性</li><li>session.removeAttribute(“key”);  //删除会话属性</li></ul><h3 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h3><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，失效及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。</p><ul><li>Session start(SessionContext context); //启动会话</li><li>Session getSession(SessionKey key) throws SessionException; //根据会话 Key 获取会话</li></ul><p>Shiro 提供了三个默认实现：</p><ul><li>DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li><li>ServletContainerSessionManager：DefaultWebSecurityManager 使用的默认实现，用于Web环境，其直接使用 Servlet 容器的会话；</li><li>DefaultWebSessionManager：用于Web环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li></ul><p>另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：sessionManager. globalSessionTimeout=1800000<br>另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制， 此时我们可以使用 DefaultWebSessionManager来维护会话：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionIdCookie</span>=org.apache.shiro.web.servlet.SimpleCookie</span><br><span class="line"><span class="attr">sessionManager</span>=org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span><br><span class="line"><span class="attr">sessionIdCookie.name</span>=sid</span><br><span class="line"><span class="comment">#sessionIdCookie.domain=sishuok.com</span></span><br><span class="line"><span class="comment">#sessionIdCookie.path=</span></span><br><span class="line"><span class="attr">sessionIdCookie.maxAge</span>=<span class="number">1800</span></span><br><span class="line"><span class="attr">sessionIdCookie.httpOnly</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">sessionManager.sessionIdCookie</span>=<span class="variable">$sessionIdCookie</span></span><br><span class="line"><span class="attr">sessionManager.sessionIdCookieEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">securityManager.sessionManager</span>=<span class="variable">$sessionManager</span></span><br></pre></td></tr></table></figure><ul><li>sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板：</li><li>sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID；</li><li>sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名；</li><li>sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下；</li><li>sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认-1 表示关闭浏览器时过期 Cookie；</li><li>sessionIdCookie.httpOnly：如果设置为 true，则客户端不会暴露给客户端脚本代码，使用HttpOnly cookie有助于减少某些类型的跨站点脚本攻击； 此特性需要实现了 Servlet 2.5 MR6及以上版本的规范的 Servlet 容器支持；</li><li>sessionManager.sessionIdCookieEnabled：是否启用/禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie，即默认使用了 Servlet 容器的 JSESSIONID，且通过 URL 重写（URL 中的“;JSESSIONID=id”部分）保存 Session Id。（这里设为false，url并没有重写，需要设置什么吗？)</li></ul><h3 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h3><p>会话监听器用于监听会话创建、过期及停止事件。可以实现SessionListener中的onStart、onExpiration、onStop方法</p><h3 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储/持久化"></a>会话存储/持久化</h3><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SessionDAO</span></span><br><span class="line">    <span class="comment">-- AbstractSessionDAO </span></span><br><span class="line">        <span class="comment">-- CachingSessionDAO</span></span><br><span class="line">            <span class="comment">-- EnterpriseCacheSessionDAO</span></span><br><span class="line">        <span class="comment">-- MemorySessionDAO</span></span><br></pre></td></tr></table></figure><p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话 ID等；CachingSessionDAO 提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护；而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。</p><p>Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分布式集群。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.session</span><span class="selector-class">.mgt</span><span class="selector-class">.eis</span>.EnterpriseCacheSessionDAO</span><br><span class="line">sessionDAO. activeSessionsCacheName=shiro-activeSessionCache</span><br><span class="line">sessionManager.sessionDAO=<span class="variable">$sessionDAO</span></span><br><span class="line">cacheManager = org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.cache</span><span class="selector-class">.ehcache</span>.EhCacheManager</span><br><span class="line">cacheManager.cacheManagerConfigFile=classpath:ehcache.xml</span><br><span class="line">securityManager<span class="selector-class">.cacheManager</span> = <span class="variable">$cacheManager</span></span><br></pre></td></tr></table></figure><ul><li>sessionDAO. activeSessionsCacheName：设置Session 缓存名字，默认就是shiro-activeSessionCache；</li><li>cacheManager：缓存管理器，用于管理缓存的，此处使用 Ehcache 实现；</li><li>cacheManager.cacheManagerConfigFile：设置 ehcache 缓存的配置文件；</li><li>securityManager.cacheManager：设置 SecurityManager 的 cacheManager，会自动设置实现了CacheManagerAware 接口的相应对象，如 SessionDAO 的 cacheManager；</li></ul><p>ehcache.xml：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache <span class="attribute">name</span>=<span class="string">"shiro-activeSessionCache"</span></span><br><span class="line">    <span class="attribute">maxEntriesLocalHeap</span>=<span class="string">"10000"</span></span><br><span class="line">    <span class="attribute">overflowToDisk</span>=<span class="string">"false"</span></span><br><span class="line">    <span class="attribute">eternal</span>=<span class="string">"false"</span></span><br><span class="line">    <span class="attribute">diskPersistent</span>=<span class="string">"false"</span></span><br><span class="line">    <span class="attribute">timeToLiveSeconds</span>=<span class="string">"0"</span></span><br><span class="line">    <span class="attribute">timeToIdleSeconds</span>=<span class="string">"0"</span></span><br><span class="line">    <span class="attribute">statistics</span>=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>Cache 的名字为 shiro-activeSessionCache，即设置的 sessionDAO 的 activeSessionsCacheName 属性值。</p><p>用于生成会话 ID，默认就是 JavaUuidSessionIdGenerator，使用 java.util.UUID 生成。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionIdGenerator=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.session</span><span class="selector-class">.mgt</span><span class="selector-class">.eis</span>.JavaUuidSessionIdGenerator</span><br><span class="line">sessionDAO.sessionIdGenerator=<span class="variable">$sessionIdGenerator</span></span><br></pre></td></tr></table></figure><h3 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h3><p>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。</p><p>可以通过如下 ini 配置开启会话验证：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionValidationScheduler</span>=org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler</span><br><span class="line"><span class="attr">sessionValidationScheduler.interval</span> = <span class="number">3600000</span></span><br><span class="line"><span class="attr">sessionValidationScheduler.sessionManager</span>=<span class="variable">$sessionManager</span></span><br><span class="line"><span class="attr">sessionManager.globalSessionTimeout</span>=<span class="number">1800000</span></span><br><span class="line"><span class="attr">sessionManager.sessionValidationSchedulerEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">sessionManager.sessionValidationScheduler</span>=<span class="variable">$sessionValidationScheduler</span></span><br></pre></td></tr></table></figure><ul><li>sessionValidationScheduler：会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler， 其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期；</li><li>sessionValidationScheduler.interval：设置调度时间间隔，单位毫秒，默认就是 1 小时；</li><li>sessionValidationScheduler.sessionManager：设置会话验证调度器进行会话验证时的会话管理器；</li><li>sessionManager.globalSessionTimeout：设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期；</li><li>sessionManager.sessionValidationSchedulerEnabled：是否开启会话验证器，默认是开启的；</li><li>sessionManager.sessionValidationScheduler：设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationScheduler。</li></ul><p>Shiro 也提供了使用 Quartz 会话验证调度器,使用时需要导入 shiro-quartz 依赖：</p><p>如上会话验证调度器实现都是直接调用 AbstractValidatingSessionManager 的 validateSessions 方法进行验证，其直接调用 SessionDAO 的 getActiveSessions 方法获取所有会话进行验证，如果会话比较多，会影响性能；可以考虑如分页获取会话并进行验证</p><p>如果在会话过期时不想删除过期的会话，可以通过如下 ini 配置进行设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionManager.deleteInvalidSessions</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>会话工厂</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionFactory</span>=org.apache.shiro.session.mgt.<span class="literal">On</span>lineSessionFactory</span><br><span class="line"><span class="attr">sessionManager.sessionFactory</span>=<span class="variable">$sessionFactory</span></span><br></pre></td></tr></table></figure><h2 id="编码-加密"><a href="#编码-加密" class="headerlink" title="编码/加密"></a>编码/加密</h2><h3 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码/解码"></a>编码/解码</h3><p>Shiro 内部的一些数据的存储/表示都使用了 base64 和 16 进制字符串。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>; </span><br><span class="line">String base64Encoded = <span class="module-access"><span class="module"><span class="identifier">Base64</span>.</span></span>encode<span class="constructor">ToString(<span class="params">str</span>.<span class="params">getBytes</span>()</span>); </span><br><span class="line">String str2 = <span class="module-access"><span class="module"><span class="identifier">Base64</span>.</span></span>decode<span class="constructor">ToString(<span class="params">base64Encoded</span>)</span>; </span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span><span class="keyword">assert</span><span class="constructor">Equals(<span class="params">str</span>, <span class="params">str2</span>)</span>;</span><br></pre></td></tr></table></figure><p>还有一个可能经常用到的类 CodecSupport，提供了 toBytes(str,  “utf-8”)  /  toString(bytes, “utf-8”)用于在 byte 数组/String 之间转换。</p><h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><p>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的 数据，常见的散列算法如 MD5、SHA 等。一般进行散列时最好提供一个 salt（盐），因为md5解密网站很容易通过散列值得到密码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">String</span> salt = <span class="string">"123"</span>; </span><br><span class="line"><span class="keyword">String</span> md5 =<span class="keyword">new</span> Md5Hash(<span class="built_in">str</span>, salt, <span class="number">2</span>).toString();<span class="comment">//还可以转换为  toBase64()/toHex()  做两次hash</span></span><br></pre></td></tr></table></figure><p>除了Md5外还有Sha256/Sha1/Sha512</p><p>通用的散列支持</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">String</span> salt = <span class="string">"123"</span>; </span><br><span class="line"><span class="comment">//内部使用Java的 MessageDigest </span></span><br><span class="line"><span class="keyword">String</span> simpleHash =<span class="keyword">new</span> SimpleHash(<span class="string">"SHA-1"</span>, <span class="built_in">str</span>, salt).toString();</span><br></pre></td></tr></table></figure><p>为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultHashService hashService =<span class="keyword">new</span> <span class="constructor">DefaultHashService()</span>; <span class="comment">//默认算法 SHA-512 </span></span><br><span class="line">hashService.set<span class="constructor">HashAlgorithmName(<span class="string">"SHA-512"</span>)</span>; </span><br><span class="line">hashService.set<span class="constructor">PrivateSalt(<span class="params">newSimpleByteSource</span>(<span class="string">"123"</span>)</span>); <span class="comment">//私盐，默认无</span></span><br><span class="line">hashService.set<span class="constructor">GeneratePublicSalt(<span class="params">true</span>)</span>;<span class="comment">//是否生成公盐，默认 false </span></span><br><span class="line">hashService.set<span class="constructor">RandomNumberGenerator(<span class="params">new</span>  SecureRandomNumberGenerator()</span>);<span class="comment">//用于生成公盐。默认就这个</span></span><br><span class="line">hashService.set<span class="constructor">HashIterations(1)</span>; <span class="comment">//生成 Hash 值的迭代次数</span></span><br><span class="line">HashRequest request =<span class="keyword">new</span> HashRequest.<span class="constructor">Builder()</span> </span><br><span class="line">.set<span class="constructor">AlgorithmName(<span class="string">"MD5"</span>)</span>.set<span class="constructor">Source(ByteSource.Util.<span class="params">bytes</span>(<span class="string">"hello"</span>)</span>) </span><br><span class="line">.set<span class="constructor">Salt(ByteSource.Util.<span class="params">bytes</span>(<span class="string">"123"</span>)</span>).set<span class="constructor">Iterations(2)</span>.build<span class="literal">()</span>; </span><br><span class="line">String hex =hashService.compute<span class="constructor">Hash(<span class="params">request</span>)</span>.<span class="keyword">to</span><span class="constructor">Hex()</span>;</span><br></pre></td></tr></table></figure><h3 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h3><p>Shiro 还提供对称式加密/解密算法的支持，如 AES、Blowfish 等；当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。</p><p>AES算法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AesCipherService aesCipherService =<span class="keyword">new</span> <span class="constructor">AesCipherService()</span>; </span><br><span class="line">aesCipherService.set<span class="constructor">KeySize(128)</span>; <span class="comment">//设置 key 长度</span></span><br><span class="line"><span class="comment">//生成 key </span></span><br><span class="line">Keykey = aesCipherService.generate<span class="constructor">NewKey()</span>; </span><br><span class="line">String text = <span class="string">"hello"</span>; </span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">String encrptText = aesCipherService.encrypt(text.get<span class="constructor">Bytes()</span>, key.get<span class="constructor">Encoded()</span>).<span class="keyword">to</span><span class="constructor">Hex()</span>; </span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">String text2 = <span class="keyword">new</span> <span class="constructor">String(<span class="params">aesCipherService</span>.<span class="params">decrypt</span>(Hex.<span class="params">decode</span>(<span class="params">encrptText</span>)</span>, key.get<span class="constructor">Encoded()</span>).get<span class="constructor">Bytes()</span>); </span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span><span class="keyword">assert</span><span class="constructor">Equals(<span class="params">text</span>, <span class="params">text2</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h3><p>Shiro 提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordService</span> </span>&#123; </span><br><span class="line"><span class="comment">//输入明文密码得到密文密码</span></span><br><span class="line"><span class="function">String <span class="title">encryptPassword</span><span class="params">(ObjectplaintextPassword)</span> <span class="keyword">throws</span> IllegalArgumentException</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CredentialsMatcher</span> </span>&#123; </span><br><span class="line"><span class="comment">//匹配用户输入的 token 的凭证（未加密）与系统提供的凭证（已加密）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现PasswordMatcher及HashedCredentialsMatcher（更强大）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[main] </span><br><span class="line">passwordService=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.authc</span><span class="selector-class">.credential</span><span class="selector-class">.DefaultPasswordService</span> </span><br><span class="line">hashService=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.crypto</span><span class="selector-class">.hash</span><span class="selector-class">.DefaultHashService</span> </span><br><span class="line">passwordService.hashService=<span class="variable">$hashService</span> </span><br><span class="line">hashFormat=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.crypto</span><span class="selector-class">.hash</span><span class="selector-class">.format</span><span class="selector-class">.Shiro1CryptFormat</span> </span><br><span class="line">passwordService.hashFormat=<span class="variable">$hashFormat</span> </span><br><span class="line">hashFormatFactory=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.crypto</span><span class="selector-class">.hash</span><span class="selector-class">.format</span><span class="selector-class">.DefaultHashFormatFactory</span> </span><br><span class="line">passwordService.hashFormatFactory=<span class="variable">$hashFormatFactory</span> </span><br><span class="line">passwordMatcher=org<span class="selector-class">.apache</span><span class="selector-class">.shiro</span><span class="selector-class">.authc</span><span class="selector-class">.credential</span><span class="selector-class">.PasswordMatcher</span> </span><br><span class="line">passwordMatcher.passwordService=<span class="variable">$passwordService</span> </span><br><span class="line">myRealm=com<span class="selector-class">.github</span><span class="selector-class">.zhangkaitao</span><span class="selector-class">.shiro</span><span class="selector-class">.chapter5</span><span class="selector-class">.hash</span><span class="selector-class">.realm</span><span class="selector-class">.MyRealm</span> </span><br><span class="line">myRealm.passwordService=<span class="variable">$passwordService</span> </span><br><span class="line">myRealm.credentialsMatcher=<span class="variable">$passwordMatcher</span> </span><br><span class="line">securityManager.realms=<span class="variable">$myRealm</span></span><br></pre></td></tr></table></figure><ol><li>passwordService 使用 DefaultPasswordService，如果有必要也可以自定义；</li><li>hashService 定义散列密码使用的 HashService，默认使用 DefaultHashService（默认SHA-256 算法）；</li><li>hashFormat 用于对散列出的值进行格式化，默认使用 Shiro1CryptFormat，另外提供了Base64Format 和 HexFormat，对于有 salt 的密码请自定义实现 ParsableHashFormat 然后把salt 格式化到散列值中；</li><li>hashFormatFactory 用于根据散列值得到散列的密码和 salt； 因为如果使用如 SHA 算法，那么会生成一个 salt，此 salt 需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用 DefaultHashFormatFactory；</li><li>passwordMatcher 使用 PasswordMatcher，其是一个 CredentialsMatcher 实现；</li><li>将 credentialsMatcher 赋值给 myRealm， myRealm 间接继承了 AuthenticatingRealm， 其在调用getAuthenticationInfo 方法获取到AuthenticationInfo信息后，会使用 credentialsMatcher 来验证凭据是否匹配，如果不匹配将抛出 IncorrectCredentialsException 异常。</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span> </span><br><span class="line"><span class="attr">credentialsMatcher</span>=org.apache.shiro.authc.credential.HashedCredentialsMatcher </span><br><span class="line"><span class="attr">credentialsMatcher.hashAlgorithmName</span>=md5 </span><br><span class="line"><span class="attr">credentialsMatcher.hashIterations</span>=<span class="number">2</span> </span><br><span class="line"><span class="attr">credentialsMatcher.storedCredentialsHexEncoded</span>=<span class="literal">true</span> </span><br><span class="line"><span class="attr">myRealm</span>=com.github.zhangkaitao.shiro.chapter5.hash.realm.MyRealm2 </span><br><span class="line"><span class="attr">myRealm.credentialsMatcher</span>=<span class="variable">$credentialsMatcher</span> </span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$myRealm</span></span><br></pre></td></tr></table></figure><ol><li>通过 credentialsMatcher.hashAlgorithmName=md5 指定散列算法为 md5，需要和生成密码时的一样；</li><li>credentialsMatcher.hashIterations=2，散列迭代次数，需要和生成密码时的意义；</li><li>credentialsMatcher.storedCredentialsHexEncoded=true 表示是否存储散列后的密码为 16 进制，需要和生成密码时的一样，默认是 base64；</li></ol><p>此处最需要注意的就是 HashedCredentialsMatcher 的算法需要和生成密码时的算法一样。 另外 HashedCredentialsMatcher 会自动根据AuthenticationInfo 的类型是否是 SaltedAuthenticationInfo 来获取 credentialsSalt 盐。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Apache Shiro的配置主要分为四部分： </p><ol><li>对象和属性的定义与配置</li><li>URL的过滤器配置</li><li>静态用户配置</li><li>静态角色配置</li></ol><p>其中，由于用户、角色一般由后台进行操作的动态数据，因此Shiro配置一般仅包含前两项的配置。 </p><p>Apache Shiro的大多数组件是基于POJO的，因此我们可以使用POJO兼容的任何配置机制进行配置，例如：Java代码、Sping XML、YAML、JSON、ini文件等等。</p><p>Shiro 是从根对象 SecurityManager 进行身份验证和授权的；也就是所有操作都是自它开始的，这个对象是线程安全且整个应用只需要一个即可</p><p><strong>INI配置</strong></p><ol><li>对象名=全限定类名 相当于调用 public 无参构造器创建对象</li><li>对象名.属性名=值 相当于调用 setter 方法设置常量值</li><li>对象名.属性名=$对象引用 相当于调用 setter 方法设置对象引用</li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line"><span class="meta">#提供了对根对象 securityManager 及其依赖的配置</span></span><br><span class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager</span><br><span class="line">…………</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"><span class="meta">#常量值注入</span></span><br><span class="line">jdbcRealm.permissionsLookupEnabled=<span class="literal">true</span></span><br><span class="line">…………</span><br><span class="line"><span class="meta">#对象引用值注入</span></span><br><span class="line">securityManager.realms=$jdbcRealm</span><br><span class="line">…………</span><br><span class="line"><span class="meta">#嵌套属性注入</span></span><br><span class="line">securityManager.authenticator.authenticationStrategy=$authenticationStrategy</span><br><span class="line"><span class="meta">#byte数组注入</span></span><br><span class="line"><span class="meta">#base64 byte[]</span></span><br><span class="line">authenticator.bytes=aGVsbG8=</span><br><span class="line"><span class="meta">#hex byte[]</span></span><br><span class="line">authenticator.bytes=<span class="number">0x68656c6c6f</span></span><br><span class="line"><span class="meta">#Array/Set/List注入</span></span><br><span class="line">authenticator.array=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">authenticator.<span class="keyword">set</span>=$jdbcRealm,$jdbcRealm</span><br><span class="line"><span class="meta">#Map注入</span></span><br><span class="line">authenticator.map=$jdbcRealm:$jdbcRealm,<span class="number">1</span>:<span class="number">1</span>,key:abc</span><br><span class="line">[users]</span><br><span class="line"><span class="meta">#提供了对用户/密码及其角色的配置，用户名=密码，角色 1，角色 2</span></span><br><span class="line">username=password,role1,role2</span><br><span class="line">[roles]</span><br><span class="line"><span class="meta">#提供了角色及权限之间关系的配置，角色=权限 1，权限 2</span></span><br><span class="line">role1=permission1,permission2</span><br><span class="line">[urls]</span><br><span class="line"><span class="meta">#用于 web，提供了对 web url 拦截相关的配置，url=拦截器[参数]，拦截器</span></span><br><span class="line">/index.html = anon</span><br><span class="line">/admin<span class="comment">/** = authc, roles[admin], perms["permission1"]</span></span><br></pre></td></tr></table></figure><p>XML配置： </p><p>主要是对Shiro各个组件的实现进行定义配置，主要组件在前文已做过简单介绍，这里不再一一说明。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.mgt.DefaultSecurityManager"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionMode"</span> <span class="attr">value</span>=<span class="string">"native"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"myRealm"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span>/&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Shiro过滤器的配置 </p><p>Shiro主要是通过URL过滤来进行安全管理，这里的配置便是指定具体授权规则定义。 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"shiroFilter"</span> <span class="built_in">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"loginUrl"</span> value=<span class="string">"/login.jsp"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"successUrl"</span> value=<span class="string">"/home.jsp"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"unauthorizedUrl"</span> value=<span class="string">"/unauthorized.jsp"</span>/&gt; <span class="comment">--&gt;  </span></span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;  </span><br><span class="line">        &lt;value&gt;  </span><br><span class="line">            <span class="comment"># some example chain definitions:  </span></span><br><span class="line">            /admin/** = authc, roles[admin]  </span><br><span class="line">            /docs/** = authc, perms[document:<span class="built_in">read</span>]  </span><br><span class="line">            /** = authc  </span><br><span class="line">            <span class="comment"># more URL-to-FilterChain definitions here  </span></span><br><span class="line">        &lt;/value&gt;  </span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>URL过滤器配置说明： </p><p>Shiro可以通过配置文件实现基于URL的授权验证。FilterChain定义格式： <code>URL_Ant_Path_Expression = Path_Specific_Filter_Chain</code> </p><p>每个URL配置，表示匹配该URL的应用程序请求将由对应的过滤器进行验证。 </p><p>例如： </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[urls] </span><br><span class="line"><span class="string">/index.html</span> = anon </span><br><span class="line"><span class="string">/user/create</span> = anon </span><br><span class="line"><span class="string">/user/</span>** = authc </span><br><span class="line"><span class="string">/admin/</span>** = authc, roles[administrator] </span><br><span class="line"><span class="string">/rest/</span>** = authc, rest </span><br><span class="line"><span class="string">/remoting/rpc/</span>** = authc, perms[<span class="string">"remote:invoke"</span>]</span><br></pre></td></tr></table></figure><p>URL表达式说明 </p><ol><li>URL目录是基于HttpServletRequest.getContextPath()此目录设置 </li><li>URL可使用通配符，**代表任意子目录 </li><li>Shiro验证URL时，URL匹配成功便不再继续匹配查找。所以要注意配置文件中的URL顺序，尤其在使用通配符时。 </li></ol><p>URL 路径表达式按事先定义好的顺序判断传入的请求，并遵循 FIRST MATCH WINS 这一原则。例如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/account/</span>** = ssl, authc</span><br><span class="line"><span class="regexp">/account/</span>signup = anon</span><br></pre></td></tr></table></figure><p>如果传入的请求旨在访问 <code>/account/signup/index.html</code>（所有 ‘anon’ymous 用户都能访问），那么它将永不会被处理！原因是因为<code>/account/*</code>  的模式第一个匹配了传入的请求，“短路”了其余的定义。 </p><p>Filter Chain定义说明 </p><ol><li>一个URL可以配置多个Filter，使用逗号分隔 </li><li>当设置多个过滤器时，全部验证通过，才视为通过 </li><li>部分过滤器可指定参数，如perms，roles </li></ol><p>Shiro内置的FilterChain </p><table><thead><tr><th>Filter Name</th><th>Class</th></tr></thead><tbody><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter</td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td></tr><tr><td>logout</td><td>org.apache.shiro.web.filter.authc.LogoutFilter</td></tr><tr><td>noSessionCreation</td><td>org.apache.shiro.web.filter.session.NoSessionCreationFilter</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter</td></tr></tbody></table><p>OncePerRequestFilter（及其所有子类）支持 Enabling/Disabling 所有请求及 per-request 基础。 一般为所有的请求启用或禁用一个过滤器是通过设置其 enabled 属性为true 或 false。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">ssl.enabled</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>CacheManager - 负责所有缓存的主要管理组件，它返回 Cache 实例。</li><li>Cache - 维护key/value 对。</li><li>CacheManagerAware - 通过想要接收和使用 CacheManager 实例的组件来实现。</li></ul><p>CacheManager 返回Cache 实例，各种不同的Shiro 组件使用这些Cache 实例来缓存必要的数据。任何实现了 CacheManagerAware 的 Shiro 组件将会自动地接收一个配置好的 CacheManager，该 CacheManager 能够用来获取 Cache 实例。</p><h3 id="Realm缓存"><a href="#Realm缓存" class="headerlink" title="Realm缓存"></a>Realm缓存</h3><p>Shiro 的 SecurityManager 实现及所有 AuthorizingRealm 实现都实现了 CacheManagerAware 。如果你在 SecurityManager 上设置了 CacheManger，它反过来也会将它设置到实现了CacheManagerAware 的各种不同的 Realm 上（OO delegation）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userRealm</span>=com.github.zhangkaitao.shiro.chapter11.realm.UserRealm</span><br><span class="line"><span class="attr">userRealm.credentialsMatcher</span>=<span class="variable">$credentialsMatcher</span></span><br><span class="line"><span class="attr">userRealm.cachingEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">userRealm.authenticationCachingEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">userRealm.authenticationCacheName</span>=authenticationCache</span><br><span class="line"><span class="attr">userRealm.authorizationCachingEnabled</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">userRealm.authorizationCacheName</span>=authorizationCache</span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$userRealm</span></span><br><span class="line"><span class="attr">cacheManager</span>=org.apache.shiro.cache.ehcache.EhCacheManager</span><br><span class="line"><span class="attr">cacheManager.cacheManagerConfigFile</span>=classpath:shiro-ehcache.xml</span><br><span class="line"><span class="attr">securityManager.cacheManager</span>=<span class="variable">$cacheManager</span></span><br></pre></td></tr></table></figure><ul><li>userRealm.cachingEnabled：启用缓存，默认 false；</li><li>userRealm.authenticationCachingEnabled：启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 false；</li><li>userRealm.authenticationCacheName：缓存 AuthenticationInfo 信息的缓存名称；</li><li>userRealm. authorizationCachingEnabled：启用授权缓存，即缓存 AuthorizationInfo 信息，默认 false；</li><li>userRealm. authorizationCacheName：缓存 AuthorizationInfo 信息的缓存名称；</li><li>cacheManager：缓存管理器，此处使用 EhCacheManager，即 Ehcache 实现，需要导入相应的 Ehcache 依赖，请参考 pom.xml；</li></ul><p>如果凭证数据或授权数据发生改变，需要调用Realm的clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo方法</p><h3 id="Session缓存"><a href="#Session缓存" class="headerlink" title="Session缓存"></a>Session缓存</h3><p>如 securityManager 实现了 SessionsSecurityManager，其会自动判断 SessionManager 是否实现了 CacheManagerAware 接口，如果实现了会把 CacheManager 设置给它。然后sessionManager 会判断相应的 sessionDAO（如继承自 CachingSessionDAO）是否实现了CacheManagerAware， 如果实现了会把 CacheManager 设置给它</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=com<span class="selector-class">.github</span><span class="selector-class">.zhangkaitao</span><span class="selector-class">.shiro</span><span class="selector-class">.chapter11</span><span class="selector-class">.session</span><span class="selector-class">.dao</span>.MySessionDAO</span><br><span class="line">sessionDAO.activeSessionsCacheName=shiro-activeSessionCache</span><br></pre></td></tr></table></figure><p>activeSessionsCacheName 默认就是 shiro-activeSessionCache。</p><h2 id="与Spring的集成"><a href="#与Spring的集成" class="headerlink" title="与Spring的集成"></a>与Spring的集成</h2><h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><p>spring-shiro.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缓存管理器 使用 Ehcache 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">class</span>=<span class="string">"com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"storedCredentialsHexEncoded"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Realm 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRealm"</span> <span class="attr">class</span>=<span class="string">"com.github.zhangkaitao.shiro.chapter12.realm.UserRealm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">ref</span>=<span class="string">"userService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationCachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationCacheName"</span> <span class="attr">value</span>=<span class="string">"authenticationCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizationCachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizationCacheName"</span> <span class="attr">value</span>=<span class="string">"authorizationCache"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话 ID 生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionIdGenerator"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话 DAO --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionDAO"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"activeSessionsCacheName"</span> <span class="attr">value</span>=<span class="string">"shiro-activeSessionCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionIdGenerator"</span> <span class="attr">ref</span>=<span class="string">"sessionIdGenerator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话验证调度器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionValidationScheduler"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionValidationInterval"</span> <span class="attr">value</span>=<span class="string">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.session.mgt.DefaultSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalSessionTimeout"</span> <span class="attr">value</span>=<span class="string">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteInvalidSessions"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionValidationSchedulerEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionValidationScheduler"</span> <span class="attr">ref</span>=<span class="string">"sessionValidationScheduler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionDAO"</span> <span class="attr">ref</span>=<span class="string">"sessionDAO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.mgt.DefaultSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realms"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"userRealm"</span>/&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于调用 SecurityUtils.setSecurityManager(securityManager) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"staticMethod"</span> <span class="attr">value</span>=<span class="string">"org.apache.shiro.SecurityUtils.setSecurityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arguments"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Shiro 生命周期处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>LifecycleBeanPostProcessor 用于在实现了 Initializable 接口的 Shiro bean 初始化时调用 Initializable 接口回调，在实现了 Destroyable 接口的 Shiro bean 销毁时调用 Destroyable 接口回调。 如 UserRealm 就实现了 Initializable， 而 DefaultSecurityManager 实现了 Destroyable。具体可以查看它们的继承关系。 </p><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><p>spring-shiro-web.xml，只列出了和JavaSE不同的项，其中会话管理器和安全管理器和JavaSE稍有不同，其他几个是新加的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话 Cookie 模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionIdCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpOnly"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"180000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalSessionTimeout"</span> <span class="attr">value</span>=<span class="string">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteInvalidSessions"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionValidationSchedulerEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionValidationScheduler"</span> <span class="attr">ref</span>=<span class="string">"sessionValidationScheduler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionDAO"</span> <span class="attr">ref</span>=<span class="string">"sessionDAO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionIdCookieEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionIdCookie"</span> <span class="attr">ref</span>=<span class="string">"sessionIdCookie"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"userRealm"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于 Form 表单的身份验证过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParam"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParam"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Shiro 的 Web 过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span> <span class="comment">&lt;!-- 对应ini文件[filters] --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"authc"</span> <span class="attr">value-ref</span>=<span class="string">"formAuthenticationFilter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">        /index.jsp = anon</span><br><span class="line">        /unauthorized.jsp = anon</span><br><span class="line">        /login.jsp = authc</span><br><span class="line">        /logout = logout</span><br><span class="line">        /** = user</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还要在web.xml中添加shiro过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Shiro filter--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">        org.springframework.web.filter.DelegatingFilterProxy  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是上述配置所做的事情：</p><ol><li>EnvironmentLoaderListener 初始化一个Shiro WebEnvironment 实例（其中包含 Shiro 需要的一切操作，包括 SecurityManager ），使得它在 ServletContext 中能够被访问。如果你需要在任何时候获得WebEnvironment 实例，你可以调用WebUtils.getRequiredWebEnvironment（ServletContext）。</li><li>ShiroFilter 将使用此 WebEnvironment 对任何过滤的请求执行所有必要的安全操作。</li><li>最后，filter-mapping 的定义确保了所有的请求被 ShiroFilter 过滤，建议大多数 Web 应用程序使用以确保任何请求是安全的。</li></ol><p>通常为了shiro能够很好的工作，这个配置应该在其他过滤器之前</p><h3 id="Shiro-权限注解"><a href="#Shiro-权限注解" class="headerlink" title="Shiro 权限注解"></a>Shiro 权限注解</h3><p>Shiro 提供了相应的注解用于权限控制，如果使用这些注解就需要使用 AOP 的功能来进行判断，如 Spring AOP；Shiro 提供了 Spring AOP 集成用于权限注解的解析和验证。为了测试，此处使用了 Spring MVC 来测试 Shiro 注解，当然 Shiro 注解不仅仅可以在 web 环境使用，在独立的 JavaSE 中也是可以用的</p><p>在spring-mvc.xml中添加权限注解的支持</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:<span class="keyword">config</span> proxy-target-<span class="keyword">class</span>=<span class="string">"true"</span>&gt;&lt;/aop:<span class="keyword">config</span>&gt;</span><br><span class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> name=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h3><p>spring-shiro-web.xml 配置：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpOnly"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"2592000"</span>/&gt;</span><span class="comment">&lt;!-- 30 天 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- rememberMe 管理器 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cipherKey"</span> <span class="attr">value</span>=<span class="string">"#</span></span></span><span class="template-variable">&#123;T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookie"</span> <span class="attr">ref</span>=<span class="string">"rememberMeCookie"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    ……</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeManager"</span> <span class="attr">ref</span>=<span class="string">"rememberMeManager"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    ……</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeParam"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>rememberMe 管理器，cipherKey 是加密 rememberMe Cookie 的密钥；默认 AES 算法；设置 securityManager 安全管理器的 rememberMeManager；rememberMeParam，即 rememberMe 请求参数名，请求参数是 boolean 类型，true 表示 rememberMe。</p><p><code>/authenticated.jsp = authc</code> 表示访问该地址用户必须身份验证通过（ Subject.isAuthenticated()==true）；而<code>/** = user</code>表示访问该地址的用户是身份验证通过或 RememberMe 登录的都可以。</p>]]></content>
    
    <summary type="html">
    
      Shiro; Java安全框架; 认证、授权、加密和会话管理
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/categories/Java/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://howiefh.github.io/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker-XML处理笔记</title>
    <link href="http://howiefh.github.io/2015/05/03/freemarker-XML-processing-note/"/>
    <id>http://howiefh.github.io/2015/05/03/freemarker-XML-processing-note/</id>
    <published>2015-05-03T01:20:51.000Z</published>
    <updated>2020-05-02T14:28:14.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="揭示XML文档"><a href="#揭示XML文档" class="headerlink" title="揭示XML文档"></a>揭示XML文档</h2><p>test.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Book<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ch1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">para</span>&gt;</span>p1.1<span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">para</span>&gt;</span>p1.2<span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">para</span>&gt;</span>p1.3<span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">chapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ch2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">para</span>&gt;</span>p2.1<span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">para</span>&gt;</span>p2.2<span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">chapter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>根节点是“文档”而不是book</li><li>如果 B 是 A 的直接后继，我们说 B 节点是 A 节点的 child 子节点，A节点是B节点的parent父节点。</li><li>元素，文本，注释，处理指令都是DOM树的节点</li></ul><a id="more"></a><h3 id="将XML放到数据模型中"><a href="#将XML放到数据模型中" class="headerlink" title="将XML放到数据模型中"></a>将XML放到数据模型中</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map root = <span class="keyword">new</span> <span class="constructor">HashMap()</span>;</span><br><span class="line">root.put(<span class="string">"doc"</span>, freemarker.ext.dom.<span class="module-access"><span class="module"><span class="identifier">NodeModel</span>.</span></span>parse(<span class="keyword">new</span> <span class="constructor">File(<span class="string">"test.xml"</span>)</span>));</span><br></pre></td></tr></table></figure><ul><li>parse 方法默认移除注释和处理指令节点。参见 API 文档获取详细信息。</li><li>NodeModel 也允许你直接包装 org.w3c.dom.Node。首先你也许想用静态的实用方法清空 DOM 树，比如 NodeModel.simplify 或你自定义的清空规则。</li></ul><h2 id="必要的XML处理"><a href="#必要的XML处理" class="headerlink" title="必要的XML处理"></a>必要的XML处理</h2><h3 id="通过例子来学习"><a href="#通过例子来学习" class="headerlink" title="通过例子来学习"></a>通过例子来学习</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;doc.book.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>尝试访问有子元素的元素将导致错误</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;doc.book&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>doc.book.chapter是存储两个元素节点的序列</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>$</span><span class="template-variable">&#123;doc.book.chapter[0].title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>$</span><span class="template-variable">&#123;doc.book.chapter[1].title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">doc.book.chapter</span> <span class="attr">as</span> <span class="attr">ch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>$</span><span class="template-variable">&#123;ch.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>就算只有一个元素节点，也可以当做一个序列</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;doc.book[0].title[0]&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果 book 没有 chapter，那么book.chapter 就是一个空序列，所以 doc.book.chapter 就不会是 false，它就一直是 true！类似地，<code>&lt;#if doc.book.somethingTotallyNonsense??&gt;&lt;/#if&gt;</code>也不会是false。来检查是否有子节点，可以使用doc.book.chapter[0]??（或doc.book.chapter?size == 0）。当然你可以使用类似所有的控制处理操作符（比如 doc.book.author[0]!”Anonymous”），只是不要忘了那个[0]。</p><p>一个完整示例</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">book</span> = <span class="string">doc.book</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;book.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">book.chapter</span> <span class="attr">as</span> <span class="attr">ch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>$</span><span class="template-variable">&#123;ch.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#list</span> <span class="attr">ch.para</span> <span class="attr">as</span> <span class="attr">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$</span><span class="template-variable">&#123;p&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>得到所有的para</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">doc.book.chapter.para</span> <span class="attr">as</span> <span class="attr">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>$</span><span class="template-variable">&#123;p&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>如果test.xml中title是属性而不是元素，只需在其前加@即可。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">book</span> = <span class="string">doc.book</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;book.@title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">book.chapter</span> <span class="attr">as</span> <span class="attr">ch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>$</span><span class="template-variable">&#123;ch.@title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">#list</span> <span class="attr">ch.para</span> <span class="attr">as</span> <span class="attr">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$</span><span class="template-variable">&#123;p&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果你很好奇是否 foo 含有属性 bar，那么你不得不写 foo.@bar[0]??来验证。（ foo.@bar??是不对的，因为它总是返回 true）。类似地，如果你想要一个bar属性的默认值，那么你就不得不写 foo.@bar[0]!”theDefaultValue”。</p><h3 id="探索DOM"><a href="#探索DOM" class="headerlink" title="探索DOM"></a>探索DOM</h3><p>枚举所有book的子元素</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">doc.book</span>?<span class="attr">children</span> <span class="attr">as</span> <span class="attr">c</span>&gt;</span></span></span><br><span class="line"><span class="xml">- $</span><span class="template-variable">&#123;c?node_type&#125;</span><span class="xml"> <span class="tag">&lt;<span class="name">#if</span> <span class="attr">c</span>?<span class="attr">node_type</span> = <span class="string">'element'</span>&gt;</span>$</span><span class="template-variable">&#123;c?node_name&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">#if</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>children：子元素序列<br>node_type：节点类型，”element”， “text”， “comment”， “pi”<br>node_name：节点名称</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;book <span class="attribute">foo</span>=<span class="string">"Foo"</span> <span class="attribute">bar</span>=<span class="string">"Bar"</span> <span class="attribute">baaz</span>=<span class="string">"Baaz"</span>&gt;</span><br></pre></td></tr></table></figure><p>可以通过元素的自变量@@获取元素的属性序列</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.@@ <span class="keyword">as</span> attr&gt;</span><br><span class="line">- <span class="variable">$&#123;attr</span>?node_name&#125; = <span class="variable">$&#123;attr&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><p>返回元素的子节点序列可以用*</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.* <span class="keyword">as</span> c&gt;</span><br><span class="line">- <span class="variable">$&#123;c</span>?node_name&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><p>可以使用内建函数 parent 来获得元素的父节点。你可以使用内建函数 root 来快速返回到文档节点</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">e</span> = <span class="string">doc.book.chapter[0].para[0]</span>&gt;</span></span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;e?node_name&#125;</span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;e?parent?node_name&#125;</span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;e?parent?parent?node_name&#125;</span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;e?parent?parent?parent?node_name&#125;</span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;e?root?node_name&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用XPath表达式"><a href="#使用XPath表达式" class="headerlink" title="使用XPath表达式"></a>使用XPath表达式</h3><p>XPath 表达式仅在 Jaxen（推荐使用，但是使用至少 Jaxen 1.1-beta-8 版本，不能再老了） 或 Apache Xalan 库可用时有效。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">doc</span>["<span class="attr">book</span>/<span class="attr">chapter</span>[<span class="attr">title</span>=<span class="string">'Ch1'</span>]/<span class="attr">para</span>"] <span class="attr">as</span> <span class="attr">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>$&#123;p&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br><span class="line">$&#123;doc[<span class="string">"book/chapter[title='Ch1'</span>]/para[<span class="string">1</span>]"][0]&#125;</span><br><span class="line">$&#123;doc.book["chapter[title='Ch1']/para[1]"]&#125;</span><br></pre></td></tr></table></figure><p>注意 XPath 序列的项索引从 1 开始，而 FTL 的序列项索引是用 0 开始的。</p><p>如果使用 Jaxen 而不是 Xalan，那么 FreeMarker 的变量在使用 XPath 变量引用时是可见的</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign currentTitle = <span class="string">"Ch1"</span>&gt;</span><br><span class="line">&lt;#list doc[<span class="string">"book/chapter[title=$currentTitle]/para"</span>] <span class="keyword">as</span> p&gt;</span><br></pre></td></tr></table></figure><p>注意$currentTitle 不是 FreeMarker 的插值，因为那里没有{和}。那是 XPath 表达式。</p><p>一些 XPath 表达式的结果不是节点集，而是字符串，数字或者布尔值。获取para元素的总数</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>x[<span class="string">"count(//para)"</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="XML命名空间"><a href="#XML命名空间" class="headerlink" title="XML命名空间"></a>XML命名空间</h3><p>如果元素book是命名空间 <a href="http://example.com/ebook，那么你不得不关联一个前缀，要在模板的顶部使用" target="_blank" rel="noopener">http://example.com/ebook，那么你不得不关联一个前缀，要在模板的顶部使用</a> ftl 指令的 the ns_prefixes 参数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#ftl ns_prefixes=&#123;</span></span><br><span class="line"><span class="string">"e"</span>:<span class="string">"http://example.com/ebook"</span>,</span><br><span class="line"><span class="string">"f"</span>:<span class="string">"http://example.com/form"</span>,</span><br><span class="line"><span class="string">"vg"</span>:<span class="string">"http://example.com/vectorGraphics"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>现在你可以编写如 doc[“e:book”]的表达式。使用保留前缀D可以设置默认命名空间。XPath不支持默认命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#ftl ns_prefixes=&#123;<span class="meta-string">"D"</span>:<span class="meta-string">"http://example.com/ebook"</span>&#125;&gt;</span></span><br></pre></td></tr></table></figure><p>注意当你使用默认命名空间时，那么你可以使用保留前缀 N 来选择不属于任意节点空间的元素。比如 doc.book[“N:foo”]。这对 XPath 表达式不起作用</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#escape</span> <span class="attr">x</span> <span class="attr">as</span> <span class="attr">x</span>?<span class="attr">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">book</span> = <span class="string">doc.book</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>$</span><span class="template-variable">&#123;book.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">book.chapter</span> <span class="attr">as</span> <span class="attr">ch</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>$</span><span class="template-variable">&#123;ch.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">ch.para</span> <span class="attr">as</span> <span class="attr">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>$</span><span class="template-variable">&#123;p&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#escape</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="声明的XML处理"><a href="#声明的XML处理" class="headerlink" title="声明的XML处理"></a>声明的XML处理</h2><p>最经常使用来处理声明方式的指令就是 recurse 指令，这个指令获取节点变量，并把它作为是参数，从第一个子元素开始，一个接一个地“访问”所有它的子元素。“访问”一个节点意味着它调用了用户自定义的指令（比如宏），它的名字和子节点（ ?node_name）的名字相同。我们这么说，用户自定义指令操作节点。使用用户自定义指令处理的节点作为特殊变量.node 是可用的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#recurse doc&gt;</span></span><br><span class="line">&lt;<span class="meta">#macro book&gt;</span></span><br><span class="line">    Book element with <span class="built_in">title</span> $&#123;.node.title&#125;</span><br><span class="line">    &lt;<span class="meta">#recurse&gt;</span></span><br><span class="line">    <span class="keyword">End</span> book</span><br><span class="line">&lt;/<span class="meta">#macro&gt;</span></span><br><span class="line">&lt;<span class="meta">#macro title&gt;</span></span><br><span class="line">    <span class="built_in">Title</span> element</span><br><span class="line">&lt;/<span class="meta">#macro&gt;</span></span><br><span class="line">&lt;<span class="meta">#macro chapter&gt;</span></span><br><span class="line">    Chapter element with <span class="built_in">title</span>: $&#123;.node.title&#125;</span><br><span class="line">&lt;/<span class="meta">#macro&gt;</span></span><br></pre></td></tr></table></figure><p>如果你调用 recurse 而不用参数，那么它使用.node，也就是说，它访问现在处理这个节点的所有子节点。</p><p>所有文本节点的节点名字都是@text。转义HTML</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#macro @text&gt;</span>$&#123;.<span class="keyword">node</span><span class="title">?html</span>&#125;<span class="tag">&lt;/#macro&gt;</span></span><br></pre></td></tr></table></figure><h3 id="默认处理器"><a href="#默认处理器" class="headerlink" title="默认处理器"></a>默认处理器</h3><ul><li>文本节点： 打印其中的文本。要注意，在很多应用程序中，这对你来说并不好，因为你应该在你发送它们到输出（使用?html 或?xml 或?rtf 等，这基于输出的格式）前转义这些文本。</li><li>处理指令节点： 如果你定义了自定义指令，可以通过调用处理器调用@pi，否则将什么都不做（忽略这些节点）。</li><li>注释节点，文档类型节点：什么都不做（忽略这些节点）。</li><li>文档节点：调用 recurse，也就是说，访问文档节点的所有子节点。</li></ul><p>元素节点的情形，这意味着如果你定义了一个称为@element 的宏（或其他种类的用户自定义指令），没有其他特定的处理器时，那么它会捕捉所有元素节点。如果你没有@element 处理器，那么你必须为所有可能的元素定义处理器。</p><p>属性节点在 recurse 指令中不可见，所以不需要为它们编写处理器。</p><h3 id="访问单独节点"><a href="#访问单独节点" class="headerlink" title="访问单独节点"></a>访问单独节点</h3><p>使用visit指令你可以访问单独的节点</p><h3 id="XML-命名空间"><a href="#XML-命名空间" class="headerlink" title="XML 命名空间"></a>XML 命名空间</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;book <span class="attribute">xmlns</span>=<span class="string">"http://example.com/ebook"</span>&gt;</span><br></pre></td></tr></table></figure><p>考虑命名空间</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#ftl</span> <span class="attr">ns_prefixes</span>=</span></span><span class="template-variable">&#123;"e":"http://example.com/ebook"&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#recurse</span> <span class="attr">doc</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> "<span class="attr">e:book</span>"&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">#recurse</span> <span class="attr">.node</span>["<span class="attr">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">#recurse</span> <span class="attr">.node</span>["<span class="attr">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#recurse</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> "<span class="attr">e:chapter</span>"&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">#recurse</span> <span class="attr">.node</span>["<span class="attr">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#recurse</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> "<span class="attr">e:para</span>"&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">#recurse</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> "<span class="attr">e:title</span>"&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#--</span></span></span></span><br><span class="line"><span class="xml">We have handled this element imperatively,</span></span><br><span class="line"><span class="xml">so we do nothing here.</span></span><br><span class="line"><span class="xml">--&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> @<span class="attr">text</span>&gt;</span>$</span><span class="template-variable">&#123;.node?html&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>设置为默认命名空间</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#ftl ns_prefixes=&#123;<span class="string">"D"</span>:<span class="string">"http://example.com/ebook"</span>&#125;&gt;</span><br><span class="line">&lt;#recurse doc&gt;</span><br><span class="line">&lt;#macro book&gt;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      FreeMarker;Java模板引擎;XML处理
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker-程序开发指南笔记</title>
    <link href="http://howiefh.github.io/2015/05/02/freemarker-program-development-note/"/>
    <id>http://howiefh.github.io/2015/05/02/freemarker-program-development-note/</id>
    <published>2015-05-02T01:20:06.000Z</published>
    <updated>2020-05-02T14:28:14.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li>使用 java.lang.String 来构建字符串。</li><li>使用 java.lang.Number 来派生数字类型。</li><li>使用 java.lang.Boolean 来构建布尔值。</li><li>使用 java.util.List 或 Java 数组来构建序列。</li><li>使用 java.util.Map 来构建哈希表。</li><li>使用你自己定义的 bean 类来构建哈希表， bean 中的项和 bean 的属性对应。例如product 中的 price 属性可以用 product.price 来获取。</li></ul><a id="more"></a><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> freemarker.<span class="keyword">template</span>.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFTLDemo</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line"><span class="comment">/* 在整个应用的生命周期中，这个工作你应该只做一次。 */</span></span><br><span class="line"><span class="comment">/* 创建和调整配置。 */</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">cfg.setDirectoryForTemplateLoading(<span class="keyword">new</span> <span class="built_in">File</span>(</span><br><span class="line"><span class="string">"/where/you/store/templates"</span>));</span><br><span class="line">cfg.setObjectWrapper(<span class="keyword">new</span> DefaultObjectWrapper());</span><br><span class="line"><span class="comment">/* 在整个应用的生命周期中，这个工作你可以执行多次 */</span></span><br><span class="line"><span class="comment">/* 获取或创建模板 */</span></span><br><span class="line">Template temp = cfg.getTemplate(<span class="string">"test.ftl"</span>);</span><br><span class="line"><span class="comment">/* 创建数据模型 */</span></span><br><span class="line">Map root = <span class="keyword">new</span> HashMap();</span><br><span class="line">root.<span class="built_in">put</span>(<span class="string">"user"</span>, <span class="string">"Big Joe"</span>);</span><br><span class="line">Map latest = <span class="keyword">new</span> HashMap();</span><br><span class="line">root.<span class="built_in">put</span>(<span class="string">"latestProduct"</span>, latest);</span><br><span class="line">latest.<span class="built_in">put</span>(<span class="string">"url"</span>, <span class="string">"products/greenmouse.html"</span>);</span><br><span class="line">latest.<span class="built_in">put</span>(<span class="string">"name"</span>, <span class="string">"green mouse"</span>);</span><br><span class="line"><span class="comment">/* 将模板和数据模型合并 */</span></span><br><span class="line">Writer out = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">temp.<span class="built_in">process</span>(root, out);</span><br><span class="line">out.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>在内部，模板中可用的变量都是实现了freemarker.template.TemplateModel 接口的 Java 对象。但在你自己的数据模型中，可以使用基本的 Java 集合类作为变量， 因为这些变量会在内部被替换为适当的TemplateModel 类型。这种功能特性被称作是 object wrapping 对象包装。对象包装功能可以透明地把任何类型的对象转换为实现了 TemplateModel 接口类型的实例。要注意一个类可以实现多个TemplateModel 接口，这就是为什么 FTL 变量可以有多种类型</p><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>布尔值、数字、字符串、日期这四种标量每一种标量类型都是 TemplateTypeModel 接口的实现，这里的 Type 就是类型的名称（比如Boolean,Number,Scalar,Date）。 这些接口只定义了一个方法 type getAsType()；它返回变量的 Java 类型（boolean，Number， String 和 Date 各自代表的值）的值。这些接口的有一个实现类SimpleType 类。但是没有 SimpleBooleanModel 类型；为了代表布尔值，可以使用TemplateBooleanModel.TRUE 和 TemplateBooleanModel.FALSE 来单独使用。</p><p>Date有个问题，就是模板不知道它是date还是time还是datetime。TemplateDateModel 接口有两个方法：分别是java.util.Date getAsDate() 和int getDateType()。这个接口典型的实现是存储一个 java.util.Date 对象，加上一个整数来辨别“数据库存储的类型”。这个整数的值也必须是 TemplateDateModel 接口中的常量之一：DATE，TIME，DATETIME和UNKNOWN。通过内建函数date、time、datetime和string可以解决这个问题。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是实现了 TemplateHashModel 接口的 Java 对象。TemplateHashModel 接口有两个方法：TemplateModel get(String key)，boolean isEmpty()。</p><p>TemplateHashModelEx 接口扩展了 TemplateHashModel 接口。它增加了更多的方法，使得可以使用内建函数 values 和 keys 来枚举哈希表中的子变量。经常使用的实现类是 SimpleHash，该类实现了 TemplateHashModelEx 接口。 </p><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>序列是实现了 TemplateSequenceModel 接口的 Java 对象。它包含两个方法：TemplateModel get(int index)和 int size()。</p><p>经常使用的实现类是 SimpleSequence， 该类内部使用一个 java.util.List 类型的对象存储它的子变量。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合是实现了 TemplateCollectionModel 接口的 Java 对象。这个接口只定义了一个方法：TemplateModelIterator iterator() 。TemplateModelIterator 接口和 java.util.Iterator 相似，但是它返回 TemplateModels 而不是Object，而且它能抛出TemplateModelException 异常。通常使用的实现类是 SimpleCollection。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法变量在存于实现了 TemplateMethodModel 接口的模板中。这个接口仅包含一个方法： TemplateModel exec(java.util.List arguments)。当使用方法调用表达式调用方法时，exec 方法将会被调用。形参将会包含 FTL方法调用形参的值。exec 方法的返回值给出了 FTL 方法调用表达式的返回值。TemplateMethodModelEx 接口扩展了 TemplateMethodModel 接口。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexOfMethod</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">TemplateMethodModel</span></span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> TemplateModel exec(List args) throws TemplateModelException &#123;</span><br><span class="line"><span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TemplateModelException</span>(<span class="string">"Wrong arguments"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">SimpleNumber</span>(((<span class="keyword">String</span>) args.<span class="keyword">get</span>(<span class="number">1</span>)).indexOf((<span class="keyword">String</span>) args.<span class="keyword">get</span>(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.put(<span class="string">"indexOf"</span>, <span class="keyword">new</span> <span class="type">IndexOfMethod</span>());</span><br></pre></td></tr></table></figure><p>在模板中调用</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">assign</span> x = <span class="string">"something"</span>&gt;</span><br><span class="line"><span class="symbol">$</span>&#123;indexOf(<span class="string">"met"</span>, x)&#125;</span><br><span class="line"><span class="symbol">$</span>&#123;indexOf(<span class="string">"foo"</span>, x)&#125;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>可以使用 TemplateDirectiveModel 接口在 Java 代码中实现自定义指令。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FreeMarker 的用户自定义指令在逐步改变 它嵌套内容的输出转换为大写形式</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;指令内容&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 指令参数：无</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 循环变量：无</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 指令嵌套内容：是</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">UpperDirective</span> <span class="title">implements</span> <span class="title">TemplateDirectiveModel</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Environment env, Map <span class="keyword">params</span>, TemplateModel[] loopVars,</span></span></span><br><span class="line"><span class="function"><span class="params">TemplateDirectiveBody body</span>) throws TemplateException, IOException</span> &#123;</span><br><span class="line"><span class="comment">// 检查参数是否传入</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">params</span>.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"This directive doesn't allow parameters."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (loopVars.length != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"This directive doesn't allow loop variables."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否有非空的嵌入内容</span></span><br><span class="line"><span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 执行嵌入体部分，和 FTL 中的&lt;#nested&gt;一样，除了</span></span><br><span class="line"><span class="comment">// 我们使用我们自己的 writer 来代替当前的 output writer.</span></span><br><span class="line">body.render(<span class="keyword">new</span> UpperCaseFilterWriter(env.getOut()));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"missing body"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;@link Writer&#125;改变字符流到大写形式， 而且把它发送到另外一个&#123;@link Writer&#125;中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UpperCaseFilterWriter</span> <span class="title">extends</span> <span class="title">Writer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> final Writer <span class="keyword">out</span>;</span><br><span class="line">UpperCaseFilterWriter(Writer <span class="keyword">out</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">out</span> = <span class="keyword">out</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params"><span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len</span>) throws IOException</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] transformedCbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">transformedCbuf[i] = Character.toUpperCase(cbuf[i + off]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">out</span>.write(transformedCbuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span>(<span class="params"></span>) throws IOException</span> &#123;</span><br><span class="line"><span class="keyword">out</span>.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span>(<span class="params"></span>) throws IOException</span> &#123;</span><br><span class="line"><span class="keyword">out</span>.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.put(<span class="string">"upper"</span>, <span class="keyword">new</span> UpperDirective());</span><br></pre></td></tr></table></figure><p>然后在模板中使用</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">@upper</span>]</span><br><span class="line">hello world!</span><br><span class="line">[<span class="meta">#list [<span class="meta-string">"red"</span>,<span class="meta-string">"blue"</span>,<span class="meta-string">"white"</span>,<span class="meta-string">"black"</span></span>] <span class="keyword">as</span> color]</span><br><span class="line">$&#123;color&#125;</span><br><span class="line">[<span class="meta">/#list</span>]</span><br><span class="line">[<span class="meta">/@upper</span>]</span><br></pre></td></tr></table></figure><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点变量有下列属性， 它们都由 TemplateNodeModel 接口的方法提供。</p><ul><li>基本属性：<ul><li>TemplateSequenceModel getChildNodes()：一个节点的子节点序列（除非这个节点是叶子节点，这时方法返回一个空序列或者是 null）。子节点本身应该也是节点变量。</li><li>TemplateNodeModel getParentNode()：一个节点只有一个父节点（除非这个节点是节点树的根节点，这时方法返回 null）。</li></ul></li><li>可选属性。如果一个属性在具体的使用中没有意义，那对应的方法应该返回 null：<ul><li>String getNodeName()：节点名称也是宏的名称，当使用 recurse和 visit 指令时，它用来控制节点。因此， 如果想通过节点使用这些指令，那么节点的名称是必须的。</li><li>String getNodeType()：在 XML 技术中： “element”， “text”，”comment”等类型。 如果这些信息可用，就是通过 recurse 和 visit 指令来查找节点的默认处理宏。而且，它对其他有具体用途的应用程序也是有用的。</li><li>String getNamespaceURI()：这个节点所属的命名空间（和用于库的 FTL 命名空间无关）。例如，在 XML 中，这就是元素和属性所属 XML 命名空间的 URI。 这个信息如果可用，就是通过 recurse 和 visit 指令来查找存储控制宏的 FTL 命名空间。</li></ul></li></ul><p>在 FTL 这里，节点属性的直接使用可以通过内建函数 node 完成， 还有 visit 和 recurse 宏。</p><h3 id="对象包装"><a href="#对象包装" class="headerlink" title="对象包装"></a>对象包装</h3><p>Template.process()可以接收任何Java对象，不一定是TemplateModel，因为末班实现是会用合适的TemplateModel对象来替换原有对象。替换在获取自变量时必须会发生，因为getter方法返回TemplateModel，而不是Object。</p><p>替换策略通过ObjectWrapper实现，</p><ul><li>ObjectWrapper.DEFAULT_WRAPPER：它使用 SimpleScalar 来替换String， SimpleNumber 来替换 Number， SimpleSequence 来替换 List和数组，SimpleHash 来替换Map，TemplateBooleanModel.TRUE 或 TemplateBooleanModel.FALSE 来替换 Boolean，freemarker.ext.dom.NodeModel 来替换 W3C 组织定义的 DOM 模型节点类型。对于Jython 类型的对象，包装器会调用 freemarker.ext.jython.JythonWrapper。而对于其他对象，则会调用 BEAN_WRAPPER。</li><li>ObjectWrapper.BEANS_WRAPPER：它可以通过 Java 的反射机制来获取到Java Bean 的属性和其他任意对象类型的成员变量。</li></ul><p>如果在数据模型中放了任意的对象，那么DEFAULT_WRAPPER 就会调用BEANS_WRAPPER 来包装这个对象</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="built_in">put</span>(<span class="string">"person"</span>, <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"Jack"</span>));</span><br></pre></td></tr></table></figure><p>Person类有两个字段id和name。这里Person类必须是public的，而且字段需要提供getter方法。如果还有公开方法，那么公开方法名不能和字段名相同。否则会抛出异常。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置对象是freemarker.template.Configuration 的实例，可以通过构造方法来创建它。一个应用程序通常只使用一个共享的 Configuration 实例。</p><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>Shared variables 共享变量是为所有模板所定义的变量。可以使用setSharedVariable 方法向配置实例中添加共享变量。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfg.set<span class="constructor">SharedVariable(<span class="string">"wrap"</span>, <span class="params">new</span> WrapDirective()</span>);</span><br><span class="line">cfg.set<span class="constructor">SharedVariable(<span class="string">"company"</span>, <span class="string">"Foo Inc."</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果配置对象在多线程环境中使用，不要使用 TemplateModel 实现类来作为共享变量，因为它是线程不安全的。这也是基于 Servlet 的 Web 站点的典型情况。</p><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>Settings 配置信息是影响 FreeMarker 行为的已经被命名的值。</p><p>Environment中能覆盖Template中的配置信息，Template中能覆盖Configuration中的配置信息。</p><p>Configuration可以通过setter方法或setSetting方法设置配置信息。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myCfg.set<span class="constructor">Locale(<span class="params">java</span>.<span class="params">util</span>.Locale.ITALY)</span>;</span><br><span class="line">myCfg.set<span class="constructor">NumberFormat(<span class="string">"0.####"</span>)</span>;</span><br><span class="line">myCfg.set<span class="constructor">Setting(<span class="string">"locale"</span>,<span class="string">"it_IT"</span>)</span>;</span><br><span class="line">myCfg.set<span class="constructor">Setting(<span class="string">"number_format"</span>,<span class="string">"0.####"</span>)</span>;</span><br></pre></td></tr></table></figure><p>Template层不需要设置配置信息。</p><p>Environment层这里有两种设置方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment env =</span><br><span class="line">myTemplate.create<span class="constructor">ProcessingEnvironment(<span class="params">root</span>, <span class="params">out</span>)</span>;</span><br><span class="line">env.set<span class="constructor">Locale(<span class="params">java</span>.<span class="params">util</span>.Locale.ITALY)</span>;</span><br><span class="line">env.set<span class="constructor">NumberFormat(<span class="string">"0.####"</span>)</span>;</span><br><span class="line">env.process<span class="literal">()</span>; <span class="comment">// 处理模板</span></span><br></pre></td></tr></table></figure><p>或在模板中直接使用指令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#setting <span class="attribute">locale</span>=<span class="string">"it_IT"</span>&gt;</span><br><span class="line">&lt;#setting <span class="attribute">number_format</span>=<span class="string">"0.####"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="模板加载"><a href="#模板加载" class="headerlink" title="模板加载"></a>模板加载</h3><h4 id="内建模板加载器"><a href="#内建模板加载器" class="headerlink" title="内建模板加载器"></a>内建模板加载器</h4><p>在 Configuration 中可以使用下面的方法来方便建立三种模板加载。（每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDirectoryForTemplateLoading</span><span class="params">(<span class="built_in">File</span> dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClassForTemplateLoading</span><span class="params">(Class cl, <span class="keyword">String</span> prefix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServletContextForTemplateLoading</span><span class="params">(Object servletContext, <span class="keyword">String</span> path)</span></span>;</span><br></pre></td></tr></table></figure><p>上述的第一种方法在磁盘的文件系统上设置了一个明确的目录，它确定了从哪里加载模板。</p><p>第二种调用方法使用了一个 Class 类型的参数和一个前缀。这是让你来指定什么时候通过相同的机制来加载模板，不过是用 Java 的 ClassLoader 来加载类。 这就意味着传入的 Class 参数会被用来调用 Class.getResource()方法来找到模板。参数 prefix是给模板的名称来加前缀的。在实际运行的环境中，类加载机制是首选用来加载模板的方法，因为通常情况下，从类路径下加载文件的这种机制， 要比从文件系统的特定目录位置加载安全而且简单。 在最终的应用程序中，所有代码都使用.jar 文件打包也是不错的，这样用户就可以直接执行包含所有资源的.jar 文件了。</p><p>第三种调用方式需要 Web 应用的上下文和一个基路径作为参数，这个基路径是 Web 应用根路径（ WEB-INF 目录的上级目录）的相对路径。那么加载器将会从 Web 应用目录开始加载模板。尽管加载方法对没有打包的.war 文件起作用，因为它使用了ServletContext.getResource()方法来访问模板，注意这里我们指的是“目录”。</p><h4 id="从多个位置加载"><a href="#从多个位置加载" class="headerlink" title="从多个位置加载"></a>从多个位置加载</h4><p>如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将它们包装到一个被成为 MultiTemplateLoader 的特殊模板加载器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileTemplateLoader ftl1 = <span class="keyword">new</span> <span class="constructor">FileTemplateLoader(<span class="params">new</span> File(<span class="string">"/tmp/templates"</span>)</span>);</span><br><span class="line">FileTemplateLoader ftl2 = <span class="keyword">new</span> <span class="constructor">FileTemplateLoader(<span class="params">new</span> File(<span class="string">"/usr/data/templates"</span>)</span>);</span><br><span class="line">ClassTemplateLoader ctl = <span class="keyword">new</span> <span class="constructor">ClassTemplateLoader(<span class="params">getClass</span>()</span>, <span class="string">""</span>);</span><br><span class="line">TemplateLoader<span class="literal">[]</span> loaders = <span class="keyword">new</span> TemplateLoader<span class="literal">[]</span> &#123; ftl1, ftl2, ctl &#125;;</span><br><span class="line">MultiTemplateLoader mtl = <span class="keyword">new</span> <span class="constructor">MultiTemplateLoader(<span class="params">loaders</span>)</span>;</span><br><span class="line">cfg.set<span class="constructor">TemplateLoader(<span class="params">mtl</span>)</span>;</span><br></pre></td></tr></table></figure><p>FreeMarker 将会尝试从/tmp/templates 目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板，那么它就会使用类加载器来加载模板。</p><h4 id="从其他资源加载模板"><a href="#从其他资源加载模板" class="headerlink" title="从其他资源加载模板"></a>从其他资源加载模板</h4><p>需要自己实现加载器实现freemarker.cache.TemplateLoader 或freemarker.cache.URLTemplateLoader 接口</p><h4 id="模板路径"><a href="#模板路径" class="headerlink" title="模板路径"></a>模板路径</h4><p>强烈建议模板加载器使用 URL 风格的路径</p><h3 id="模板缓存"><a href="#模板缓存" class="headerlink" title="模板缓存"></a>模板缓存</h3><p>FreeMarker 是会缓存模板的（假设使用 Configuration 对象的方法来创建 Template 对象）。这就是说当调用 getTemplate 方法时， FreeMarker 不但返回了Template 对象的结果，而且还会将它存储在缓存中，当下一次再以相同（或相等）路径调用 getTemplate 方法时，那么它只返回缓存的 Template 实例， 而不会再次加载和解析模板文件了。</p><p>如果更改了模板文件，当下次调用模板时， FreeMarker 将会自动重新载入和解析模板。然而，要检查模板文件是否改变内容了是需要时间的，有一个 Configuration 级别的设置被称作为“更新延迟”可以用来配置这个时间。这个时间就是从上次对某个模板检查更新后， FreeMarker 再次检查模板所要间隔的时间。 其默认值是 5 秒。如果想要看到模板立即更新的效果，那么就要把它设置为 0。要注意某些模板加载器也许在模板更新时可能会有问题。例如，典型的例子就是在基于类加载器的模板加载器就不会注意到模板文件内容的改变。</p><p>当调用了 getTemplate 方法时，与此同时 FreeMarker 意识到这个模板文件已经被<br>移除了，所以这个模板也会从缓存中移除。 如果 Java 虚拟机认为会有内存溢出时，默认情况它会将任意的模板从缓存中移除。此外，你还可以使用 Configuration 对象的clearTemplateCache 方法手动清空缓存。</p><p>何时将一个被缓存了的模板清除的实际应用策略是由配置的属性 cache_storage来确定的，通过这个属性可以配置任何 CacheStorage 的实现。对于大多数用户来说，使用 freemarker.cache.MruCacheStorage 就足够了。这个缓存存储实现了二级最近使用的缓存。在第一级缓存中，组件都被强烈引用到特定的最大数目（引用次数最多的组件不会被 Java 虚拟机抛弃，而引用次数很少的组件则相反）。当超过最大数量时，最近最少使用的组件将被送至二级缓存中，在那里它们被很少引用，直到达到另一个最大的数目。引用强度的大小可以由构造方法来指定。例如，设置强烈部分为 20，轻微部分为 250：</p><p>或者，使用 MruCacheStorage 缓存，它是默认的缓存存储实现。当创建了一个新的 Configuration 对象时，它使用一个 maxStrongSize 值为0 的 MruCacheStorage 缓存来初始化，maxSoftSize 的值是Integer.MAX_VALUE（也就是说在实际中，是无限大 的）。 但是使用非 0 的 maxStrongSize 对于高负载的服务器来说也许是一个更好的策略，对于少量引用的组件来说，如果资源消耗已经很高的话， Java 虚拟机往往会引发更高的资源消耗，因为它不断从缓存中抛出经常使用的模板，这些模板还不得不再次加载和解析。</p><h3 id="错误控制"><a href="#错误控制" class="headerlink" title="错误控制"></a>错误控制</h3><h4 id="可能的异常"><a href="#可能的异常" class="headerlink" title="可能的异常"></a>可能的异常</h4><p>当加载和解析模板时发生异常： 调用了 Configuration.getTemplate(…) 方法， FreeMarker 就要把模板文件加载到内存中然后来解析它（除非模板已经在Configuration 对象中被缓存了）。 在这期间，有两种异常可能发生：</p><ul><li>因模板文件没有找到而发生的 IOException 异常，或在读取文件时发生其他的 I/O 问题。比如没有读取文件的权限，或者是磁盘错误。这些错误的发出者是TemplateLoader 对象，可以将它设置到 Configuration 对象中。（为了正确起见：这里所说的”文件”，是简化形式。例如，模板也可以存储在关系型数据库的表中。这是 TemplateLoader 所要做的事。）</li><li>根据FTL语言的规则，模板文件发生语法错误时会导致 freemarker.core.ParseException 异常。当获得 Template 对象（ Configuration.getTemplate(…)）时，这种错误就会发生，而不是当执行（Template.process(…) ）模板的时候。这种异常是IOException 异常的一个子类。</li></ul><p>当执行（处理）模板时发生的异常，也就是当调用了 Template.process(…)方法时会发生的两种异常：</p><ul><li>当试图写入输出对象时发生错误而导致的 IOException 异常。</li><li>当执行模板时发生的其它问题而导致的freemarker.template.TemplatException 异常。比如，一个频繁发生的错误，就是当模板引用一个不存在的变量。默认情况下，当TemplatException 异常发生时， FreeMarker 会用普通文本格式在输出中打印出 FTL 的错误信息和堆栈跟踪信息。然后通过再次抛出 TemplatException异常而中止模板的执行，然后就可以捕捉到 Template.process(…)方法抛出的异常了。而这种行为是可以来定制的。FreeMarker也会经常写 TemplatException 异常的日志。</li></ul><h4 id="根据-TemplateException-来制定处理方式"><a href="#根据-TemplateException-来制定处理方式" class="headerlink" title="根据 TemplateException 来制定处理方式"></a>根据 TemplateException 来制定处理方式</h4><p>Configuration中通过setTemplateExceptionHandler可以制定处理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateExceptionHandler</span> <span class="keyword">implements</span> <span class="title">TemplateExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTemplateException</span><span class="params">(TemplateException te, Environment env,</span></span></span><br><span class="line"><span class="function"><span class="params">java.io.Writer out)</span> <span class="keyword">throws</span> TemplateException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">out.write(<span class="string">"[ERROR: "</span> + te.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TemplateException(<span class="string">"Failed to print error message. Cause: "</span> + e, env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cfg.setTemplateExceptionHandler(<span class="keyword">new</span> MyTemplateExceptionHandler());</span><br></pre></td></tr></table></figure><p>FreeMarker 本身带有这些预先编写的错误控制器：</p><ul><li>TemplateExceptionHandler.DEBUG_HANDLER：打印堆栈跟踪信息（包括 FTL 错误信息和 FTL 堆栈跟踪信息）和重新抛出的异常。这是默认的异常控制器（也就是说，在所有新的 Configuration 对象中，它是初始配置的）。</li><li>TemplateExceptionHandler.HTML_DEBUG_HANDLER：DEBUG_HANDLER 相同，但是它可以格式化堆栈跟踪信息，那么就可以在 Web 浏览器中来阅读错误信息。当你在制作 HTML 页面时，建议使用它而不是DEBUG_HANDLER。</li><li>TemplateExceptionHandler.IGNORE_HANDLER：简单地压制所有异常（但是要记住， FreeMarker 仍然会写日志）。它对处理异常没有任何作用，也不会重新抛出异常。</li><li>TemplateExceptionHandler.RETHROW_HANDLER：简单重新抛出所有异常而不会做其它的事情。这个控制器对 Web 应用程序（假设你在发生异常之后不想继续执行模板）来说非常好，因为它在生成的页面发生错误的情况下，给了你很多对 Web应用程序的控制权。</li></ul><h4 id="在模板中明确地处理错误"><a href="#在模板中明确地处理错误" class="headerlink" title="在模板中明确地处理错误"></a>在模板中明确地处理错误</h4><p>你可以在模板中直接控制错误。通常这不是一个好习惯（尽量保持模板简单，技术含量不要太高），但有时仍然需要：</p><ul><li>控制不存在/为空的变量：请阅读模板开发指南/模板/表达式/处理不存在的值部分。</li><li>在发生障碍的“ porlets” 中留存下来</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>当你想要读取一个变量时， FreeMarker 将会以这种顺序来查找，直到发现了完全匹配的的变量名称才会停下来</p><ol><li>在 Environment 对象中：<ol><li>如果在循环中，在循环变量的集合中。循环变量是由 （ 如 list 指令）来创建的。</li><li>如果在宏中，在宏的局部变量集合中。局部变量可以由 local 指令创建。而且，宏的参数也是局部变量。</li><li>在当前的命名空间中。可以使用 assign 指令将变量放到一个命名空间中。</li><li>在由 global 指令创建的变量集合中。FTL 将它们视为数据模型的普通成员变量一样来控制它们。也就是说，它们在所有的命名空间中都可见，你也可以像访问一个数据模型中的数据一样来访问它们。</li></ol></li><li>在传递给 process 方法的数据模型对象中。</li><li>在 Configuration 对象存储的共享变量集合中。</li></ol><p>1.4, 2,3 共同构成了全局变量的集合</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>输入编码</p><p>可以使用配置对象的setEncoding(Locale locale, String encoding)方法来填充编码表；编码表初始化时是空的。默认的初始编码是系统属性 file.encoding 的值，但是可以通过 setDefaultEncoding 方法来设置一个不同的默认值。</p><p>输出编码</p><p>原则上， FreeMarker 不处理输出内容的字符集问题，因为 FreeMarker 将输出内容都写入了 java.io.Writer 对象中。而 Writer 对象是由封装了 FreeMarker（比如 Web应用框架）的软件生成的，那么输出内容的字符集就是由封装软件来控制的。而 FreeMarker有一个称为 output_encoding（开始于 FreeMarker 2.3.1 版本之后）的设置。封装软件应该使用这个设置（ Writer 对象使用的字符集） 来通知 FreeMarker 在输出中（ 否则 FreeMarker 不能找到它）使用哪种字符集。 </p><p>为独立模板设置编码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writer w = <span class="keyword">new</span> <span class="constructor">OutputStreamWriter(<span class="params">out</span>, <span class="params">outputCharset</span>)</span>;</span><br><span class="line">Environment env = template.create<span class="constructor">ProcessingEnvironment(<span class="params">dataModel</span>, <span class="params">w</span>)</span>;</span><br><span class="line">env.set<span class="constructor">OutputEncoding(<span class="params">outputCharset</span>)</span>;</span><br><span class="line">env.process<span class="literal">()</span>;</span><br></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>在多线程运行环境中， Configuration 实例， Template 实例和数据模型应该是永远不能改变（只读）的对象。也就是说， 创建和初始化它们（如使用 set…方法） 之后， 就不能再修改它们了（ 比如不能再次调用 set…方法）。 </p><p>不鼓励你编写修改数据模型对象或共享变量的方法。多试试使用存储在环境对象（这个对象是为独立的 Template.process 调用而创建的，用来存储模板处理的运行状态）中的变量，所以最好不要修改那些由多线程使用的数据。</p><h3 id="Bean-的包装"><a href="#Bean-的包装" class="headerlink" title="Bean 的包装"></a>Bean 的包装</h3><p>当 出 现 下 面 这 些 情 况 时 ， 你 会 想 使 用 BeansWrapper 包 装 器 来 代 替 DefaultObjectWrapper：<br>在模板执行期间，数据模型中的 Collection 和 Map 应该被允许修改。（ DefaultObjectWrapper 会阻止这样做，因为当它包装对象时创建了数据集合的拷贝，而这些拷贝都是只读的。）<br>如果 array， Collection 和 Map 对象的标识符当在模板中被传递到被包装对象的方法时，必须被保留下来。 也就是说，那些方法必须得到之前包装好的同类对象。<br>如果在之前列出的 Java API 中的类（ 如 String， Map， List 等），应该在模板中可见。还有，默认情况下它们是不可见的，但是可以设置获取的可见程度</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>默认情况下，不能访问模板制作时认为是不安全的一些方法。比如，不能使用同步方法（ wait， notify， notifyAll），线程和线程组的管理方法（ stop， suspend，resume， setDaemon ， setPriority ），反射相关方法（ Field setXxx ，Method.invoke， Constructor.newInstance， Class.newInstance，Class.getClassLoader 等）， System 和 Runtime 类中各种有危险性的方法（ exec， exit， halt， load 等）。 BeansWrapper 也有一些安全级别（被称作“方法暴露的级别”）， 默认的级别被称作为 EXPOSE_SAFE，它可能对大多数应用程序来说是适用的。没有安全保证的级别称作是 EXPOSE_ALL，它允许你调用上述的不安全的方法。一个严格的级别是 EXPOSE_PROPERTIES_ONLY，它只会暴露出 bean 属性的 getters方法。最后，一个称作是 EXPOSE_NOTHING 的级别，它不会暴露任何属性和方法。这种情况下，你可以通过哈希表模型接口访问的那些数据只是 map 和资源包中的项，还有，可以从通用 get(Object) 方法和 get(String)方法调用返回的对象，所提供的受影响的对象就有这样的方法。</p><h4 id="访问静态变量"><a href="#访问静态变量" class="headerlink" title="访问静态变量"></a>访问静态变量</h4><p>从 BeansWrapper.getStaticModels() 方法返回的 TemplateHashModel 对象可以用来创建哈希表模型来访问静态方法和任意类型的字段。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeansWrapper <span class="keyword">wrapper</span> = BeansWrapper.getDefaultInstance();</span><br><span class="line">TemplateHashModel staticModels = <span class="keyword">wrapper</span>.getStaticModels();</span><br><span class="line">TemplateHashModel fileStatics = (TemplateHashModel) staticModels.<span class="keyword">get</span>("java.io.File");</span><br><span class="line">root.put("File", fileStatics);</span><br></pre></td></tr></table></figure><p>模板中使用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">File</span>.</span></span><span class="built_in">list</span><span class="constructor">Roots()</span> <span class="keyword">as</span> fileSystemRoot&gt;...&lt;/#<span class="built_in">list</span>&gt;</span><br></pre></td></tr></table></figure><p>如果使用，将带来更多自由</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put(<span class="string">"statics"</span>, <span class="module-access"><span class="module"><span class="identifier">BeansWrapper</span>.</span></span>get<span class="constructor">DefaultInstance()</span>.get<span class="constructor">StaticModels()</span>);</span><br></pre></td></tr></table></figure><p>可以这样使用</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>statics[<span class="string">"java.lang.System"</span>].currentTimeMillis()&#125;</span><br></pre></td></tr></table></figure><p>注意，这样会有更多的安全隐患，比如，如果方法暴露级别对 EXPOSE_ALL 是很弱的，那么某些人可以使用这个模型调用 System.exit()方法。</p><h4 id="访问枚举类型"><a href="#访问枚举类型" class="headerlink" title="访问枚举类型"></a>访问枚举类型</h4><p>BeansWrapper.getDefaultInstance()返回的对象可以被用作创建访问枚举类型值的哈希表模型</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeansWrapper <span class="keyword">wrapper</span> = BeansWrapper.getDefaultInstance();</span><br><span class="line">TemplateHashModel enumModels = <span class="keyword">wrapper</span>.getEnumModels();</span><br><span class="line">TemplateHashModel roundingModeEnums = (TemplateHashModel)enumModels.<span class="keyword">get</span>("java.math.RoundingMode");</span><br><span class="line">root.put("RoundingMode", roundingModeEnums);</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">RoundingMode</span><span class="selector-class">.UP</span></span><br></pre></td></tr></table></figure><p>更自由的方式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put(<span class="string">"enums"</span>, <span class="module-access"><span class="module"><span class="identifier">BeansWrapper</span>.</span></span>get<span class="constructor">DefaultInstance()</span>.get<span class="constructor">EnumModels()</span>);</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">$</span><span class="template-variable">&#123;enums["java.<span class="keyword">math</span>.RoundingMode"].UP&#125;</span></span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>默认情况下， FreeMarker 会按如下顺序来查找日志包，而且会自动使用第一个发现的包： SLF4J，Apache Commons Logging，Log4J，Avalon， java.util.logging。 然而，如果在 freemarker.log.Logger 类用合适的参数中调用静态的 selectLoggerLibrary 方法，而且在使用任何 FreeMarker 类之前记录信息，你可以明确地选择一个日志包，或者关闭日志功能。</p><h3 id="在-Servlet-中使用-FreeMarker"><a href="#在-Servlet-中使用-FreeMarker" class="headerlink" title="在 Servlet 中使用 FreeMarker"></a>在 Servlet 中使用 FreeMarker</h3><ol><li>复制 freemarker.jar 到（从 FreeMarker 发布包的 lib 目录中）你的 Web<br>应用程序的 WEB-INF/lib 目录下。</li><li>将下面的部分添加到 Web 应用程序的 WEB-INF/web.xml 文件中（调整它是否<br>需要）。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">freemarker.ext.servlet.FreemarkerServlet</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FreemarkerServlet 设置: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>TemplatePath<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>NoCache<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ContentType<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>text/html; charset=UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制使用 UTF-8 作为输出编码格式! --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FreeMarker 设置: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>template_update_delay<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 0 只对开发使用! 否则使用大一点的值. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>default_encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>ISO-8859-1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模板文件的编码方式. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>number_format<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0.##########<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.ftl<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 为了阻止从 Servlet 容器外部访问 MVC 的视图层组件。</span></span><br><span class="line"><span class="comment">RequestDispatcher.forward/include 应该起到作用。</span></span><br><span class="line"><span class="comment">移除下面的代码可能开放安全漏洞!</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span></span><br><span class="line">FreeMarker MVC Views</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.ftl<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不允许任何人访问这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>它是怎么工作的？让我们来看看 JSP 是怎么工作的。许多 servlet 容器处理 JSP 时使用一个映射为*.jsp 的 servlet 请求 URL 格式。 这样 servlet 就会接收所有 URL 是以.jsp结尾的请求，查找请求 URL 地址中的 JSP 文件，内部编译完后交给 Servlet，然后调用 生 成 信 息 的 serlvet 来 生 成 页 面 。 这 里 为 URL 类 型 是 *.ftl 映射的 FreemarkerServlet 也是相同功能，只是 FTL 文件不会编译给 Servlet，而是给 Template 对象，之后 Template 对象的 process 方法就会被调用来生成<br>页面。</p><p>Freemarker现在页面中寻找变量，其次在 HttpServletRequest中寻找，然后在 HttpSession，最后在ServletContext中</p><p>FreemarkerServlet 也会在数据模型中放置 3 个哈希表，这样你就可以直接访问 3 个对象中的属性了。这些哈希表变量是： Request， Session， Application（和ServletContext 对应）。它还会暴露另外一个名为 RequestParameters 的哈希表，这个哈希表提供访问 HTTP 请求中的参数。</p><p>FreemarkerServlet 也有很多初始参数。它可以被设置从任意路径来加载模板，从类路径下，或相对于 Web 应用程序的目录。你可以设置模板使用的字符集。你还可以设置想使用的对象包装器等。</p><p>通过子类别， FreemarkerServlet 易于定制特殊需要。那就是说，你需要对所有模板添加一个额外的可用变量，使用 servlet 的子类，覆盖 preTemplateProcess()方法，在模板被执行前，将你需要的额外数据放到模型中。或者在 servlet 的子类中，在Configuration 中设置这些全局的变量作为共享变量。</p><h4 id="包含其它Web应用程序资源中的内容"><a href="#包含其它Web应用程序资源中的内容" class="headerlink" title="包含其它Web应用程序资源中的内容"></a>包含其它Web应用程序资源中的内容</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@include_page <span class="attribute">path</span>=<span class="string">"path/to/some.jsp"</span>/&gt;</span><br></pre></td></tr></table></figure><p>和使用 JSP 指令是相同的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include <span class="attribute">page</span>=<span class="string">"path/to/some.jsp"</span>&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;@include_page ...&gt;</code>会开始一个独立的 HTTP 请求处理。</p><p>除了参数 path 之外，你也可以用布尔值（当不指定时默认是 true）指定一个名为 inherit_params 可选的参数来指定被包含的页面对当前的请求是否可见 HTTP 请求中的参数。</p><p>最后，你可以指定一个名为 params 的可选参数，来指定被包含页面可见的新请求参数。 如果也传递继承的参数，那么指定参数的值将会得到前缀名称相同的继承参数的值。params 的值必须是一个哈希表类型，它其中的每个值可以是字符串，或者是字符串序列（如果你需要多值参数）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@include_page <span class="attribute">path</span>=<span class="string">"path/to/some.jsp"</span> <span class="attribute">inherit_params</span>=<span class="literal">true</span> params=&#123;<span class="string">"foo"</span>: <span class="string">"99"</span>, <span class="string">"bar"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>]&#125;/&gt;</span><br></pre></td></tr></table></figure><p>如果“foo”有值“111”和“123”，那么现在它会有“99”，“111”，“123”。</p><h4 id="在-FTL-中使用-JSP-客户化标签"><a href="#在-FTL-中使用-JSP-客户化标签" class="headerlink" title="在 FTL 中使用 JSP 客户化标签"></a>在 FTL 中使用 JSP 客户化标签</h4><p>FreemarkerServlet 将一个哈希表类型的 JspTaglibs 放到数据模型中，就可以使用它来访问 JSP 标签库了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">html</span>=<span class="string">JspTaglibs[</span>"/<span class="attr">WEB-INF</span>/<span class="attr">struts-html.tld</span>"]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">bean</span>=<span class="string">JspTaglibs[</span>"/<span class="attr">WEB-INF</span>/<span class="attr">struts-bean.tld</span>"]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">@bean.message</span> <span class="attr">key</span>=<span class="string">"welcome.title"</span>/&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">@html.errors</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">@html.form</span> <span class="attr">action</span>=<span class="string">"/query"</span>&gt;</span></span><br><span class="line">Keyword: <span class="tag">&lt;<span class="name">@html.text</span> <span class="attr">property</span>=<span class="string">"keyword"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Exclude: <span class="tag">&lt;<span class="name">@html.text</span> <span class="attr">property</span>=<span class="string">"exclude"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">@html.submit</span> <span class="attr">value</span>=<span class="string">"Send"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">@html.form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 JSP 客户化标签是在 JSP 环境中来书写操作的，它们假设变量（在 JSP 中常被指代“beans”）被存储在 4 个范围中： page 范围， request 范围， session 范围和 application 范围。FTL 没有这样的表示法（ 4 种范围），但是 FreemarkerServlet 给客户化标签提供仿真的环境，这样就可以维持 JSP 范围中的“ beans”和 FTL 变量之间的对应关系。对于自定义的JSP标签，请求，会话和应用范围是和真实JSP相同的：javax.servlet.ServletContext，HttpSession 和 ServerRequest 对象中的属性。从 FTL 的角度来看，这三种范围都在数据模型中</p>]]></content>
    
    <summary type="html">
    
      FreeMarker;Java模板引擎;程序开发
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>FreeMarker-模板开发笔记</title>
    <link href="http://howiefh.github.io/2015/04/30/freemarker-template-development-note/"/>
    <id>http://howiefh.github.io/2015/04/30/freemarker-template-development-note/</id>
    <published>2015-04-30T01:19:31.000Z</published>
    <updated>2020-05-02T14:28:14.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">Welcome $</span><span class="template-variable">&#123;user&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">#if</span> <span class="attr">user</span> == <span class="string">"Big Joe"</span>&gt;</span>, our beloved leader<span class="tag">&lt;/<span class="name">#if</span>&gt;</span>!</span></span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">animals</span> <span class="attr">as</span> <span class="attr">being</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;being.name&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;being.price&#125;</span><span class="xml"> Euros</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#<span class="meta-keyword">include</span> <span class="string">"/copyright_footer.html"</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数值和类型"><a href="#数值和类型" class="headerlink" title="数值和类型"></a>数值和类型</h2><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><ul><li>标量：<ul><li>字符串</li><li>数字</li><li>布尔值</li><li>日期</li></ul></li><li>容器：<ul><li>哈希表</li><li>序列</li><li>集</li></ul></li><li>子程序：<ul><li>方法和函数：方法是来自于数据模型（它们反射了 Java 对象的方法），而函数是定义在模板内的（使用了函数指令-这也是高级主题），但二者可以用同一种方式来使用。内置的方法<code>${avg(6, 10, 20)}</code></li><li>用户自定义指令：按经验来说，如果能够实现，请先用自定义指令而不要用函数/方法。 <code>&lt;@box title=&quot;Attention!&quot;&gt; hello &lt;/@box&gt;</code></li></ul></li><li>其它/很少使用：<ul><li>节点</li></ul></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板（ FTL 编程）是由如下部分混合而成的：</p><ul><li>Text 文本：文本会照着原样来输出。</li><li>Interpolation 插值： 这部分的输出会被计算的值来替换。插值由${和}所分隔（或者#{和}，这种风格已经不建议再使用了）。</li><li>FTL tags 标签： FTL 标签和 HTML 标签很相似，但是它们却是给 FreeMarker 的指示， 而且不会打印在输出内容中。</li><li>Comments 注释： FTL 的注释和 HTML 的注释也很相似，但它们是由<code>&lt;#--</code>和<code>--&gt;</code>来分隔的。注释会被 FreeMarker 所忽略，更不会在输出内容中显示。</li></ul><p>FTL 标签不可以在其他 FTL 标签和插值中使用。下面这样写就是错的：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#if &lt;#<span class="meta-keyword">include</span> <span class="string">'foo'</span>&gt;=<span class="string">'bar'</span>&gt;...<span class="meta-string">&lt;/#if&gt;</span></span></span><br></pre></td></tr></table></figure><p>注释可以放在 FTL 标签和插值中间。<br>插值可以在文本区域和字符串中出现，但是不能在标签中使用</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#if</span> $</span></span><span class="template-variable">&#123;isBig&#125;</span><span class="xml"><span class="tag">&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的就是错误的，正确的应该这样写</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;#if isBig&gt;</span><span class="section">&lt;/if&gt;</span></span><br></pre></td></tr></table></figure><p>FreeMarker可以忽略标签、插值内的空格，但是<code>&lt;</code>、<code>&lt;\</code>和指令之间的空格不能忽略</p><h3 id="快速浏览"><a href="#快速浏览" class="headerlink" title="快速浏览"></a>快速浏览</h3><ul><li>直接指定值<ul><li>字符串： “Foo” 或者 ‘Foo’ 或者 “It’s &quot;quoted&quot;“ 或者<br>r”C:\raw\string”</li><li>数字： 123.45</li><li>布尔值： true, false</li><li>序列： [“foo”, “bar”, 123.45], 1..100</li><li>哈希表： {“name”:”green mouse”, “price”:150}</li></ul></li><li>检索变量<ul><li>顶层变量： user</li><li>从哈希表中检索数据： user.name, user[“name”]</li><li>从序列中检索： products[5]</li><li>特殊变量： .main  。 特殊变量是由 FreeMarker 引擎本身定义的，为了使用它们，可以按照如下语法形式来进行： .variable_name。</li></ul></li><li>字符串操作<ul><li>插值（ 或连接）： “Hello ${user}!”（或”Free” + “Marker”）</li><li>获取一个字符： name[0]</li></ul></li><li>序列操作<ul><li>连接： users + [“guest”]</li><li>序列切分： products[10..19] 或 products[5..]</li></ul></li><li>哈希表操作<ul><li>连接： passwords + {“joe”:”secret42”}</li></ul></li><li>算数运算: (x * 1.5 + 10) / 2 - y % 100</li><li>比较运算 ： <code>x == y, x != y, x &lt; y, x &gt; y, x &gt;= y, x &lt;= y, x &amp;lt; y,</code> 等等</li><li>逻辑操作： !registered &amp;&amp; (firstVisit || fromEurope)</li><li>内建函数： name?upper_case</li><li>方法调用： repeat(“What”, 3)</li><li>处理不存在的值<ul><li>默认值： name!”unknown” 或者(user.name)!”unknown” 或者<br>name! 或者 (user.name)!</li><li>检测不存在的值： name?? 或者(user.name)??</li></ul></li><li>运算符的优先级</li></ul><p>最高优先级运算符:  [subvarName][subStringRange].?(methodParams)<br>一元前缀运算符: +expr -expr !expr<br>乘除法，求模: * / %<br>加减法: + -<br>关系运算符: <code>&lt; &gt; &lt;= &gt;= (相当于: gt, lt, 等)</code><br>相等，不等: == (也可以是: =) !=<br>逻辑与: &amp;&amp;<br>逻辑或: ||<br>数字范围: ..</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>可以使用转义字符<code>\\</code>、<code>\&quot;</code>等。一种特殊的字符串就是原生字符串。在原生字符串中，反斜杠和${没有特殊的含义，它们被视为普通的字符。 为了表明字符串是原生字符串，在开始的引号或单引号之前放置字母 r，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">r"$&#123;foo&#125;"</span>&#125;</span><br><span class="line">$&#123;<span class="string">r"C:\foo\bar"</span>&#125;</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;foo&#125;</span><br><span class="line">C:<span class="symbol">\f</span>oo<span class="symbol">\b</span>ar</span><br></pre></td></tr></table></figure><p>连接</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span>&#123;<span class="string">"Hello <span class="variable">$</span>&#123;user&#125;!"</span>&#125;</span><br><span class="line"><span class="variable">$</span>&#123;<span class="string">"<span class="variable">$</span>&#123;user&#125;<span class="variable">$</span>&#123;user&#125;<span class="variable">$</span>&#123;user&#125;<span class="variable">$</span>&#123;user&#125;"</span>&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">"Hello "</span> + <span class="keyword">user</span> <span class="title">+ "!"&#125;</span></span><br><span class="line"><span class="title">$</span>&#123;<span class="keyword">user</span> <span class="title">+ user</span> + <span class="keyword">user</span> <span class="title">+ user</span>&#125;</span><br></pre></td></tr></table></figure><p>效果上是一样的</p><p>可以使用${user[0]}获取某个字符，也可以使用${user[2..5]}和${user[2..]}获取子串</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>数值文字 08, +8, 8.00 和 8 是完全相等的，它们都是数字 8。因此${08}, ${+8}, ${8.00}和${8}打印的都是相同的。</p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="meta">list</span> [<span class="string">"winter"</span>, <span class="string">"spring"</span>, <span class="string">"summer"</span>, <span class="string">"autumn"</span>] <span class="meta">as</span> <span class="meta">x</span>&gt;</span><br><span class="line">$&#123;<span class="meta">x</span>&#125;</span><br><span class="line">&lt;/#<span class="meta">list</span>&gt;</span><br></pre></td></tr></table></figure><p>列表中的项目是表达式，那么也可以这样做： [2 + 2, [1, 2, 3, 4], “whatnot”]，其中第一个子变量是数字 4，第二个子变量是一个序列，第三个子变量是字符串”whatnot”。<br>也可以用 start..end 定义存储数字范围的序列，这里的 start 和 end 是处理数字值表达式，比如 2..5 和[2, 3, 4, 5]是相同的，但是使用前者会更有效率（ 内存占用少而且速度快）。</p><p>序列的连接可以使用+号来进行</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> [<span class="string">"Joe"</span>, <span class="string">"Fred"</span>] + [<span class="string">"Julia"</span>, <span class="string">"Kate"</span>] <span class="keyword">as</span> user&gt;</span><br><span class="line">- <span class="variable">$&#123;user&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><p>序列切分<br>使用 [firstindex..lastindex] 可以获取序列中的一部分，这里的firstindex 和lastindex 表达式的结果是数字。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在模板中指定一个哈希表，就可以遍历用逗号分隔开的“键/值”对，把列表放到花括号内。键和值成对出现并以冒号分隔。看这个例子：{“name”:”green mouse”, “price”:150}。注意到名字和值都是表达式，但是用来检索的名字就必须是字符串类型的。</p><p>两种方式从哈希表中检索数据:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">book</span><span class="selector-class">.name</span></span><br><span class="line"><span class="selector-tag">book</span><span class="selector-attr">[<span class="string">"name"</span>]</span></span><br></pre></td></tr></table></figure><p>哈希表也可以使用+连接，如果有相同键，+后面出现的会覆盖之前的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">#assign ages = &#123;<span class="meta-string">"Joe"</span>:23, <span class="meta-string">"Fred"</span>:25&#125; + &#123;<span class="meta-string">"Joe"</span>:30, <span class="meta-string">"Julia"</span>:18&#125;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="、-、-、-、"><a href="#、-、-、-、" class="headerlink" title="+、-、*、/、%"></a><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></h3><p>内建函数int可以取出整数部分<code>${(x/2)?int}</code></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>为了避免大于、小于被当做标签处理，可以用圆括号包含表达式<code>&lt;#if (x&gt;y)&gt;&lt;/if&gt;</code>。也可以用lt、<br>lte、gt、gte来比较</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>内建函数以?形式提供变量的不同形式或者其他信息。</p><ul><li>字符串使用的内建函数：<ul><li>html: 字符串中所有的特殊 HTML 字符都需要用实体引用来代替（比如<code>&lt;</code>代替&lt;）。</li><li>cap_first:字符串的第一个字母变为大写形式</li><li>lower_case:字符串的小写形式</li><li>upper_case:字符串的大写形式</li><li>trim:去掉字符串首尾的空格</li></ul></li><li>序列使用的内建函数：<ul><li>size：序列中元素的个数</li></ul></li><li>数字使用的内建函数：<ul><li>int:数字的整数部分（比如-1.9?int 就是-1）</li></ul></li></ul><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><ul><li>avg求均值</li><li>repeat重复输出3次What<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;repeat(<span class="string">"What"</span>, <span class="number">3</span>)&#125;</span><br><span class="line">$&#123;avg(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="处理不存在的变量"><a href="#处理不存在的变量" class="headerlink" title="处理不存在的变量"></a>处理不存在的变量</h2><p>一个不存在的变量和一个是 null 的变量， 对于 FreeMarker 来说是一样的，所以这里所指的丢失包含这两种情况。<br>就像下面的例子，当 user 从数据模型中丢失时，模板将会将user 的值表示为字符串”Anonymous”。（若 user 并没有丢失，那么模板就会表现<br>出”Anonymous”不存在一样）：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;h1&gt;</span>Welcome $&#123;user!<span class="string">"Anonymous"</span>&#125;!<span class="params">&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以在变量名后面通过放置??来询问 FreeMarker 一个变量是否存在。 将它和 if 指令合并，那么如果 user 变量不存在的话将会忽略整个问候代码段：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#if</span> <span class="attr">user</span>??&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome $</span><span class="template-variable">&#123;user&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">#if</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>关于多级访问的变量，比 如 animals.python.price，书写代码：animals.python.price!0，仅当 animals.python 存在而仅仅最后一个子变量 price 可能不存在（这种情况下我们假设价格是 0）。 如果 animals 或者 python<br>不存在，那么模板处理过程将会以“未定义的变量”错误而停止。为了防止这种情况的发生，可以这样来书写代码(animals.python.price)!0。这种情况下当 animals 或<br>python 不存在时表达式的结果仍然是 0。 对于??也是同样用来的处理这种逻辑的</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>使用形式概览：unsafe_expr!default_expr 或 unsafe_expr! 或 (unsafe_expr)!default_expr 或(unsafe_expr)!</p><p>hits!0 或 colors![“red”, “green”, “blue”]</p><p>由于 FreeMarker 2.3.x 版本的源码中的小失误所以必须这么来做。 !（作为默认值操作）的优先级非常低。 这就意味着${x!1 + y}会被 FreeMarker 误解为${x!(1 + y)}，而真实的意义是${(x!1) + y}。 这个源码的错误在 FreeMarker 2.4 中会得到修正。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>字符串</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#escape</span> <span class="attr">x</span> <span class="attr">as</span> <span class="attr">x</span>?<span class="attr">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Title: $</span><span class="template-variable">&#123;book.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Description:</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#noescape</span>&gt;</span>$</span><span class="template-variable">&#123;book.description&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">#noescape</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Comments:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">comments</span> <span class="attr">as</span> <span class="attr">comment</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comment"</span>&gt;</span></span></span><br><span class="line"><span class="xml">$</span><span class="template-variable">&#123;comment&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#escape</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果插值在文本区 （也就是说，不再字符串表达式中）， 如果 escapse 指令起作用了，即将被插入的字符串会被自动转义（将&amp;转为&amp;）。如果你要生成 HTML，那么强烈建议你利用它来阻止跨站脚本攻击和非格式良好的 HTML 页面。使用 noescape 可以抵消 escape 的转义。如果你想把所有的输出为大写的话可以x.upper_case</p><p>数字</p><p>小数的分隔符是根据所在地的标准确定的，如匈牙利的分隔符是<code>,</code>。那么<code>{1.5}</code>会输出<code>1,5</code></p><p>可以通过string内置函数来设置输出的格式。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>自定义指令可以使用 macro 指令来定义，这是模板设计者所关心的内容。 Java 程序员若不想在模板中实现定义指令，而是在 Java 语言中实现指令的定义， 这时可以使用freemarker.template.TemplateDirectiveModel 类来扩展</p><p>定义宏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">greet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"+2"</span>&gt;</span>Hello Joe!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用自定义指令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;@greet&gt;</span><span class="section">&lt;/@greet&gt;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;@greet/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">greet</span> <span class="attr">person</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"+2"</span>&gt;</span>Hello $</span><span class="template-variable">&#123;person&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@greet <span class="attribute">person</span>=<span class="string">"Joe"</span>/&gt;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"+2"</span>&gt;</span>Hello Joe!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用自定义指令提供的参数必须与宏定义的参数对应，如果多于宏定义中的参数则报错；如果少于宏定义中的参数，并且宏中也没有指定有默认值的话，会报错，指定了默认值的话不会报错。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">greet</span> <span class="attr">person</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"+2"</span> <span class="attr">color</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;color&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>Hello $</span><span class="template-variable">&#123;person&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用下面的指令是对的，如果没有color=”red”的话则会报错</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@greet <span class="attribute">person</span>=<span class="string">"Joe"</span>/&gt;</span><br></pre></td></tr></table></figure><p>someParam=foo 和 someParam=”${foo}”是不同的。第一种情况，是把变量 foo 的值作为参数的值来使 用。第二种情况则是使用插值形式的字符串，那么参数值就是字符串了</p><h4 id="嵌套内容"><a href="#嵌套内容" class="headerlink" title="嵌套内容"></a>嵌套内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">border</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">4</span> <span class="attr">cellspacing</span>=<span class="string">0</span> <span class="attr">cellpadding</span>=<span class="string">4</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">#nested</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;#nested&gt;</code>指令执行位于开始和结束标记指令之间的模板代码段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">@border</span>&gt;</span>The bordered text<span class="tag">&lt;/<span class="name">@border</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">4</span> <span class="attr">cellspacing</span>=<span class="string">0</span> <span class="attr">cellpadding</span>=<span class="string">4</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">The bordered text<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>nested可以多次被调用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;#macro do_thrice&gt;</span></span><br><span class="line"><span class="section">&lt;#nested&gt;</span></span><br><span class="line"><span class="section">&lt;#nested&gt;</span></span><br><span class="line"><span class="section">&lt;#nested&gt;</span></span><br><span class="line"><span class="section">&lt;/#macro&gt;</span></span><br><span class="line"><span class="section">&lt;@do_thrice&gt;</span></span><br><span class="line"><span class="attribute">Anything</span>.</span><br><span class="line"><span class="section">&lt;/@do_thrice&gt;</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Anything.</span><br><span class="line">Anything.</span><br><span class="line">Anything.</span><br></pre></td></tr></table></figure><p>嵌套的内容可以是任意有效的 FTL，包含其他的用户自定义指令，这样也是对的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">@border</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">@do_thrice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">@greet</span> <span class="attr">person</span>=<span class="string">"Joe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">@do_thrice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">@border</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">repeat</span> <span class="keyword">count</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">local</span> y = <span class="string">"test"</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">list</span> 1..<span class="keyword">count</span> <span class="keyword">as</span> x&gt;</span><br><span class="line"><span class="variable">$&#123;y&#125;</span> <span class="variable">$&#123;count&#125;</span>/<span class="variable">$&#123;x&#125;</span>: &lt;#nested&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line">&lt;@<span class="keyword">repeat</span> <span class="keyword">count</span>=3&gt;<span class="variable">$&#123;y</span>!<span class="string">"?"</span>&#125; <span class="variable">$&#123;x</span>!<span class="string">"?"</span>&#125; <span class="variable">$&#123;count</span>!<span class="string">"?"</span>&#125;&lt;/@<span class="keyword">repeat</span>&gt;</span><br></pre></td></tr></table></figure><p>在宏的外部，宏中的局部变量是不可见的</p><h4 id="宏和循环变量"><a href="#宏和循环变量" class="headerlink" title="宏和循环变量"></a>宏和循环变量</h4><p>自定义指令也可以有循环变量。比如我们来扩展先前例子中的 do_thrice 指令，就可以拿到当前的循环变量的值。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro do_thrice&gt;</span><br><span class="line">&lt;#nested <span class="number">1</span>&gt;</span><br><span class="line">&lt;#nested <span class="number">2</span>&gt;</span><br><span class="line">&lt;#nested <span class="number">3</span>&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line">&lt;@do_thrice ; x&gt; &lt;#-- 用户自定义指令 使用<span class="string">";"</span>代替<span class="string">"as"</span> --&gt;</span><br><span class="line">$&#123;x&#125; Anything.</span><br><span class="line">&lt;/@do_thrice&gt;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>Anything.</span><br><span class="line"><span class="symbol">2 </span>Anything.</span><br><span class="line"><span class="symbol">3 </span>Anything.</span><br></pre></td></tr></table></figure><p>nested 指令（当然参数可以是任意的表达式）的参数。 循环变量的名称是在自定义指令的开始标记（ <code>&lt;@...&gt;</code>）的参数后面通过分号确定的。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">repeat</span> <span class="keyword">count</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">list</span> 1..<span class="keyword">count</span> <span class="keyword">as</span> x&gt;</span><br><span class="line">&lt;#nested x, x/2, x==<span class="keyword">count</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line">&lt;@<span class="keyword">repeat</span> <span class="keyword">count</span>=4 ; c, halfc, last&gt;</span><br><span class="line"><span class="variable">$&#123;c&#125;</span>. <span class="variable">$&#123;halfc&#125;</span>&lt;#<span class="keyword">if</span> last&gt; Last!&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/@<span class="keyword">repeat</span>&gt;</span><br></pre></td></tr></table></figure><p>如果在分号后面指定了比 nested 指令还多的变量，那么最后的循环变量将不会被创建（在嵌套内容中不会被定义）。如果分号后的指定了比nested指令少的变量，没有问题。</p><h4 id="在模板中可以定义三种类型的变量"><a href="#在模板中可以定义三种类型的变量" class="headerlink" title="在模板中可以定义三种类型的变量"></a>在模板中可以定义三种类型的变量</h4><ul><li>简单变量： 它能从模板中的任何位置来访问，或者从使用 include 指令引入的<br>模板访问。可以使用 assign 或 macro 指令来创建或替换这些变量。</li><li>局部变量： 它们只能被设置在宏定义体内，而且只在宏内可见。一个局部变量的生<br>存周期只是宏的调用过程。可以使用 local 指令在宏定义体内创建或替换局部变<br>量。</li><li>循环变量：循环变量是由指令（如 list）自动创建的，而且它们只在指令的开始<br>和结束标记内有效。宏的参数是局部变量而不是循环变量。</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>当运行 FTL 模板时，就会有使用 assign 和 macro 指令创建的变量的集合（可能是空的），可以从前一章节来看如何使用它们。像这样的变量集合被称为 namespace 命名空间。在简单的情况下可以只使用一个命名空间，称之为 main namespace 主命名空间。</p><h4 id="创建一个库"><a href="#创建一个库" class="headerlink" title="创建一个库"></a>创建一个库</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">copyright</span> <span class="attr">date</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Copyright (C) $</span><span class="template-variable">&#123;date&#125;</span><span class="xml"> Julia Smith. All rights reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">mail</span> = <span class="string">"jsmith@acme.com"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>把上面的这些定义存储在文件 lib/my_test.ftl 中（目录是你存放模板的位置）。假设想在aWebPage.ftl中使用这个模板。如果在aWebPage.ftl 使用<code>&lt;#include &quot;/lib/my_test.ftl&quot;&gt;</code>，那么就会在主命名空间中创建两个变量，所以就不得不使用import 指令来代替 include 了。它会为 lib/my_test.ftl 创建一个空的命名空间，然后在那里执行。在 aWebPage.ftl中就可以用下面的代码。如果在主命名空间中有一个变量，名为 mail 或 copyright， 那么就不会引起混乱了</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/lib/my_test.ftl"</span> <span class="keyword">as</span> my&gt;</span><br><span class="line">&lt;#-- 被称为<span class="string">"my"</span>的哈希表就会是那个<span class="string">"大门"</span> --&gt;</span><br><span class="line">&lt;@my.copyright date=<span class="string">"1999-2002"</span>/&gt;</span><br><span class="line">$&#123;my.mail&#125;</span><br></pre></td></tr></table></figure><h4 id="命名空间和数据模型"><a href="#命名空间和数据模型" class="headerlink" title="命名空间和数据模型"></a>命名空间和数据模型</h4><p>数据模型中的变量在任何位置都是可见的。数据模型user在lib/my_test.ftl和aWebPage.ftl 都能访问。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">copyright</span> <span class="attr">date</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Copyright (C) $</span><span class="template-variable">&#123;date&#125;</span><span class="xml"> $</span><span class="template-variable">&#123;user&#125;</span><span class="xml">. All rights reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">mail</span> = <span class="string">"$</span></span></span><span class="template-variable">&#123;user&#125;</span><span class="xml"><span class="tag"><span class="string">@acme.com"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在模板的命名空间（可以使用 assign 或 macro 指令来创建的变量）中的变量有着比数据模型中的变量更高的优先级，可以覆盖数据模型。如果想在模板中创建任何命名空间都能访问的变量，那么可以使用global指令</p><h4 id="命名空间的生命周期"><a href="#命名空间的生命周期" class="headerlink" title="命名空间的生命周期"></a>命名空间的生命周期</h4><p>命名空间由使用的 import 指令中所写的路径来识别。如果想多次 import 这个路径，那么只会为第一次的 import 引用创建命名空间执行模板。 后面相同路径的 import 只是创建一个哈希表当作访问相同命名空间的“门”。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/lib/my_test.ftl"</span> <span class="keyword">as</span> my&gt;</span><br><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/lib/my_test.ftl"</span> <span class="keyword">as</span> foo&gt;</span><br><span class="line">&lt;#<span class="keyword">import</span> <span class="string">"/lib/my_test.ftl"</span> <span class="keyword">as</span> bar&gt;</span><br><span class="line">$&#123;my.mail&#125;, $&#123;foo.mail&#125;, $&#123;bar.mail&#125;</span><br><span class="line">&lt;#assign mail=<span class="string">"jsmith@other.com"</span> <span class="keyword">in</span> my&gt;</span><br><span class="line">$&#123;my.mail&#125;, $&#123;foo.mail&#125;, $&#123;bar.mail&#125;</span><br></pre></td></tr></table></figure><p>还要注意命名空间是不分层次的，它们相互之间是独立存在的。那么，如果在命名空间N1 中 import 命名空间 N2，那 N2 也不在 N1 中， N1 只是可以通过哈希表来访问 N2。 这和在主命名空间中 importN2，然后直接访问命名空间 N2 是一样的过程。</p><p>每一次模板执行工作都是一个分离且有序的过程，它们仅仅存在一段很短的时间， 同时页面用以呈现内容，然后就和所有填充过的命名空间一起消失了。</p><h4 id="编写类库"><a href="#编写类库" class="headerlink" title="编写类库"></a>编写类库</h4><p>命名和Java包命名规范相似，存放路径一般是</p><p>/lib/example.sourceforge.net/example.ftl 或<br>/lib/geocities.com/jsmith/example.ftl</p><h3 id="空白处理"><a href="#空白处理" class="headerlink" title="空白处理"></a>空白处理</h3><p>FreeMarker 提供下面的工具来处理这个问题：</p><ul><li>忽略某些模板文件的空白的工具（ 解析阶段空白就被移除了）：<ul><li>剥离空白： 这个特性会自动忽略在 FTL 标签周围多余的空白。这个特性可以通过模板来随时使用和禁用。</li><li>微调指令： t， rt 和 lt， 使用这些指令可以明确地告诉 FreeMarker 去忽略某些空白。可以阅读参考手册来获取更多信息。</li><li>FTL 参数 strip_text：这将从模板中删除所有顶级文本。对模板来说这很有用，它只包含某些定义的宏（还有以他一些没有输出的指令），因为它可以移除宏定义和其他顶级指令中的换行符，这样可以提高模板的可读性。</li></ul></li><li>从输出中移除空白的工具（移除临近的空白）：<ul><li>compress 指令</li></ul></li></ul><h3 id="替换（方括号）语法"><a href="#替换（方括号）语法" class="headerlink" title="替换（方括号）语法"></a>替换（方括号）语法</h3><p>这个特性从 FreeMarker 2.3.4 版本后才可用。<br>FreeMarker 支持一个替换的语法。就是在 FreeMarker 的指令和注释中用[和]来代替<code>&lt;</code>和<code>&gt;</code>，例如下面这个例子：</p><ul><li>调用预定义指令： [#list animals as being]…[/#list]</li><li>调用自定义指令： [@myMacro /]</li><li>注释： [#– the comment –]</li></ul><p>为了使用这种语法从而代替默认语法，从模板开始，使用 ftl 指令都要使用这用语法。[#ftl]</p><p>2.4 版本中的默认配置将会自动检测，也就是说第一个 FreeMarker 标签决定了语法形式（它可以是任意的，而不仅仅是 ftl）。</p>]]></content>
    
    <summary type="html">
    
      FreeMarker;Java模板引擎;模板开发
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机笔记三（JVM性能监控与故障处理工具）</title>
    <link href="http://howiefh.github.io/2015/04/09/jvm-note-3/"/>
    <id>http://howiefh.github.io/2015/04/09/jvm-note-3/</id>
    <published>2015-04-09T08:00:22.000Z</published>
    <updated>2020-05-02T14:28:14.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多工具都是对jdk/lib/tools.jar类库的一层包装，SUN JDK监控和故障处理工具：</p><ol><li>jps：JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li><li>jstat：JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</li><li>jinfo：Configuration Info for Java，显示虚拟机配置信息</li><li>jmap：Memory Map for Java，生成虚拟机的内存转储快照(heap dump文件)</li><li>jhat：JVM Heap Dump Browser，用于分析heap dump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器查看分析结果</li><li>jstack：Stack Trace for Java，显示虚拟机的线程快照</li></ol><p>然后还有两个GUI工具：</p><ol><li>jconsole：略微过时的JVM各状态查看工具</li><li>visualVM：Sun出品的强大的JVM工具，推荐使用！</li></ol><a id="more"></a><h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><h3 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h3><p>它和Unix的ps命令有类似功能：</p><p><strong>它可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Claas，main()函数所在的类）的名称，以及这些进程的内地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier）。</strong></p><p>命令格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">jps</span> <span class="selector-attr">[options]</span> <span class="selector-attr">[hostid]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是jar包，输出jar包路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时JVM参数</td></tr></tbody></table><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>jstat的全称是JVM Statistics Monitoring Tool，它用于监视虚拟机各种运行状态信息。可以显示<strong>本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</strong>，在没有GUI图形界面，只提供纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p><p>命令格式：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat <span class="comment">[options vmid <span class="comment">[interval<span class="comment">[s|ms]</span> <span class="comment">[count]</span>]</span> ]</span></span><br></pre></td></tr></table></figure><p>假如我想监控gc，每250ms查询一次，一共查询20次，进程号为1234。命令就是:<code>jstat -gc 1234 250 20</code>。如何监控远程机器呢？很简单，使用jstatd。和mysql类似，mysql是客户端，mysqld是服务器端。所以当远程机器开始了jstatd，就相当于开启了远程虚拟机进程的监控，本地可通过RMI查看远程机器的运行时数据，非常方便。</p><p>在这里，option主要分为3类：</p><ol><li>类装载</li><li>垃圾收集</li><li>运行期编译状况</li></ol><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视Java堆状况，包括Eden区、2个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最新空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>监视内容与-gc基本相同，但会额外输出导致上一次GC产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间</td></tr><tr><td>-gcold</td><td>监视老年代GC的状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，输出主要关注使用到的最大和最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大和最小空间</td></tr><tr><td>-compiler</td><td>输出JIT编译期编译过的方法、耗时等信息</td></tr><tr><td>-printcomplilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table><h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>jinfo全称为Configuration Info for Java，它的作用是<strong>实时地查看和调整虚拟机的各项参数</strong>。</p><p>命令格式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ <span class="keyword">option</span> ] pid</span><br></pre></td></tr></table></figure><p>使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK1.6或以上版本的话，使用java -XX:+PrintFlasFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。可以使用-flag [+-] name或-flag name=value修改一部分运行期可写的虚拟机参数值。</p><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>jmap全称为Memory Map for Java，它<strong>用于生成堆转储快照（一般称为heap dump或者dump文件）</strong>。jmap的作用并不仅仅是为了获取dump文件供其他工具分析当前JVM的内存情况，它还可以<strong>查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等</strong>。它的命令格式为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ <span class="keyword">option</span> ] vmid</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成java堆转储快照。格式为：-dump:[live,]format=b,file=<filename>，其中live子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在F-Queue中等待Filalizer线程执行finalize方法的对象，只在Linux/Solaris平台下有效</td></tr><tr><td>-heap</td><td>显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效</td></tr><tr><td>-histo</td><td>显示堆中统计信息，包括类、实例数量和合计容量</td></tr><tr><td>-permstat</td><td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td></tr></tbody></table><p>比如我得到dump快照，就可以先通过jps拿到虚拟机的LVMID，然后使用<code>jmap -dump:format=b,file=haha.bin &lt;LVMID&gt;</code>就可以了。</p><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的http/html服务器，生成dump文件的分析结果后，可以在浏览器中查看。但一般情况下，这个命令使用的几率不会太大。首先对于线上服务器来说，生成dump快照后，分析快照是一个很耗时且吃硬件的过程，如果dump快照过于复杂，甚至会影响线上服务；其次jhat的分析功能相对来说比较简陋。建议是将这个dump快照拷贝到线下，然后使用更强大的GUI工具来直观分析，比如Eclipse Memory Analyzer、IBM HeapAnalyzer等工具。</p><p>如果打开后，可以在本地localhost:7000查看结果。拉到最下面有个Heap Histogram，点进去就可以看到虚拟机中所有对象实例的数目和大小。</p><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>jstack全称为Stack Trace for Java，它<strong>用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内存每一个线程正在执行的方法堆栈的集合</strong>。生成线程快照的主要目的就是<strong>定位线程出现长时间停顿的原因</strong>，比如线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</p><p>命令格式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ <span class="keyword">option</span> ] vmid</span><br></pre></td></tr></table></figure><p>option选项说明如下：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><p>在JDK 1.5中，java.lang.Thread类新增了一个叫做getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象，使用这个方法可以通过简单的几行代码就完成jstack的大部分功能。</p><h3 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h3><p>JDK除了提供大量的命令行工具外，还提供了两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员</p><p>其实现在Sun主推VisualVM了，因为JConsole稍微有点老。而且可视化工具基本不需要学习，稍微看看就知道啥情况。说白了就是把上面的jdk工具，比如jstat、jmap、jstack结果套个GUI。</p><p>其中看了感觉比较有价值的是BTrace这个插件，它竟然可以动态的在项目中插入调试信息</p>]]></content>
    
    <summary type="html">
    
      深入理解Java虚拟机; JVM性能监控与故障处理工具;
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）</title>
    <link href="http://howiefh.github.io/2015/04/08/jvm-note-2/"/>
    <id>http://howiefh.github.io/2015/04/08/jvm-note-2/</id>
    <published>2015-04-08T14:40:22.000Z</published>
    <updated>2020-05-04T11:33:41.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器、虚拟机栈、本地方法栈这些区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。垃圾收集器关注的是堆和方法区中的垃圾。</p><a id="more"></a><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>这种计数法无法解决循环引用的问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在Java1.2之前，引用的定义是这样的：</p><blockquote><p>如果reference类型的数据中存储的数值代表的是另外一块内存中的起始地址，就称这块内存代表着一个引用。</p></blockquote><p>我们可以看到，这个引用的定义是非常狭隘的，和指针类似，只有引用、非引用区分。所以，在JAVA1.2以后提出了新的引用定义：</p><ul><li>强引用：在代码中普遍存在的，类似<code>Object obj = new Object();</code>。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象</li><li>软引用：用来描述一些还有用，但并非必须的对象。这样当系统要发生内存溢出异常之前，就会把软引用列进第二次垃圾回收的计划中。SoftReference</li><li>弱引用：比软引用还弱的引用，被弱引用的对象只能存活到下一次垃圾回收之前。WeakReference</li><li>虚引用：最弱的一种引用关系了。使用虚引用的唯一目的就是在这个对象回收前收到一个系统回收通知。PhantomReference</li></ul><p>《Java编程思想》中也有相关<a href="http://howiefh.github.io/2014/10/30/thinking-in-java-note-5/#持有引用">内容</a></p><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过<strong>两次标记过程</strong>：</p><p>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()已经被JVM调用过（说明一个对象的finalize()方法只能执行一次），JVM会将这两种情况视为“没有必要执行”。如果这个对象有必要执行finalize()方法，JVM就会把它放在F-Queue中，稍后JVM会触发一个低优先级的线程去执行。<strong>但是去执行并并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。</strong>finalize()是对象逃脱死亡命运的最后一次机会，稍后GC将会对F-Queue进行第二次小规模的标记，如果在finalize()中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/jvm-gc-mark.png" alt="两次标记过程"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> FinalizeEscapeGC &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> isAlive() &#123;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> finalize() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*output:</span></span><br><span class="line"><span class="comment">finalize method executed!</span></span><br><span class="line"><span class="comment">haha, i'm still alive!</span></span><br><span class="line"><span class="comment">5555, i'm dead!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以清楚的看到，第一次在finalize()中赋值给类变量，所以和root同根自救了一次，但是因为finalize()只会执行一次，所以第二次标记时，JVM发现已经调用这个对象的finalize()，就知道没必要再执行finalize了，然后就被回收了。</p><p>作者非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。<strong>有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，完全可以忘掉Java有finalize()。</strong></p><h3 id="方法回收区"><a href="#方法回收区" class="headerlink" title="方法回收区"></a>方法回收区</h3><p>Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是因为在方法区进行垃圾回收的“性价比”很低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收70%-95%的空间，而永久代的垃圾回收效率也远低于此。</p><p>永久代的垃圾收集主要回收两部分内容：</p><ul><li><p>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p></li><li><p>无用的类：判断一个类是无用的类，条件比废弃变量要苛刻的多，要同时满足下面3个条件才能算是“无用的类”：</p><ol><li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li><li>加载该类的ClassLoader已经被回收</li><li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）</li></ol></li></ul><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul><li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高；而是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。<strong>现在的商业JVM采用这种算法来回收新生代，IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。</strong>当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</strong>，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用其他内存（这里指老年代）进行分配担保。分配担保就相当于现实生活中的担保。</li><li>标记-整理算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（老年代就是采用这个方法）</li><li>分代收集算法：当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是<strong>根据对象的存活周期的不同将内存划分为几块</strong>，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。比如新生代存活对象少，就采用Eden-Survivor复制算法；老年代存活对象少，复制的话代价太大，就可以采用标记-整理算法。</li></ul><p>总结：<br>标记-清除：简单，效率低，有内存碎片<br>复制：新生代，实现简单，运行高效，空间利用率低<br>标记-整理：老年代</p><h2 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可达性分析在逐个检查引用链和GC停顿（保证分析工作的一致性）上浪费时间较多。主流Java虚拟机使用的都是准确式GC，虚拟机应当有办法直接得知哪些地方存放着对象的引用。HotSpot是通过一个OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，那样占用空间太多，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong>，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/jvm-hotspot-gc.jpg" alt="HotSpot虚拟机的垃圾收集器"></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本，历史最悠久。新生代的，单线程的，只会用一个CPU或一个线程工作，并且收集时，必须暂停所有的工作线程，直到收集结束。它依然是虚拟机运行在Client端的默认新生代收集器。简单而高效，因为它不需要考虑线程切换，只专注一次把收集工作搞定，而且在Client端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这个本质上就是Serial收集器的多线程版本。许多运行在Server模式下的虚拟机中首选的<strong>新生代收集器</strong>，其中还有一个与性能无关<strong>但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。（原因是Parallel Scavenge收集器和后面的G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现的，其余几种收集器则共用了框架代码）。ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后的默认新生代收集器，当然也可以使用<code>-XX:+UseParNewGC</code>选项来显式指定使用</p><p>单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，<strong>它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用```-XX:ParallelGCThreads参数来限制收集器的线程数。</strong></p><p>然后提前解释一下<strong>并行</strong>和<strong>并发</strong>的概念，因为后面会有几个并发和并行的收集器：</p><ul><li>并行(Parallel)：指多条垃圾收集线程并行工作，<strong>但此时用户线程仍然处于等待状态</strong>。所以，遇到 Parallel 关键字的话，都是并行。所以当它们工作的时候，用户线程是阻塞的。所以也是 stop the world</li><li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会根据时间片轮转交替进行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。所以遇到 concurrent 关键字就是 GC 线程和用户线程在一段时间内交叉运行，不会将用户线程阻塞，不是 stop the world</li></ul><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge也是<strong>一个新生代收集器</strong>，它也是<strong>使用复制算法</strong>的收集器，同时也是<strong>并行的多线程收集器</strong>。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。</p><p>这就说说一下应用场景了。</p><ul><li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li></ul><p>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</p><ul><li>-XX:MaxGCPauseMillis:大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。</li><li>-XX:GCTimeRatio:大于0小于100的整数.假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N),比如设置为19,占比就是1/(1+19)=5%，默认值是99，即1%。</li><li>-XX:+UseAdaptiveSizePolicy:这也是一个有用的参数，放在这里说一下。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、Eden、Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。<strong>自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别</strong></li></ul><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。这个收集器的主要意义就是被Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用；另外一个就是CMS的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK 1.6之后才提供的。前面说过，Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK 1.6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到JDK 1.6推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，<strong>在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合</strong>。</p><h3 id="CMS（Comcurrent-Mark-Sweep）收集器"><a href="#CMS（Comcurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Comcurrent Mark Sweep）收集器"></a>CMS（Comcurrent Mark Sweep）收集器</h3><p>CMS收集器是<strong>以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用<strong>尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求</strong></p><p>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p><ol><li>初始标记(stop the world):初始标记仅仅只是标记一下GC roots能直接关联到的对象，速度很快</li><li>并发标记:并发标记就是进行GC Roots Tracing的过程</li><li>重新标记(stop the world):重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短</li><li>并发清除:垃圾清除</li></ol><p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS收集器的优点在于<strong>并发收集、低停顿</strong>，但是也不是完美的，主要有3个显著的缺点：</p><ol><li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。虽然有了解决方法，但已经废除了，就不多说了。</li><li><strong>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，它<strong>需要预留一部分空间提供并发收集时的线程使用。在JDK1.5默认设置下，CMS收集器在老年代使用了68%的空间会被激活，这是一个偏保守的设置。</strong>如果在应用中，老年代增长不是太快，可以适当调高这个参数-XX:CMSInitiatingOccupancyFraction。要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure”失败，这时候JVM会启动后备方案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，因为是单线程，停顿时间就会更长了。所以如果大量出现”Concurrent Mode Failure”，就可以将这个值调低</li><li>CMS是基于<strong>标记-清除</strong>算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有”Stop The World”了。另外，虚拟机还设计了一个参数-XX:CMSFullGCsBeforeCompaction,用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li></ol><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点。</p><p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。<br>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。<br>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><p>初始标记（Initial Marking）<br>并发标记（Concurrent Marking）<br>最终标记（Final Marking）<br>筛选回收（Live Data Counting and Evacuation）</p><p>总结：</p><p>Serial收集器：新生代；复制算法；单线程；GC区域名称(GCLogging)：DefNew；优点：简单高效，Client模式下的默认新生代收集器；缺点：进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”。<br>ParNew收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：ParNew；优点：Server模式下的虚拟机中首选的新生代收集器。除了Serial收集器外，目前只有它能与CMS收集器配合工作；缺点：在单CPU的环境中绝对不会有比Serial收集器更好的效果<br>Parallel Scavenge收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：PSYoungGen；优点：吞吐量优先。缺点：无法与CMS配合使用<br>Serial Old收集器：老年代；标记-整理算法（Mark-Compact）；单线程；<br>GC区域名称(GCLogging)：Tenured；优点：与Parallel Scavenge配合；作为CMS的后备方案。缺点：性能较低<br>Parallel Old收集器：老年代；标记-整理算法（Mark-Compact）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：与Parallel Scavenge配合，真正成为吞吐量优先的收集器组合。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br>CMS收集器：老年代；标记-清楚算法（Mark-Sweep）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：响应速度快、停顿时间短。；缺点：1.对CPU资源敏感；2.无法处理浮动垃圾，因为GC标记和用户线程并发运行着；3.空间碎片多<br>G1：新生代，老年代；标记-整理，复制；多线程；优点：并行与并发，分代收集，空间整合，可预测的停顿</p><h2 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span> secs]<span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p><p>后面方括号内部的“3324K-&gt;152K（3712K）”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K（11904K）”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p><p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致</p><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td></tr><tr><td>UseParNewGC</td><td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td>UseConcMarkSweepGC</td><td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td></tr><tr><td>UseParallelGC</td><td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td></tr><tr><td>UseParallelOldGC</td><td>打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td></tr><tr><td>SurvivorRatio</td><td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代</td></tr><tr><td>UseAdaptiveSizePolicy</td><td></td></tr><tr><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td><td></td></tr><tr><td>HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td></tr><tr><td>ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>GCTimeRatio</td><td>GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>MaxGCPauseMillis</td><td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>CMSinitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td>UseCMSCompactAtFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td></tr><tr><td>CMSFullGCsBeforeCompaction</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p><p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p><p>请看下面例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @VM param -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEdenAllocation</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] alloc1, alloc2, alloc3, alloc4;</span><br><span class="line"></span><br><span class="line">        alloc1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看vm的参数：</p><p>-XX:+UseSerialGC： 保证使用Serial/SerialOld收集器作为例子<br>-Xms20M -Xmx20M -Xmn10M： 限制堆为20M，10M新生代10M老年代<br>-XX:SurvivorRatio=8： 新生代Eden区与一个Survivor区比例8:1<br>-XX:+PrintGCDetails： 收集器日志参数</p><p>输出如下：</p><p>[GC[DefNew: 6817K-&gt;484K(9216K), 0.0038248 secs] 6817K-&gt;6628K(19456K), 0.0038598 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 5072K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)<br>  eden space 8192K,  56% used [0x00000000f9a00000, 0x00000000f9e7af60, 0x00000000fa200000)<br>  from space 1024K,  47% used [0x00000000fa300000, 0x00000000fa379110, 0x00000000fa400000)<br>  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)<br> tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)<br>   the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)<br> compacting perm gen  total 21248K, used 2519K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)<br>   the space 21248K,  11% used [0x00000000fae00000, 0x00000000fb075e08, 0x00000000fb076000, 0x00000000fc2c0000)<br>No shared spaces configured.</p><p>分析如下：</p><p>分配alloc4时发生一次minorGC，Eden区从6817K减少到484K。由于alloc1、alloc2、alloc3都是存活的所以没有对象可收。<br>这次GC发生的原因是给allo-cation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。<br>GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。<br>这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Sur-vivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p><p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>]]></content>
    
    <summary type="html">
    
      深入理解Java虚拟机; 垃圾收集器与内存分配策略
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机笔记一（Java内存区域与内存溢出异常）</title>
    <link href="http://howiefh.github.io/2015/04/07/jvm-note-1/"/>
    <id>http://howiefh.github.io/2015/04/07/jvm-note-1/</id>
    <published>2015-04-07T15:31:59.000Z</published>
    <updated>2020-05-04T11:32:41.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中，会把内存分为不同的数据区域。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/jvm-model.jpg" alt="Java虚拟机运行时数据区"></p><a id="more"></a><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>它是一块较小的内存空间，作用可以当做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器</strong>（字节码行号记录器）。</p><p>因为java虚拟机的多线程是通过时间片轮转占用cpu，所以一个处理器只会执行一条线程的指令。为了线程切换后能恢复到正确的位置，每个线程都需要一个独立的程序计数器，这样能使各个线程之间的计数器互不影响，独立存储。这类区域为<strong>线程私有内存</strong>。</p><ul><li>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址</li><li>如果线程正在执行的是 Native 方法，这个计数器值为空（Undefined）</li></ul><p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是<strong>线程私有</strong>的，它的生命周期和线程相同。</p><p>Java虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。调用一个方法时创建新的栈帧并压入栈顶部，方法执行完后，这个栈帧就会弹出栈帧的元素作为这个方法的返回值，并清除这个栈帧，Java栈的栈顶就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。</p><p>局部变量表存放了基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><ul><li><strong>如果线程请求的栈深度太深，超出了虚拟机所允许的深度，就会出现StackOverFlowError（比如无限递归。因为每一层栈帧都占用一定空间，而 Xss 规定了栈的最大空间，超出这个值就会报错）</strong></li><li><strong>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存空间，会出现OOM</strong></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈的作用是非常类似的，区别是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</strong>。因为虚拟机规范没有对这块有太多规定，所以不同的虚拟机可以自由实现它。有的虚拟机（Sun的HotSpot虚拟机）直接就把<strong>本地方法栈和虚拟机栈合二为一</strong>了。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，它是<strong>所有线程共享的，在虚拟机启动时候创建</strong>。Java堆唯一的目的就是<strong>存放对象实例（当然还有数组）</strong>，Java堆是垃圾收集器管理的主要区域。堆可分为老年代和新生代，再细分还可以分为Eden空间、From Survivor空间、To Survivor空间等。主流虚拟机都可扩展（-Xmx和-Xms）</p><p><strong>如果堆上没有内存可以完成对象实例的分配，并且堆已经达到了最大容量，无法向OS继续申请的时候，就会抛出OOM异常</strong>。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与Java堆一样，是<strong>所有线程共享</strong>的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p><p>对于习惯在 HotSpot虚拟机上开发部署程序的开发者来说，很多人倾向于把方法区成为“永久代（Perm Generation）”，但<strong>本质上两者并不等价，仅仅是因为 HotSpot 团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区而已</strong>，目的是为了让 HotSpot 的垃圾回收器可以像管理 Java 堆一样管理这部分内存，不能再编写这部分内存的内存管理代码。对于其他虚拟机（比如 JRockit、IMB J9）来说，是不存在永久代的概念的。</p><p>其实 JVM 规范并没有规定如何实现方法区，但是从目前状况来看：<strong>使用永久代来实现方法区不是一个好的做法。因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize 的上限，而 J9和 Jrockit 只要没有触碰到进程可用内存的上限，例如32位的4GB，就不会出现问题）</strong>，同时有极少数方法（比如 String.intern()，这个函数能直接操纵方法区中的常量池）会因为这个原因在不同虚拟机有不同的表现。因此，HotSpot 团队有了<em>放弃永久代并逐步改为采用 Native Memory 来实现方法区的规划</em>，在目前已经发布的 JDK1.7 的 HotSpot 中，已经把放在永久代的字符串常量池移出。</p><p><strong>当方法区无法满足分寸分配需求时，就会抛出OOM异常</strong>。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>方法区的一部分</strong>。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(class文件中)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在<strong>类加载后存放到方法区的运行时常量池中</strong>。除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于class文件常量池的另外一个重要特性是具备动态性，Java语言并不要求常量一定是在编译期产生，也就是说，并非是预置入class文件中常量池的内容内能进入方法区的运行时常量池，<strong>运行期间也可以将新的常量放入池中，用的比较多是有String.intern()</strong>，可以去看下文档。说的很清楚：</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分</strong>，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>JDK 1.4中新加入了NIO(NEW Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，<strong>因为避免了在Java堆和Native堆中来回复制数据</strong>。</p><p>服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OOM。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>程序计数器：行号指示器；空间小，最快；线程私有；不会有OOM</li><li>Java虚拟机栈：Java方法执行的内存模型,用于存储局部变量表、操作栈、动态链接、方法出口等信息；线程私有；StackOverFlowError,OOM</li><li>本地方法栈：和Java虚拟机栈发挥的作用非常相似，但是市委Native方法服务。</li><li>Java堆：存放对象实例；线程共享；OOM</li><li>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；线程共享；OOM</li><li>运行时常量池：方法区的一部分；线程共享；存放编译期生成的各种字面量和符号引用；OOM</li><li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现；新NIO利用了直接内存，效率高</li></ul><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>探讨Java堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol><li><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就得执行类的加载过程，这个过程在第七章讲了。TODO 添加第七章链接</p></li><li><p>类加载检查过之后，虚拟机就为这个新生对象分配内存。目前有两种做法，使用哪种方式是由 GC 回收器是否带有压缩整理功能决定的：</p><ul><li>指针碰撞（Bump the Pointer）：假设Java堆中内存是绝对规整的 ，没用过的内存和用过的内存用一个指针划分（<em>需要保证 java 堆中的内存是规整的，一般情况是使用的 GC 回收器有压缩整理功能</em>），分配内存仅仅是将指针向空闲空间那边挪动一段与对象大小相等的距离。假如需要分配8个字节，指针就往后挪8个字节</li><li>空闲列表（Free List）：假设Java堆中内存是不规整的，已使用内存和空闲内存交错，虚拟机维护一个列表，记录哪些内存是可用的，分配的时候从列表中遍历，找到合适的内存分配，然后更新列表</li></ul></li><li><p>分配内存过程中还需要解决线程安全问题。 就刚才的一个修改指针操作，就会带来隐患：对象 A 正分配内存呢，突然对象 B 又同时使用了原来的指针来分配 B 的内存。解决方案也有两种：</p><ul><li>同步处理——实际上虚拟机采用 CAS 配上失败重试来保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，成为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，用完并分配新的TLAB时，才需要同步锁定（虚拟机是否使用 TLAB，可以通过<code>-XX:+/-UseTLAB</code> 参数来设置）</li></ul></li><li><p>给内存分配了空间之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p></li><li><p>接下来要对对象进行必要的设置，比如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的 hashcode 值是多少、对象的 GC 分代年龄等信息，这些信息都放在对象头中。</p></li><li><p>上面的步骤都完成后，从虚拟机角度来看，一个新的对象已经产生了，但是从 Java 程序的视角来看，对象创建才刚刚开始——<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p></li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>首先我们要知道的是：<strong>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instantce Data）、对齐补充（Padding）。</strong></p><ol><li>对象头（Header）：包含两部分信息。第一部分用于存储对象自身的运行时数据，如 hashcode 值、GC 分代的年龄、锁状态标志、线程持有的锁等，官方称为“Mark Word”。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li><li>实例数据（Instance Data）：就是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li><li>内存对齐，对象的大小必须是8字节的整数倍</li></ol><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ol><li><p>假如代码出现在方法体中，那么Object obj就会存在在<strong>Java虚拟机栈的本地变量表</strong>中，作为一个引用类型数据。</p></li><li><p>new Object()则存在在<strong>Java堆</strong>上。另外，在Java堆上还必须包含能查找到该对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在<strong>方法区</strong>中。</p></li><li><p>由于引用类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式可能不同，主流的有：</p><ol><li>使用句柄：Java堆中划分一块区域作为句柄池，引用存储的是对象的句柄地址，而句柄中含有对象实例数据和类型数据各自的数据信息</li><li>直接指针：引用中直接存储的就是对象的地址，同时还必须包括方法区类型信息的指针</li></ol></li></ol><p>下面是对应的图片：</p><p><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/jvm-reference-handler.jpg" alt="通过句柄访问对象"><br><img src="https://cdn.jsdelivr.net/gh/howiefh/assets/img/jvm-direct-reference.jpg" alt="通过直接指针访问对象"></p><p>对于引用类型的实现，不同的实现方法有不同的特点：</p><ol><li>使用句柄：Java堆会划出一块区域作为句柄池，引用中存储的是稳定的句柄地址，而句柄中包含了<strong>对象实例数据（也在Java堆）和类型数据（方法区中）</strong>各自的地址信息。在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只需要改变句柄中的实例数据指针，而引用本身核方法区的类型数据指针都不需要修改</li><li>直接指针：速度更快，因为不需要间接寻址。对于效率而言是更好的，Sun HotSpot就是使用这种方式实现对象访问的。但在其他虚拟机中，使用句柄方式也非常常见。</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>下面我们会演示几个小程序，目的有两个：</p><ol><li>通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容</li><li>希望以后遇到类似问题时，能根据异常的信息快速判断是哪个区域的内存溢出，知道怎样的代码可能会导致这些区域的内存溢出，以及出现这些异常后改如何处理</li></ol><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>这个顾名思义，是最常见的。因为Java堆上存储的是对象实例，所以只要保证GC roots到该对象有路径可达，就会在不断创建对象的过程中达到Java堆的最大容量而导致溢出。下面是实例代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span>&#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">list</span>.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的结果可以看到，发生了OOM异常。要解决这个异常，一般是把内存快照dump（通过-XX:+HeapDumpOnOutOfMemoryError）下来用工具（Eclipse Memmory Analyzer）分析，确认<strong>内存中的对象是否是必要的</strong>，也就是要先分清到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory overflow）。</p><ul><li>如果是内存泄露：使用工具查看泄露对象到GC Roots的引用链。于是就可以顺藤摸瓜找到泄漏对象是通过怎样的路径关联GC Roots的，从而准确定位泄露代码的位置</li><li>如果是内存溢出：就应当检查虚拟机的堆参数（-Xmx和-Xms），与机器物理内存对比看是否可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长等情况，尝试减少程序运行期间的内存消耗</li></ul><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>-Xss可以设置栈容量。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常</li></ul><p>通过调用无限递归调用，单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。通过不断创建线程倒是可以产生内存溢出异常，不过和栈空间是否足够大并不存在任何联系。</p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（<span class="keyword">String</span>[]args）&#123;</span><br><span class="line">        <span class="keyword">String</span> str1=<span class="keyword">new</span> StringBuilder（<span class="string">"计算机"</span>）.append（<span class="string">"软件"</span>）.toString（）；</span><br><span class="line">        System.out.<span class="built_in">println</span>（str1.intern（）==str1）；</span><br><span class="line">        <span class="keyword">String</span> str2=<span class="keyword">new</span> StringBuilder（<span class="string">"ja"</span>）.append（<span class="string">"va"</span>）.toString（）；</span><br><span class="line">        System.out.<span class="built_in">println</span>（str2.intern（）==str2）；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。产生差异的原因是：在JDK 1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<strong>而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个</strong>。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p><p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>]]></content>
    
    <summary type="html">
    
      深入理解Java虚拟机;Java内存区域与内存溢出异常;
    
    </summary>
    
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
